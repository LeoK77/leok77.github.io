<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库系统实验-第三章-数据库的安全性控制</title>
      <link href="2021/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p></blockquote><h2 id="实验3-1——用户标识与鉴别"><a href="#实验3-1——用户标识与鉴别" class="headerlink" title="实验3.1——用户标识与鉴别"></a>实验3.1——用户标识与鉴别</h2><blockquote><p>实验目的：本实验的目的是通过实验加深对数据安全性的理解，并掌握SQL Server中有关用户登录认证及管理方法</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server Management Studio中设置SQL Server的安全认证模式</li><li>在SQL Server中建立一个名为“李勇”的登录用户、数据库用户</li><li>演示在SQL Server中取消“李勇”这个用户</li></ol><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server Management Studio中将所属的SQL Server服务器设置为Windows NT和SQL Server混合安全认证模式</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512081800.png" alt="image-20210512081800613"></p><p>(2)在SQL Server Management Studio中为自己建立一个服务器用户、数据库用户</p><p>以新建的服务器用户“李勇”登录，在服务器属性的权限页面如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512082802.png" alt="image-20210512082802666"></p><p>(3)使用Transact_SQL撤销李勇这个登录账号(在管理员模式下)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School</span><br><span class="line"><span class="keyword">exec</span> sp_revokedbaccess <span class="string">&#x27;李勇&#x27;</span>;</span><br><span class="line"><span class="keyword">exec</span> sp_droplogin <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512083644.png" alt="image-20210512083644791"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在School数据库中创建账号”王二”，密码：123，并向其授予数据库访问权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_addlogin <span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;School&#x27;</span>, <span class="string">&#x27;English&#x27;</span></span><br><span class="line">go</span><br><span class="line">USE School</span><br><span class="line">go</span><br><span class="line"><span class="keyword">exec</span> sp_grantdbaccess <span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)撤销“王二”这个账号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School</span><br><span class="line"><span class="keyword">exec</span> sp_revokedbaccess <span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="keyword">exec</span> sp_droplogin <span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="实验3-2——自主存取控制"><a href="#实验3-2——自主存取控制" class="headerlink" title="实验3.2——自主存取控制"></a>实验3.2——自主存取控制</h2><blockquote><p>实验目的：通过实验加深对数据库存取控制机制的理解，通过自主存取控制进行权限管理，熟悉SQL-Server中的角色管理</p></blockquote><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>分别通过SQL Server Management Studio和SQL语言的数据控制功能，设置和管理数据操作权限。对新建用户“李勇”授予school数据库中students表的SELECT权限</li><li>通过SQL Server Management Studio，实现对SQL Server的用户和角色管理。具体是创建一个数据库角色OP_of_students，代表一个可以对students表进行操作的操作员，对角色的权限进行设置，并将“李勇”、“Web”添加到这个角色中。该实验体现角色应用灵活高效的特点</li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server中建立一个名为“李勇”的登录用户、School数据库的用户</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512090112.png" alt="image-20210512090112639"></p><p>(2)使用用户名为李勇，输入用户口令登录到SQL Server Management Studio，新建SQL查询。在“查询”的文本编辑器中输入SQL语句“SELECT * FROM STUDENTS”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息 229，级别 14，状态 5，第 3 行</span><br><span class="line">拒绝了对对象 &#39;STUDENTS&#39; (数据库 &#39;School&#39;，架构 &#39;dbo&#39;)的 SELECT 权限。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512090738.png" alt="image-20210512090738564"></p><p>(3)将School数据库的操作权限赋予数据库用户李勇</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以管理员身份登录</span></span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> STUDENTS</span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(4)在School数据库中新建OP_of_students角色</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512091455.png" alt="image-20210512091455445"></p><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)以sa账号登录SQL Server Management Studio，按“新建查询”快捷键，输入下列代码并执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;happyrat&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>, <span class="keyword">insert</span>, <span class="keyword">update</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> public;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">select</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br><span class="line">DENY <span class="keyword">update</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br></pre></td></tr></table></figure><p>(2)第1行代码新建了一个名为”李勇”的登录账户，”123456”是什么？”李勇”登录账户将映射为数据库用户名happyart，为什么？将是哪个数据库的用户？<br>解释第4~7行代码的作用。<br>若以账户李勇登录服务器，能否对school数据库的表students进行select和update操作，为什么？</p><ol><li>“123456”是”李勇”账户的口令(Password)</li><li>第3行代码中，通过sp_grantdbaccess将’李勇’映射到了’happyart’用户名</li><li>将是”School”数据库的用户，因为第2行代码将当前数据库切换为了”School”数据库</li><li>第4行代码：将对表STUDENTS的查询、插入、更新权限授予PUBLIC用户组</li><li>第5行代码：将对表STUDENTS的所有权限授予”happyart”用户名(即登录账户”李勇”)</li><li>第6行代码：收回”happyart”用户对表STUDENTS的查询权限</li><li>第7行代码：禁止”happyart”用户对表STUDENTS的更新权限</li><li>若以”李勇”登录服务器，可以对School数据库的表STUDENTS进行SELECT操作，不能进行UPDATE操作，因为”李勇”在School数据库中映射到用户名”happyart”上；虽然第6行代码收回了SELECT权限，但”李勇”依旧属于PUBLIC组，而PUBLIC组具有对STUDENTS的SELECT权限；第7行代码是禁止happyart对STUDENTS更新，即便PUBLIC组具有此权限，用户”李勇”也无法进行UPDATE操作，因为被DENY语句禁用了</li></ol><h2 id="实验3-3——视图机制在自主存取控制上的应用"><a href="#实验3-3——视图机制在自主存取控制上的应用" class="headerlink" title="实验3.3——视图机制在自主存取控制上的应用"></a>实验3.3——视图机制在自主存取控制上的应用</h2><blockquote><p>实验目的：通过实验加深对数据安全性的理解，熟悉视图机制在自主存取控制上的应用</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>创建选课表CHOICES上的视图CS_View，授权给计算机系的讲授计算科学这门课程(课程号：10010)的数据库用户李勇，让其具有视图上的SELECT权限</li><li>对视图上的Score属性列的UPDATE权限授予用户李勇，可以修改学生的成绩，但是不能对学生的基本信息，如学号、选课号进行修改</li></ol><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在数据库School上创建用户”李勇”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)用sa账户登录数据库。新建查询，然后在CHOICES表上创建视图CS_View(选课课程号10010)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_View</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CHOICES <span class="keyword">WHERE</span> Cid<span class="operator">=</span><span class="string">&#x27;10010&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(3)在视图CS_View上给用户”李勇”授予School的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> dbo.CS_View <span class="keyword">TO</span> &quot;李勇&quot;;</span><br></pre></td></tr></table></figure><p>(4)将视图CS_View上Score列的更新权限授予用户”李勇”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(score) <span class="keyword">ON</span> CS_View <span class="keyword">TO</span> &quot;李勇&quot;;</span><br></pre></td></tr></table></figure><p>(5)以用户李勇登录服务器，对CS_View进行查询操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CS_View;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512125001.png" alt="image-20210512125001747"></p><p>(6)对no为500024940的学生的成绩进行修改，改为90分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS_View</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span><span class="number">90</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">no</span><span class="operator">=</span><span class="string">&#x27;500024940&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CS_View <span class="keyword">WHERE</span> <span class="keyword">no</span><span class="operator">=</span><span class="string">&#x27;500024940&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512125218.png" alt="image-20210512125217989"></p><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在数据库School上创建用户”王二”。在STUDENTS表上创建视图grade2000，把年级为2000的学生元组放入视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin N<span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess N<span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> grade2000 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="string">&#x27;2000&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)授予用户王二在视图grade2000的SELECT权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> grade2000 <span class="keyword">TO</span> &quot;王二&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span>N<span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> grade2000;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512130312.png" alt="image-20210512130312544"></p><h2 id="实验3-4——PUBLIC角色在安全性中的应用"><a href="#实验3-4——PUBLIC角色在安全性中的应用" class="headerlink" title="实验3.4——PUBLIC角色在安全性中的应用"></a>实验3.4——PUBLIC角色在安全性中的应用</h2><blockquote><p>实验目的：通过实验加深对PUBILC角色的理解，特别是PUBLIC角色在安全性管理中的应用</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server 2005 Management Studio中新建查询，创建test登录用户以public访问数据库，在school数据库的students表上授权查询操作给public，验证test用户是否可以查询students，再撤销public权限，再验证是否可以查询</li><li>在school数据库的students表上授权查询操作给public，并授权给test用户，验证test用户是否可以查询students，先撤销public权限，验证是否可以查询，再撤销test权限，再验证是否可以查询</li><li>在school数据库的students表上授权查询操作给public，并授权给test用户，验证test用户是否可以查询students，先撤销test权限，验证是否可以查询，再撤销public权限，再验证是否可以查询</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)以管理员用户登录SQL Server，创建test登录用户以public访问数据库，在school数据库的students表上授权查询操作给public；<br>再以test用户登录SQL Server，新建查询验证是否可以对students表进行查询操作；<br>再以管理员用户登录，撤销public权限，然后以test用户登录，查询students</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 新建test用户</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授权给public</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519112326.png" alt="image-20210519112326670"></p><p>(2)与管理员用户登录SQL SERVER，在school数据库的students表上授权查询操作给public和test；<br>再以test用户登录SQL Server，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回public的查询权限，再以test用户登录，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回test的查询权限，再以test用户登录，验证查询操作权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授权给public用户组和test用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC], test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销test权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519181535.png" alt="image-20210519181534971"></p><p>(3)与管理员用户登录SQL SERVER，在school数据库的students表上授权查询操作给public和test；<br>再以test用户登录SQL Server，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回test的查询权限，再以test用户登录，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回public的查询权限，再以test用户登录，验证查询操作权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授权给public用户组和test用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC], test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销test权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519182028.png" alt="image-20210519182028582"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><ul><li>从实验中可以看出，授权给public与授权给指定用户有什么区别？在实际应用中，哪个更安全一些？</li></ul><p>从实验中可以看出，当某个用户拥有来自多个用户组的对某个表的相同权限的时候，授权给public与授权给指定用户是没有区别的，当且仅当收回此用户从属的所有用户组及用户自身的此权限(或者使用DENY语句禁用相应权限)之后，才可以彻底收回此用户的相应权限；<br>在实际应用中授权给指定用户更为安全，避免收回用户权限之后，用户还具有来自其他用户组的此权限</p><h2 id="实验3-5——理解架构的安全性管理"><a href="#实验3-5——理解架构的安全性管理" class="headerlink" title="实验3.5——理解架构的安全性管理"></a>实验3.5——理解架构的安全性管理</h2><blockquote><p>实验目的：通过实验加深对SQL Server中新增加的特性——架构(Schema)的理解，并对自定义的架构进行权限的授予与撤销，掌握SQL Server中的架构管理</p></blockquote><h3 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server中创建一个user1用户，采用SQL Server身份验证，密码为user1，允许其访问数据库test，并加入dbowner的架构和角色成员，用user1登录SQL Server，创建表a，并查询表a，看执行语句是否正确？</li><li>在SQL Server中以管理员账户登录，再次创建表a，看执行是否正确，若正确，看看是否出现两个表a，若出现，执行一段插入语句insert a values(‘a’, ‘aa’)，在管理工具中查看数据插入到哪个表中？</li><li>分别在管理员账户和user1账户下新建查询，执行查询语句对表a进行查询，分别记录查询结果，并说明系统分别对哪个表a进行查询？</li></ol><h3 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server中创建一个user1的登录用户，采用SQL Server身份验证，密码user1，允许其访问数据库test，并加入dbowner的架构和角色成员；<br>用user1账户登录SQL Server新建查询，创建表a，在user1用户下查看test数据库下的对象</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br><span class="line"><span class="keyword">CREATE</span> LOGIN user1 <span class="keyword">with</span> password <span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>, default_database <span class="operator">=</span> test;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">for</span> LOGIN user1;</span><br><span class="line"><span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> user1 <span class="keyword">with</span> default_schema <span class="operator">=</span>db_owner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a;</span><br></pre></td></tr></table></figure><p>(2)以管理员账户登录SQL Server，创建表a，此时查询数据库test下对象，发现有两个表a</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520103614.png" alt="image-20210520103613933"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dbo.a;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> db_owner.a;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520103929.png" alt="image-20210520103929163"></p><p>(3)在SQL Server中以管理员账户登录，查询表a；再以user1账户登录，查询表a</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 管理员账户登录</span></span><br><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a;</span><br><span class="line"><span class="comment">-- 用户user1登录</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a;</span><br></pre></td></tr></table></figure><p>以管理员账户查询的是dbo.a，以user1账户查询的是db_owner.a，因为管理员账户的默认架构是dbo，而user1账户的默认架构是db_owner</p><h3 id="自我实践-4"><a href="#自我实践-4" class="headerlink" title="自我实践"></a>自我实践</h3><p>在实验中为什么能够成功地建立两个名称相同的表a？<br>如果对user1不分配dbowner的架构和角色成员，上述实验是否可以实现，请实验验证</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 管理员账户的默认架构是dbo，user1分配的默认架构是db_owner，所以创建表a时是在两个不同的架构中创建了同类型的表a，两者之间互不影响</span></span><br><span class="line"><span class="comment">-- 2. 如果不分配db_owner的架构和角色成员，上述实验不能实现</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> user1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">for</span> LOGIN user1;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 因为user1不属于db_owner的角色成员，所以user1不具有在test数据库中新建表的权限，也就无法创建两张表</span></span><br><span class="line"><span class="comment">-- 即便是user1属于db_owner的角色成员，不分配db_owner架构的情况下，user1的默认架构是dbo，同一数据库同一架构下的表名字互不相同，无法创建两张表</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520104939.png" alt="image-20210520104939880"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统-LeetCode刷题记录-MSSQLSERVER</title>
      <link href="2021/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-MSSQLSERVER/"/>
      <url>2021/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-MSSQLSERVER/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自<a href="https://leetcode-cn.com/problemset/database/">LeetCode的数据库模块</a>，使用的语言环境是SQL Server(因为2021春季学期学的是SQL Server)</p></blockquote><p><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 条件中要求“无论person是否有地址信息，都需要基于上述两表提供person的地址信息”，即person无对应的地址信息时，需要返回NULL，可以使用左结合(LEFT JOIN)，需要注意此时不是用WHERE而是用ON</span></span><br><span class="line"><span class="keyword">SELECT</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">FROM</span> Person <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address</span><br><span class="line"><span class="keyword">ON</span> Person.PersonId <span class="operator">=</span> Address.PersonId;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 查询出来的列名要更改，不是默认的&quot;Salary&quot;，而是&quot;SecondHighestSalary&quot;</span></span><br><span class="line"><span class="comment">-- 2. 对于第二高的薪水，也就是比最高的薪水中，找最高的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary) <span class="string">&#x27;SecondHighestSalary&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Salary<span class="operator">&lt;</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary)</span><br><span class="line">    <span class="keyword">FROM</span> Employee</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name &quot;Employee&quot;</span><br><span class="line"><span class="keyword">FROM</span> Employee Staff</span><br><span class="line"><span class="keyword">WHERE</span> Salary<span class="operator">&gt;</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> Salary</span><br><span class="line">    <span class="keyword">FROM</span> Employee Manager</span><br><span class="line">    <span class="keyword">WHERE</span> Staff.ManagerId <span class="operator">=</span> Manager.Id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Email</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Email <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/">183. 从不订购的客户</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name &quot;Customers&quot;</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> CustomerId</span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/department-highest-salary/">184. 部门工资最高的员工</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 当一个表被重命名之后，使用这个表中的字段值时，需要用重命名后的表名</span></span><br><span class="line"><span class="keyword">SELECT</span> Department.Name &quot;Department&quot;,</span><br><span class="line">       Employee_Cur.Name &quot;Employee&quot;,</span><br><span class="line">       Salary</span><br><span class="line"><span class="keyword">FROM</span> Employee Employee_Cur, Department</span><br><span class="line"><span class="keyword">WHERE</span> DepartmentId <span class="operator">=</span> Department.Id</span><br><span class="line">  <span class="keyword">AND</span> Salary<span class="operator">=</span>(</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary)</span><br><span class="line">      <span class="keyword">FROM</span> Employee Employee_SameDept</span><br><span class="line">      <span class="keyword">WHERE</span> Employee_Cur.DepartmentId <span class="operator">=</span> Employee_SameDept.DepartmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. DELETE后面需要指定要删除的表</span></span><br><span class="line"><span class="comment">-- 2. DELETE可以FROM多张表(或一张表指定多个别名)，并对这多张表使用连接，只需在前面指定要删除满足条件的哪张表的元组即可</span></span><br><span class="line"><span class="keyword">DELETE</span> Person_Del</span><br><span class="line"><span class="keyword">FROM</span> Person Person_Del, Person Person_Save</span><br><span class="line"><span class="keyword">WHERE</span> Person_Del.Email <span class="operator">=</span> Person_Save.Email</span><br><span class="line">  <span class="keyword">AND</span> Person_Del.Id <span class="operator">&gt;</span> Person_Save.Id;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rising-temperature/">197. 上升的温度</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 此题使用到了Date类型的字段，计算两个日期之间的差值可以使用DATEDIFF函数，DATEDIFF(datepart,startdate,enddate)，比如此题是今天昨天，那么就是day，属于“天”这个量级</span></span><br><span class="line"><span class="comment">-- 2. WHERE后面条件的顺序也是需要考虑的，在AND的情况下，使用资源少的条件应该放在前面，因为先判断前面的再判断后面的，比如此题这两个条件，如果把DATEDIFF放在前面就会超时</span></span><br><span class="line"><span class="keyword">SELECT</span> Today.id</span><br><span class="line"><span class="keyword">FROM</span> Weather Today, Weather Yestoday</span><br><span class="line"><span class="keyword">WHERE</span> Today.Temperature<span class="operator">&gt;</span>Yestoday.Temperature</span><br><span class="line">  <span class="keyword">AND</span> DATEDIFF(<span class="keyword">day</span>, Yestoday.recordDate, Today.recordDate)<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, population, area</span><br><span class="line"><span class="keyword">FROM</span> World</span><br><span class="line"><span class="keyword">WHERE</span> area<span class="operator">&gt;=</span><span class="number">3000000</span></span><br><span class="line">   <span class="keyword">OR</span> population<span class="operator">&gt;=</span><span class="number">25000000</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/">596. 超过5名学生的课</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 要求中有一个条件是“学生在每个课中不应被重复计算”，按照常识来说，如题所示的这个表中应该没有重复项，但是为了安全期间，在COUNT函数中增加了DISTINCT来进行去重</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line"><span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> student)<span class="operator">&gt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/not-boring-movies/">620. 有趣的电影</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. LIKE后面的字符串用单引号括起来，不可以用双引号</span></span><br><span class="line"><span class="comment">-- 2. 判断两者是否相等就是用=，不要因为写其他语言写多的顺手写==</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cinema</span><br><span class="line"><span class="keyword">WHERE</span> description <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;boring&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-salary/">627. 变更性别</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注：参考自别人的解析，先使用ASCII函数将字符转换成ASCII码，计算得到转换后性别的ASCII码后，再用CHAR函数转换为字符类型</span></span><br><span class="line"><span class="keyword">UPDATE</span> salary</span><br><span class="line"><span class="keyword">SET</span> sex<span class="operator">=</span><span class="type">CHAR</span>(ASCII(<span class="string">&#x27;m&#x27;</span>) <span class="operator">-</span> ASCII(sex) <span class="operator">+</span> ASCII(<span class="string">&#x27;f&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Cygwin安装oh-my-zsh</title>
      <link href="2021/04/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/"/>
      <url>2021/04/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>起因是上《编译原理》这门课的时候需要使用lex、bison环境，然后后面的实验需要使用makefile，虽然可以自己写bat脚本作为替代品(懒得装make)，但是有现成的文件为啥不用呢？结果在wsl里面make的时候总是报错，达不到特别好的效果(老师给的makefile是在Cygwin环境下用的)，索性就转投Cygwin的怀抱了，而且增加了一些对Cygwin的了解之后发现还是挺香的(作为一个颜狗，之前主要是被复古的大黑框框给劝退了)，因为是真的轻量级并且好用(wsl作为一个相对完整的Linux系统，当然比cygwin要庞大一些；我的CLion里的编译器也替换为了Cygwin的gcc)，为了让自己更方便的使用Cygwin，所以决定还是装一下zsh比较好。</p></blockquote><blockquote><p>安装Cygwin的部分就跳过了，反正也没啥好说的，这篇博客更多的是为了记录一下这次的操作过程，以便于以后自己换电脑的时候可以重新弄好，不用再从头找一遍解决方案</p></blockquote><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p>安装zsh有多个方法，这里展示三种：①使用安装程序的GUI安装；②使用安装程序的CLI安装；③安装包管理器apt-cyg，并用apt-cyg安装。在这几种方法里面任选其一即可</p><p>需要注意的是在使用前两种方法的时候，Cygwin不能处于运行状态，或者说不可以有正在运行的Cygwin窗口，无论是Cygwin Terminal还是在Windows Terminal中使用Cygwin的bash/zsh等shell都不可以</p><h3 id="使用安装程序的GUI安装"><a href="#使用安装程序的GUI安装" class="headerlink" title="使用安装程序的GUI安装"></a>使用安装程序的GUI安装</h3><p>所谓安装程序就是从官网下载下来的Cygwin安装程序，即”setup-x86_64.exe”，不断下一步直到出现如图所示这个页面，然后根据图片中的信息在“Full”视图中搜索“zsh”并选择自己想安装的版本，我这里是“keep”是因为我已经装过了，一般情况下需要选择一串数字版本号，比如我现在的版本是“5.8-1”，即前面的Current——当前版本。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414122916.png" alt="image-20210414122915885"></p><h3 id="使用安装程序的CLI安装"><a href="#使用安装程序的CLI安装" class="headerlink" title="使用安装程序的CLI安装"></a>使用安装程序的CLI安装</h3><p>安装程序除了可以在窗口执行以外，也提供命令行操作，不过执行命令的时候还是会出现一个窗口，然后安装结束Ctrl+C一下就好了。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\Cygwin_setup<span class="literal">-x86_64</span>.exe <span class="literal">-q</span> <span class="literal">-P</span> zsh,<span class="built_in">wget</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414123710.png" alt="image-20210414123710480"></p><h3 id="使用apt-cyg安装"><a href="#使用apt-cyg安装" class="headerlink" title="使用apt-cyg安装"></a>使用apt-cyg安装</h3><blockquote><p>apt-cyg GitHub: <a href="https://github.com/transcode-open/apt-cyg">https://github.com/transcode-open/apt-cyg</a></p></blockquote><p>apt-cyg是一个类似于apt-get的包管理器，适用于Cygwin，可以使用其GitHub中的说明直接安装，可能是我的网络问题，一直失败，所以我采用先自行下载到本地再执行安装的方式：</p><p>1、打开上述apt-cyg的GitHub连接，找到仓库中的apt-cyg文件，直接点击即可，然后在此文件的页面点击那个”Raw”，进入一个新的页面，复制这个页面的链接然后下载此连接内容，保存为apt-cyg文件(没有拓展名)，并将其放在/home/username目录下，效果如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414161614.png" alt="image-20210414161613987"></p><p>2、安装apt-cyg，执行完下述语句之后需要重启Cygwin Terminal，不然无法使用apt-cyg命令</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">install apt-cyg /bin</span><br></pre></td></tr></table></figure><p>3、使用apt-cyg安装zsh</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">apt-cyg install zsh</span><br></pre></td></tr></table></figure><p>跑码结束且无ERROR即为安装成功，可以通过在shell中输入zsh来判断是否可用(可能需要重开一下Cygwin Terminal)</p><h2 id="设置zsh为Cygwin的默认shell"><a href="#设置zsh为Cygwin的默认shell" class="headerlink" title="设置zsh为Cygwin的默认shell"></a>设置zsh为Cygwin的默认shell</h2><p>在Cygwin的安装目录中，打开/etc/nsswitch.conf文件，并在其中添加”db_shell: /bin/zsh”；比如我的Cygwin安装在”C:\ToolBox\CygWin”目录下，我需要打开的文件就是”C:\ToolBox\CygWin\etc\nsswitch.conf”，然后在其中添加上述内容</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414124810.png" alt="image-20210414124810708"></p><p>这样在打开Cygwin Terminal应用程序的时候就会默认打开zsh而不是bash了</p><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><p>对于我来说，我习惯用oh-my-zsh(没错，我是一个颜狗)，而且我并不会用到什么插件，我需要的仅仅是shell的美化和好看，所以我不在意别人说的ohmyzsh资源浪费问题，既然已经将Cygwin的shell换成了zsh，那么安装oh-my-zsh就是我接下来要做的事情</p><blockquote><p>按照oh-my-zsh的文档使用install.sh安装总是安不上，所以我选择手动将其下载下来，再替换.zshrc文件的方法</p></blockquote><p>1、下载oh-my-zsh，打开oh-my-zsh的GitHub仓库，然后下载zip包即可(由于我git clone一直失败，所以只好手动下载zip了，如果对自己网络有信息，完全可以git clone)，就不图示说明如何操作了，挺简单的操作</p><blockquote><p>oh-my-zsh GitHub: <a href="https://github.com/ohmyzsh/ohmyzsh">https://github.com/ohmyzsh/ohmyzsh</a></p></blockquote><p>2、解压oh-my-zsh到Cygwin下的/home/username文件夹下，需要注意的是这里如果在Windows下解压此文件可能需要管理员权限，为了防止权限问题，这里展示如何在Cygwin下使用命令行解压缩此zip文件：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment"># 查看当前路径，此操作需要当前目录是 /home/username ，如果不是的话可以使用 cd ~ 操作到达 /home/username</span></span><br><span class="line">cp /cygdrive/c/Users/LeoK77/Downloads/Compressed/ohmyzsh-master.zip ./ <span class="comment"># 将下载下来的ohmyzsh-master.zip文件复制到当前目录(/home/username)，此操作需要将前面这个路径替换为自己的ohmyzsh-master.zip文件的路径</span></span><br><span class="line">unzip ohmyzsh-master.zip -d ./ <span class="comment"># 执行解压操作，直接解压到当前路径下</span></span><br><span class="line">mv ohmyzsh-master ./.oh-my-zsh <span class="comment"># 重命名为 .oh-my-zsh 文件夹</span></span><br></pre></td></tr></table></figure><p>解压之后，目录结构应该如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414130233.png" alt="image-20210414130233020"></p><p>3、将.oh-my-zsh目录下的templates/zshrc.zsh-template中的内容复制到home/username目录下的.zshrc中，可以在Cygwin中使用如下命令</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">cp ./.oh-my-zsh/templates/zshrc.zsh-template ./.zshrc</span><br></pre></td></tr></table></figure><p>4、修改主题，如果喜欢默认主题的话可以不执行此操作，如果不喜欢的话，可以自行修改主题，我比较喜欢的主题是”duellj”，所以我需要编辑”.zshrc”文件，将其中的”ZSH_THEME=”robbyrussell””改为”ZSH_THEME=”duellj””，主题效果及需要修改的地方都如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414155347.png" alt="image-20210414155347565"></p><blockquote><p>至此，Cygwin下的oh-my-zsh已经配置好了(没错，我不改其他配置，因为我只是一个颜狗，对于我来说这些就够了)，此时再打开Cygwin Terminal的时候就是一个有着oh-my-zsh的黑框框了；但对于一个颜狗来说，这显然还是不够好看，所以我要把这个黑框框加入到Windows Terminal里面，虽然同样是黑框框，但我还是喜欢Windows Terminal</p></blockquote><h2 id="在Windows-Terminal中添加Cygwin"><a href="#在Windows-Terminal中添加Cygwin" class="headerlink" title="在Windows Terminal中添加Cygwin"></a>在Windows Terminal中添加Cygwin</h2><blockquote><p>不用Windows Terminal的可以跳过这一部分了，如果没安装但是想用的可以自行去Win10应用商店下载一个(免费应用，而且是一个相对好看的黑框框)，然后按照下述步骤操作</p></blockquote><p>打开Windows Terminal，找到设置，然后点击即可打开配置文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414155924.png" alt="image-20210414155924123"></p><p>然后可以照着前面的配置自己添加一个Cygwin zsh的中断配置，guid可以自己造一个，也可以在Cygwin Terminal中使用uuidgen命令随机生成一个，只要不和前面的那几项重复即可，name可以自己随便命名，比如我这里直接写成了”Cygwin-Zsh”，commandline是zsh所在地址，在你的Cygwin安装目录下的/bin/zsh.exe位置，”-i -l”是为了刷新终端，不然会有些问题(参考自<a href="https://leo3418.github.io/zh/2020/05/24/cygwin-git-bash-in-wt.html">这篇文章</a>)，然后就可以在Windows Terminal中选择使用Cygwin zsh了。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;7090d3b0-57a7-4078-b6aa-3a495228e8aa&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Cygwin-Zsh&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;C:\\ToolBox\\CygWin\\bin\\zsh.exe -i -l&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%B8%BACygwin%E5%AE%89%E8%A3%85oh-my-zsh/20210414160552.png" alt="image-20210414160552904"></p>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cygwin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第五章-树与二叉树</title>
      <link href="2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>树是n(n&gt;=0)个结点的有限集合，n=0时称为空树。<br>任意非空树应该满足：①有且仅有一个特定的称为根的结点；②当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根节点的子树</p><p>n个结点的树只有n-1条边：除了根结点以外，每个结点都有前驱结点，与前驱结点通过边相连</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413132651.png" alt="image-20210413132651113"></p><p>度：树中一个结点的子结点的个数；如上图所示树中，A的度是3(有B、C、D三个子结点)，E的度是2(有K、L两个子结点)，F的度是0(没有子结点)<br>树中最大度数称为树的度，如上图所示树中，最大度数是3，则这棵树的度便是3</p><p>分支结点：度&gt;0的结点(有孩子结点)<br>叶子结点：度=0的结点(没有孩子结点)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413133140.png" alt="image-20210413133140758"></p><p>树的高度(深度)是树中结点的最大层数，如上图所示树的高度(深度)是4</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413133519.png" alt="image-20210413133519530"></p><p>路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的；因为树中的分支是有向的(从双亲结点指向孩子结点)，所以路径一定是自上而下的。如A到K结点的路径是：ABEK<br>路径长度：路径上所经历的边的个数，如A到K结点的路径长度是3(经历了三条边)</p><p>森林：m(m&gt;=0)棵互不相交的树的集合</p><ul><li>树的性质：<ol><li>树中的结点数等于所有结点的度数加1</li><li>度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1)</li><li>高度为h的m叉树至多有(m^h-1)/(m-1)个结点</li><li>具有n个结点的m叉树的最小高度为[logm^(n(m-1)+1)]以m为底n(m-1)+1的对数向上取整</li></ol></li></ul><h2 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h2><h3 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h3><p>二叉树是n(n&gt;=0)个结点的有限集合。①n=0时，二叉树为空；②n&gt;=0时，由根节点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树也分别是一棵二叉树</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413134433.png" alt="image-20210413134433610"></p><table><thead><tr><th></th><th>二叉树</th><th>度为2的有序树</th></tr></thead><tbody><tr><td>结点个数</td><td>可以为空</td><td>至少有3个结点</td></tr><tr><td>孩子结点</td><td>始终有左右孩子之分</td><td>孩子结点的次序是相对的，只有一个孩子结点的时候不区分次序</td></tr></tbody></table><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树：一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413134749.png" alt="image-20210413134749494"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树：设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p><ul><li>完全二叉树的性质：<ol><li>若i&lt;=(n/2)，则结点i为分支结点，否则为叶子结点</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点，都依次排在最左边的位置上</li><li>度为1的结点若存在，则只有一个，且是编号最大的分支结点，其孩子结点一定是左结点</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135301.png" alt="image-20210413135301492"></p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>二叉排序树：一棵二叉树，若树非空则具有如下性质——对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点；二叉排序树的子树也是一棵二叉排序树</p><ul><li>二叉排序树(BST)，也称二叉查找树，或者为空树，或者为满足如下条件的非空树：<ol><li>若左子树非空，则左子树上所有结点关键字值均<strong>小于</strong>根结点的关键字</li><li>若右子树非空，则右子树上所有结点关键字值均<strong>大于</strong>根结点的关键字</li><li>左、右子树本身也分别是一棵二叉排序树</li></ol></li><li>由上述定义可知，二叉排序树中没有关键字值相等的两个结点，每个关键字值若出现则只可以出现一次</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135452.png" alt="image-20210413135452509"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树(AVL)：树上<strong>任意结点</strong>的左子树和右子树的深度之差不超过1</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135658.png" alt="image-20210413135658286"></p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>1、非空二叉树上的叶子结点数等于**度为2的结点数(n2)**加1，即n0=n2+1</p><p>非空二叉树上的结点总数=n0+n1+n2=n1+2n2+1</p><p>2、非空二叉树上第k层上至多有2^(k-1)个结点(k&gt;=1)</p><p>3、高度为h的二叉树至多有2^h-1个结点(h&gt;=1)</p><p>4、对完全二叉树按从上到下、从左到右的顺序依次编号为1、2、3、……、n，则有如下关系：</p><ul><li>当i&gt;1时，结点i的双亲结点标号为[i/2](取下界)，即i为偶数时，双亲结点的编号为i/2，它是双亲结点的左孩子；i是奇数时，其双亲结点的编号是(i-1)/2，他是双亲结点的右孩子</li><li>当2i&lt;=n时，结点i的左孩子编号为2i，否则无左孩子</li><li>当2i+1&lt;=n时，结点i的右孩子编号为2i+1，否则无右孩子</li></ul><p>5、具有n个(n&gt;=0)结点的完全二叉树的高度为[log2^n]+1或[log2^(n+1)]</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>二叉树的顺序存储：用一组连续的存储单元依次自上而下，自左向右存储<strong>完全二叉树</strong>上的结点元素</p><p>在完全二叉树中依次编号，对于结点i：若存在左孩子，则编号为2i；若存在右孩子，则编号为2i+1</p><p>二叉树的顺序存储中，在二叉树不是完全二叉树的情况下，需要补充空结点使得二叉树成为一棵完全二叉树，这也就导致了在最坏的情况下(每个结点有孩子结点的时候只会有右孩子结点)会极其浪费存储空间，因此顺序存储的方式比较适合完全二叉树</p><h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><p>二叉树的链式存储：用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储；那么二叉树的结点结构就包含数据域data，和两个指针lchild和rchild分别指向左孩子和右孩子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413141537.png" alt="image-20210413141537240"></p><p>含有n个结点的二叉链表中，有n+1个空链域</p><h2 id="二叉树的遍历及线索二叉树"><a href="#二叉树的遍历及线索二叉树" class="headerlink" title="二叉树的遍历及线索二叉树"></a>二叉树的遍历及线索二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul><li>若二叉树非空：<ol><li>访问根结点</li><li>先序访问左子树</li><li>先序访问右子树</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142115.png" alt="image-20210413142115148"></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul><li>若二叉树非空：<ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142243.png" alt="image-20210413142243031"></p><ul><li>中序遍历的非递归算法，借助栈：<ol><li>初始时依次扫描根结点的所有左侧结点并将它们一一进栈</li><li>出栈一个结点，访问它</li><li>扫描该结点的右孩子结点并将其进栈</li><li>依次扫描右孩子结点的所有左侧结点并一一进栈</li><li>反复该过程直到栈空为止</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul><li>若二叉树非空：<ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142426.png" alt="image-20210413142426760"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413145333.png" alt="image-20210413145333840"></p><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul><li>层次遍历，即按照编号的顺序遍历，借助队列：<ol><li>初始时将根入队并访问根结点</li><li>若有左子树，则将左子树的根入队</li><li>若有右子树，则将右子树的根入队</li><li>然后出队，访问该结点，并执行2.3.4步骤</li><li>反复该过程直到队列为空</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4><p>先(后)序遍历序列和中序遍历序列可以确定一棵二叉树，但是先序遍历序列和后序遍历序列不能确定一棵二叉树</p><ul><li>由中序遍历和先序遍历序列构造二叉树：<ol><li>在先序序列中，第一个结点是根结点</li><li>根结点将中序遍历序列划分为两部分</li><li>然后在先序序列中确定两部分的结点，并且两部分的第一个结点分别为左子树的根和右子树的根</li><li>在子树中递归重复该过程，便能唯一确定一棵二叉树</li></ol></li></ul><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>线索化：若无左子树，则将左指针指向其前驱结点；若无右子树，则将右指针指向其后继结点</p><p>PS：前驱结点和后继结点由遍历方式的不同而不同，比如下图便是同一棵树的不同遍历方式的线索二叉树；前驱结点就是遍历顺序中的前一个结点，后继结点就是遍历顺序中的下一个结点；最后一个结点没有后继结点，如先序遍历序列中的6，因为没有后继结点，所以它的是右指针依旧是空指针</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413145912.png" alt="image-20210413145912124"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相较于二叉树的结点结构，线索二叉树的结点结构增加了两个标志位</span></span><br><span class="line"><span class="comment">// 若标志域取值为0，则表示指针域指向孩子；若标志域取值为1，则表示指针域指向前驱或后继</span></span><br><span class="line"><span class="comment">// 比如，ltag==0时，lchild指向左孩子；ltag==1时，lchild指向前驱结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>上述线索二叉树结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表</p><p>在中序线索二叉树中，中序遍历序列的第一个结点是中序线索二叉树中的最左侧的结点，最后一个结点是中序线索二叉树中的最右侧的结点</p><ul><li>中序线索二叉树的前驱结点：<ul><li>若左指针为线索，则其指向结点为前驱结点</li><li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</li></ul></li><li>中序线索二叉树的后继结点：<ul><li>若右指针为线索，则其指向结点为后继结点</li><li>若右指针为右孩子，则其右子树的最左侧结点为后继结点</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序线索二叉树线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p, ThreadTree *pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InTread(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入头结点的中序线索二叉树：头结点的左指针指向根结点，遍历序列第一个结点的左指针指向头结点，头结点的右指针指向遍历序列的最后一个结点，遍历序列最后一个结点的右指针指向头结点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序线索二叉树的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=FirstNode(T);p!=<span class="literal">nullptr</span>;p=NextNode(p))&#123;</span><br><span class="line">        visti(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1、双亲表示法：采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置；根结点的下标为0，其伪指针域为-1.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413153644.png" alt="image-20210413153644176"></p><p>2、孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;           <span class="comment">// 孩子结点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子结点的指针</span></span><br><span class="line">&#125;CNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;       <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">child</span>;</span> <span class="comment">// 第一个孩子结点的指针</span></span><br><span class="line">&#125;PNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413155106.png" alt="image-20210413154315418"></p><p>3、孩子兄弟表示法：以二叉链表作为树的存储结构，又称二叉树表示法(左孩子右兄弟)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, CSTree;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413155831.png" alt="image-20210413155831659"></p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>双亲表示法</td><td>寻找结点的双亲结点效率高</td><td>寻找结点的孩子结点效率低</td></tr><tr><td>孩子表示法</td><td>寻找结点的孩子结点效率高</td><td>寻找结点的双亲结点效率低</td></tr><tr><td>孩子兄弟表示法</td><td>寻找结点的孩子结点效率高，方便实现树转换为二叉树</td><td>寻找结点的双亲结点效率低</td></tr></tbody></table><h3 id="树、森林与二叉树"><a href="#树、森林与二叉树" class="headerlink" title="树、森林与二叉树"></a>树、森林与二叉树</h3><h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><p>树转换为二叉树：每个结点左指针指向它的第一个孩子结点，有指针指向它在树中相邻的兄弟结点</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413160400.png" alt="树-&gt;二叉树"></p><p>二叉树转换为树：即上述转换过程的逆过程</p><p>森林与二叉树的转换：将每一棵树都转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树；即每棵树转化为二叉树，后一棵树的根节点视为前一棵树的根节点的兄弟结点，然后根据“右兄弟”的原则进行连接，转化为常见形式</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413161214.png" alt="image-20210413161214653"></p><p>二叉树转换为森林即上述的逆过程，从根结点一路拆右孩子结点的连接使其转化为n棵二叉树，再分别将这些二叉树转化为树</p><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><p>树的遍历：按照某种方式访问树中的每个结点，且仅访问一次，遍历方式有三种——先根遍历、后根遍历、层次遍历</p><ol><li>先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树</li><li>后根遍历：若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点</li><li>层次遍历：按照编号的顺序从左到右、从上到下的顺序遍历</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413162342.png" alt="树的先根遍历及二叉树的先序遍历"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413162417.png" alt="树的后根遍历及二叉树的中序遍历"></p><p>森林的遍历，有两种遍历方法——先序遍历、中序遍历</p><ul><li>先序遍历：若森林非空，则<ol><li>访问森林中第一棵树的根结点</li><li>先序遍历第一棵树的子树森林</li><li>先序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413163100.png" alt="image-20210413163100817"></p><ul><li>中序遍历：若森林非空，则<ol><li>中序遍历第一棵树的根节点的子树森林</li><li>访问第一棵树的根节点</li><li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413163305.png" alt="image-20210413163305810"></p><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center">后根遍历</td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table><h3 id="树的应用——并查集"><a href="#树的应用——并查集" class="headerlink" title="树的应用——并查集"></a>树的应用——并查集</h3><p>并查集：一种简单的集合表示；通常用树的<strong>双亲表示法</strong>作为并查集的存储结构，用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Initial(S);<span class="comment">//将集合S中的每个元素都初始化为只有一个单元素的子集合</span></span><br><span class="line">Union(S, Root1, Root2);<span class="comment">//把集合S中的子集合(互不相交)Root2并入子集合Root1</span></span><br><span class="line">Find(S, x);<span class="comment">//查找集合S中单元素x所在子集合，并返回该子集合的名字</span></span><br></pre></td></tr></table></figure><p>并查集实例(分为三个子集，我也不知道这是怎么分的)，如0是根结点，这个子集有四个结点，所以它的parent域是-4；6是0的子节点，所以5的parent域是0。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413165336.png" alt="并查集实例(分为三个子集)"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];<span class="comment">//默认下标就是其数据域的值，假如数据域有单独的值，需要再开一个数组或者使用结构体的形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        x=S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h3><p>二叉排序树的特点：BST的中序遍历序列是一个递增有序序列</p><p>在BST中执行<strong>查找</strong>操作：二叉树非空时，查找根结点，若相等则查找成功；若不等，则当小于根节点时，查找左子树；当大于根结点时，查找右子树；当查找到叶子结点仍没有查找到相应的值时，则查找失败。查找效率取决于树的高度，当BST接近平衡二叉树时，时间复杂度是O(log2^n)(n是结点个数)；最坏的情况下是O(n)，所有结点有子结点的时候有且仅有右节点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key, BSTNode *&amp;p)</span></span>&#123;</span><br><span class="line">    P=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">nullptr</span> &amp;&amp; key != T-&gt;data)&#123;</span><br><span class="line">        p=T;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BST执行<strong>插入</strong>操作：二叉树为空时，直接插入结点；二叉树非空时，当值小于根节点时，插入左子树；当值大于根节点时，插入右子树；当值等于根节点时不可以进行插入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        T = (BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">        T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造二叉排序树</strong>：读入一个元素并建立结点，若二叉树为空将其作为根结点；若二叉树非空，当值小于根节点时，插入左子树；当值大于根节点时，插入右子树；当值等于根节点时不进行插入。实际上就是不断调用<strong>插入</strong>操作来构造这棵二叉排序树</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, ElemType keys[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    T=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">        BST_Insert(T, keys[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树的<strong>删除结点</strong>操作：①若被删除结点z是叶子结点，则直接删除；②若被删除结点z只有一棵子树，则让结点z的子树成为结点z的父结点的子树，代替z结点；③若被删除结点z有两棵子树，则让结点z的中序序列直接后继代替结点z，并删去直接后继结点</p><h3 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>高度为h的最小平衡二叉树的结点数Nh=Nh-1+Nh-2+1，N0=0，N1=1</p><p>平衡二叉树的判断：利用递归的后序遍历过程——①判断左子树是一棵平衡二叉树；②判断右子树是一棵平衡二叉树；③判断以该结点为根的二叉树为平衡二叉树，若左子树和右子树均为平衡二叉树且左子树与右子树高度差的绝对值小于等于1则以该结点为根的二叉树是平衡二叉树</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> br=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild==<span class="literal">nullptr</span> &amp;&amp; bt-&gt;rchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        h=<span class="number">1</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Judge_AVL(bt-&gt;lchild, bl, hl);</span><br><span class="line">        Judge_AVL(bt-&gt;rchild, br, hr);</span><br><span class="line">        <span class="keyword">if</span>(hl&gt;hr)&#123;</span><br><span class="line">            h=hl+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h=hr+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(hl-hr)&lt;=<span class="number">1</span> &amp;&amp; bl==<span class="number">1</span> &amp;&amp; br==<span class="number">1</span>)&#123;</span><br><span class="line">            balance = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平衡二叉树的<strong>插入</strong>操作：先插入，后调整，每次调整最小不平衡子树，调整分为四种类型——①LL平衡旋转(右单旋转)；②</p><p>1、LL平衡旋转(右单旋转)：原因——在结点A的左孩子的左子树上插入了新结点<br>调整方法：右旋操作，将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413182610.png" alt="image-20210413182610737"></p><p>2、RR平衡旋转(左单旋转)：原因——在结点A的右孩子的右子树上插入了新结点<br>调整方法：左旋操作，将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413182926.png" alt="image-20210413182926484"></p><p>3、LR平衡旋转(先左后右双旋转)：原因——在结点A的左孩子的右子树上插入了新结点<br>调整方法：先左旋后右旋操作，将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413183312.png" alt="image-20210413183312540"></p><p>4、RL平衡旋转(先右后左双旋转)：原因——在结点A的右孩子的左子树上插入了新结点<br>调整方法：先右旋后左旋操作，将A的右孩子B的左孩子结点C代替B，然后再将C结点向上代替A的位置</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413183606.png" alt="image-20210413183539191"></p><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><p>带权路径长度：①路径长度——路径上所经历边的个数；②结点的权——结点被赋予的数值</p><p>树的带权路径长度：WPL，树中所有叶子结点的带权路径长度(结点的权*路径长度)之和</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413184654.png" alt="image-20210413184626562"></p><p>哈夫曼树，也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树</p><ul><li>哈夫曼树的构造算法：<ol><li>将n个结点作为n棵仅含有一个根结点的二叉树，构成森林F；</li><li>生成一个新结点，并从F中找出根结点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根结点的权值之和；</li><li>从F中删除这两棵树，并将新生成的树加入到F中；</li><li>重复2.3.步骤，直到F中只有一棵树为止</li></ol></li><li>哈夫曼树的性质：<ol><li>每个初始结点都会成为叶子结点，拥有左右子树的结点都为新生成的结点</li><li>权值越大离根结点越近，反之权值越小离根结点越远</li><li>哈夫曼树中没有结点的度为1</li><li>n个叶子结点的哈夫曼树的叶子结点总数为2n-1，其中度为2的结点数为n-1</li></ol></li></ul><p>编码：对于一个字符串序列，用二进制来表示字符</p><p>固定长度编码：每个字符的二进制串长度都相同<br>可变长度编码：每个字符的二进制串长度不完全相同<br>前缀编码：没有一个编码是另一个编码的前缀</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413185739.png" alt="image-20210413185739855"></p><p>哈夫曼编码：将字符的出现次数视为权重，构造哈夫曼树，然后依次读出编码，便可以得到最优的前缀编码(占存储空间最小，出现次数越多，二进制串长度越短)之一(因为哈夫曼树不唯一)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413190020.png" alt="image-20210413190020821"></p><p>哈夫曼树并不唯一(因为左右子树并不做严格规范)，所以每个字符对应的哈夫曼编码也不唯一，但是带权路径长度相同且最优</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第四章-串</title>
      <link href="2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/"/>
      <url>2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><h2 id="串的定义和实现"><a href="#串的定义和实现" class="headerlink" title="串的定义和实现"></a>串的定义和实现</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><p>串，即字符串(String)，是由零个或多个字符组成的有限序列，一般记为S=’a1a2a3……an’(n&gt;=0)</p><p>其中，S是串名，单引号(有的是双引号，比如C语言)括起来的字符序列是串的值；ai可以是字母、数字或其他字符；串中的字符的个数n称为串的长度，n=0时串称为空串，用(∅表示)</p><p>子串，串中任意个<strong>连续</strong>字符组成的子序列(空串也是子串)<br>主串，包含子串的串<br>字符在主串中的位置，字符在串中的序号，一般情况下是第一次出现的位置，且从1开始计数<br>子串在主串中的位置，子串的第一个字符在主串中的位置，一般情况下是子串第一次出现的位置</p><p><strong>串是一种特殊的线性表</strong>，数据元素之间呈线性关系</p><p>串的<strong>数据对象</strong>限定为字符集(如中文字符、英文字符、数字字符、标点字符等)</p><p>串的<strong>基本操作</strong>，如增删改查，一般是以子串为操作对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StrAssign(&amp;T, chars);   &#x2F;&#x2F;赋值操作。把串T赋值为chars</span><br><span class="line">StrCopy(&amp;T, S);         &#x2F;&#x2F;复制操作。把串S复制得到串T</span><br><span class="line">StrEmpty(S);            &#x2F;&#x2F;判空操作。若S为空串，则返回TRUE，否则返回FALSE</span><br><span class="line">StrLength(S);           &#x2F;&#x2F;求串长。返回串S的元素个数</span><br><span class="line">ClearString(&amp;S);        &#x2F;&#x2F;清空操作。将S清为空串</span><br><span class="line">DestroyString(&amp;S);      &#x2F;&#x2F;销毁串。将串S销毁(回收存储空间)</span><br><span class="line">Concat(&amp;T, S1, S2);     &#x2F;&#x2F;串连接。用T返回由S1和S2连接形成的新串</span><br><span class="line">SubString(&amp;Sub, S, pos, len); &#x2F;&#x2F;求子串。用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Index(S, T);            &#x2F;&#x2F;定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span><br><span class="line">StrCompare(S, T);       &#x2F;&#x2F;比较操作。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/20210411153722.png" alt="image-20210411153722518"></p><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAXLEN 255  &#x2F;&#x2F; 预定义最大串长为255</span><br><span class="line"></span><br><span class="line">typedef struct &#123;        &#x2F;&#x2F; 顺序串，静态分配</span><br><span class="line">    char ch[MAXLEN];    &#x2F;&#x2F; 每个分量存储一个字符</span><br><span class="line">    int length;         &#x2F;&#x2F; 串的实际长度</span><br><span class="line">&#125; SqString;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define INITSIZE 255    &#x2F;&#x2F; 串的初始长度预分配为255</span><br><span class="line"></span><br><span class="line">typedef struct SqDyString &#123;</span><br><span class="line">    char *ch&#123;&#125;;             &#x2F;&#x2F; 每个分量存储一个字符</span><br><span class="line">    int maxSize &#x3D; 0;        &#x2F;&#x2F; 串的最大长度</span><br><span class="line">    int length &#x3D; 0;         &#x2F;&#x2F; 串的实际长度</span><br><span class="line">&#125; SqDyString;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LinkNode &#123;</span><br><span class="line">    char val;               &#x2F;&#x2F; 字符值</span><br><span class="line">    struct LinkNode *next;  &#x2F;&#x2F; 下一个结点</span><br><span class="line">&#125; *LinkString;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/20210411155432.png" alt="image-20210411155432045"></p><h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><blockquote><p>  模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置</p></blockquote><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p>朴素模式匹配算法思想：将主串与模式串长度相同的子串搞出来，挨个与模式串对比，当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串</p><ul><li>时间复杂度，若模式串长度为m，主串长度为n：<ul><li>  最坏时间复杂度：O(nm)，最多需要比较(n-m+1)*m次；每个子串的前m-1个字符都和模式串匹配，只有第m个字符不匹配</li><li>  比较好的情况：每个子串的第1个字符就与模式串不匹配，</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SqString S, SqString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexS = k;</span><br><span class="line">    <span class="keyword">int</span> indexT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexS &lt;= S.length &amp;&amp; indexT &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[indexS] == T.ch[indexT]) &#123;</span><br><span class="line">            indexS++;</span><br><span class="line">            indexT++;    <span class="comment">// 继续比较后继字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k++;    <span class="comment">// 检查下一个子串</span></span><br><span class="line">            indexS = k;</span><br><span class="line">            indexT = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (indexT &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为KMP算法；其核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的，具体实现时通过一个next()函数实现，此函数本身包含了模式串的局部匹配信息。</p><p>next数组，当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配</p><p>串的<strong>前缀</strong>：包含第一个字符，且不包含最后一个字符的子串<br>串的<strong>后缀</strong>：包含最后一个字符，且不包含第一个字符的子串</p><p>当第j个字符匹配失败时，由前1~j-1个字符组成的串记为S，则：next[j]=S的最长相等前后缀长度+1，特别地，next[1]=0，next[2]=1</p><table><thead><tr><th>序号j</th><th>模式串</th><th>next[j]</th><th>解析</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>0</td><td>next[1]=0</td></tr><tr><td>2</td><td>b</td><td>1</td><td>next[2]=1</td></tr><tr><td>3</td><td>a</td><td>1</td><td>S=ab，最长相等前后缀为空，长度为0，next[3]=0+1=1</td></tr><tr><td>4</td><td>b</td><td>2</td><td>S=aba，最长相等前后缀为a，长度为1，next[4]=1+1=2</td></tr><tr><td>5</td><td>a</td><td>3</td><td>S=abab，最长相等前后缀为ab，长度为2，next[5]=2+1=3</td></tr><tr><td>6</td><td>a</td><td>4</td><td>S=ababa，最长相等前后缀为aba，长度为3，next[6]=3+1=4</td></tr></tbody></table><table><thead><tr><th>序号j</th><th>模式串</th><th>next[j]</th><th>解析</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>0</td><td>next[1]=0</td></tr><tr><td>2</td><td>a</td><td>1</td><td>next[2]=1</td></tr><tr><td>3</td><td>a</td><td>2</td><td>S=aa，最长相等前后缀为a，长度为1，next[3]=1+1=2</td></tr><tr><td>4</td><td>a</td><td>3</td><td>S=aaa，最长相等前后缀为aa，长度为2，next[4]=2+1=3</td></tr><tr><td>5</td><td>b</td><td>4</td><td>S=aaaa，最长相等前后缀为aaa，长度为3，next[5]=3+1=4</td></tr><tr><td>6</td><td>b</td><td>1</td><td>S=aaaab，最长相等前后缀为空，长度为0，next[6]=0+1=1</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法求出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next[T.length() + <span class="number">1</span>];</span><br><span class="line">    get_next(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.length() &amp;&amp; j &lt; T.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i - <span class="number">1</span>] == T[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt;= T.length() ? <span class="keyword">int</span>(i - T.length()) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取nextval数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(<span class="built_in">string</span> T, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[T.length() + <span class="number">1</span>];</span><br><span class="line">    get_next(T, next);</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= T.length(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[next[j]] == T[j]) &#123;</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextval[j] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greaterKMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextval[T.length() + <span class="number">1</span>];</span><br><span class="line">    get_next(T, nextval);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.length() &amp;&amp; j &lt; T.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i - <span class="number">1</span>] == T[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt;= T.length() ? <span class="keyword">int</span>(i - T.length()) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第三章-栈和队列</title>
      <link href="2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><p>栈(stack)是<strong>只允许在一端(栈顶)进行插入或删除操作</strong>的<strong>线性表</strong></p><ol><li>空栈：字面意思，空的栈</li><li>栈顶：允许插入和删除的一端。位于栈顶的元素被称为“栈顶元素”</li><li>栈底：不允许插入和删除的一端。位于栈底的元素被称为“栈底元素”</li></ol><p>栈具有<strong>后进先出</strong>(Last In First Out, LIFO)的特点，即最后进入的元素最先出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitStack(&amp;S);&#x2F;&#x2F;初始化栈。构造一个空栈S，分配内存空间</span><br><span class="line">DestroyStack(&amp;S);&#x2F;&#x2F;销毁栈。销毁并释放栈S所占用的内存空间</span><br><span class="line">Push(&amp;S, x);&#x2F;&#x2F;进栈。若栈S未满，则将x加入使之成为新栈顶</span><br><span class="line">Pop(&amp;S, &amp;x);&#x2F;&#x2F;出栈。若栈S非空，则弹出栈顶元素，并用x返回</span><br><span class="line">GetTop(S, &amp;x);&#x2F;&#x2F;读栈顶元素。若栈S非空，则用x返回栈顶元素</span><br><span class="line"></span><br><span class="line">StackEmpty(S);&#x2F;&#x2F;判断一个栈S是否为空。若S为空，返回true，否则返回false</span><br></pre></td></tr></table></figure><p>n个不同元素进栈，出栈元素不同排列的个数为(1/(n+1))C(n,2n)，此公式成为卡特兰(Catalan)数，可采用数学归纳法证明。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410111512.png" alt="卡特兰数"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410111623.png" alt="image-20210410111623926"></p><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><blockquote><p>顺序栈：用顺序存储的方式实现栈</p></blockquote><p>顺序栈即用顺序存储方式实现，顺序存储实现数据结构时一般使用数组存储数据(作为数据域)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int        <span class="comment">// ElemType指向int是为了下面的演示不报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;                <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p>初始化栈时栈顶指针赋值不同会引起下面的函数具体实现不同，这里以-1作为参考</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时栈为空，若top指向0，则会访问到脏内存</span></span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序栈使用静态数组，自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈是否为空，与初始化时栈顶指针的值对应</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断栈是否已满，若未满才可以插入，注意栈顶指针的移动及插入操作的顺序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断是否为空，若非空才可以删除，注意删除操作及栈顶指针的移动的顺序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据还留存在数组(栈的数据域)内，只是逻辑上被删除了(无法被访问到)</span></span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序栈”的基本操作函数(2)</span></span><br><span class="line"><span class="comment"> *  初始化栈时使用 S.top=0;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时栈为空，使用S.top=0，则其他函数也需要做出一定修改</span></span><br><span class="line">    S.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序栈使用静态数组，自动销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据还留存在数组(栈的数据域)内，只是逻辑上被删除了(无法被访问到)</span></span><br><span class="line">    S.top--;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410114624.png" alt="image-20210410114624813"></p><h3 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h3><blockquote><p>链栈：以链式存储的方式实现栈</p></blockquote><p>下面主要展示“不带头结点的链栈”，以链表的头作为栈顶，插入和删除操作都作用于链表的表头</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">//宏定义为int以免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;          <span class="comment">// 用静态数组存放栈中元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure><p>构造一个空栈时，表头是一个空指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;head)</span> </span>&#123;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack &amp;head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的销毁与顺序栈不同，链栈的销毁是实际删除所有的结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(LiStack &amp;head)</span> </span>&#123;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(head)) &#123;</span><br><span class="line">        Pop(head, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈时，新建结点，新结点的数据域为待插入的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进栈。将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;head, ElemType x)</span> </span>&#123;</span><br><span class="line">    LinkNode *node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = x;</span><br><span class="line">    node-&gt;next = head;</span><br><span class="line">    head = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;head, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = head-&gt;data;</span><br><span class="line">    LinkNode *p = head;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(LiStack &amp;head, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = head-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410121648.png" alt="image-20210410121648471"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h3><p>队列(Queue)是<strong>只允许在一端进行插入，在另一端删除</strong>的线性表</p><ol><li>空队列：字面意思，空的队列</li><li>队尾：允许插入的一端。位于队尾的元素称为队尾元素</li><li>队头：允许删除的一端。位于队头的元素称为队头元素</li></ol><p>队列具有<strong>先进先出</strong>(First In First Out, FIFO)的特点，即最先入队的元素最先出队</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitQueue(&amp;Q);&#x2F;&#x2F;初始化队列。构造一个空队列Q，分配内存空间</span><br><span class="line">DestroyQueue(&amp;Q);&#x2F;&#x2F;销毁队列。销毁并释放队列Q所占用的内存空间</span><br><span class="line">EnQueue(&amp;Q, x);&#x2F;&#x2F;进队列。若队列Q未满，则将x加入使之成为新队列顶</span><br><span class="line">DeQueue(&amp;Q, &amp;x);&#x2F;&#x2F;出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span><br><span class="line">GetHead(Q, &amp;x);&#x2F;&#x2F;读队列顶元素。若队列Q非空，则用x返回队列顶元素</span><br><span class="line"></span><br><span class="line">QueueEmpty(Q);&#x2F;&#x2F;判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410123035.png" alt="image-20210410123035051"></p><h3 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h3><blockquote><p>顺序队列：使用顺序存储的方式实现队列</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10      <span class="comment">// 定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front;              <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;               <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">int</span> size;   <span class="comment">// 记录队列元素个数，解决了牺牲一个存储单元的问题(一)</span></span><br><span class="line">    <span class="comment">// 队空时size==0; 队满时size==MaxSize;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">        del = <span class="number">0</span>, ins = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Tag tag;    <span class="comment">// 最近进行的是删除(0)还是插入操作(1)，解决牺牲存储单元的问题(二)</span></span><br><span class="line">    <span class="comment">// 队空时 front==rear &amp;&amp; tag==del;</span></span><br><span class="line">    <span class="comment">// 队满时 front==rear &amp;&amp; tag==ins;</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p>下面介绍牺牲一个存储单元的方式，对于解决牺牲问题的实现方式不做赘述(但是解决的情况常用，可以见上述队列数据结构的提示)</p><p>初始化队列时rear和front都指向0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时，队头队尾指针都指向0</span></span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则判断为空时就判断front和rear是否指向同一个位置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列是否已满时判断rear是否在front的前一个位置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear + MaxSize - Q.front) % MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410140242.png" alt="image-20210410140242105"></p><h3 id="链式队列的实现"><a href="#链式队列的实现" class="headerlink" title="链式队列的实现"></a>链式队列的实现</h3><blockquote><p>链式队列：使用链式存储的方式实现队列</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125; LinkNode;  <span class="comment">// 结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front;    <span class="comment">// 队头指针，删除操作</span></span><br><span class="line">    LinkNode *rear;     <span class="comment">// 队尾指针，插入操作</span></span><br><span class="line">&#125; LinkQueue; <span class="comment">// 链式队列</span></span><br></pre></td></tr></table></figure><p>下面主要展示不带头结点的链式队列的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">        ElemType e;</span><br><span class="line">        DeQueue(Q, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">nullptr</span> &amp;&amp; Q.rear == <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于入队操作，当队列为空时需要特殊处理，即让队头指针和队尾指针都指向入队的结点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    LinkNode *node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = x;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        Q.rear = node;</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = node;</span><br><span class="line">        Q.rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于出队操作，当出队之后队列会为空时需要特殊处理，即让队尾也指向null，不然删除结点之后，队尾rear指向的是已经被删除的脏内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        Q.front = <span class="literal">nullptr</span>;</span><br><span class="line">        Q.rear = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkNode *p = Q.front;</span><br><span class="line">        Q.front = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410144652.png" alt="image-20210410144652542"></p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><ul><li>双端队列即只允许<strong>从两端插入、两端删除</strong>的线性表：<ol><li>变种一——输入受限的双端队列：只允许从<strong>一端插入</strong>、两端删除的线性表</li><li>变种二——输出受限的双端队列：只允许从两端插入、<strong>一端删除</strong>的线性表</li></ol></li></ul><blockquote><p>考点：判断输出序列的合法性</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410145314.png" alt="输入序列是1,2,3,4，数据结构是栈，找出合法的输出序列"></p><p>对于栈来说合法的输出序列，对于双端队列来说也一定合法。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410145706.png" alt="image-20210410145706799"></p><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>遇到左括号就入栈；遇到右括号就“消耗”一个左括号；如果左括号与右括号不匹配，则说明有问题；如果右括号读完之后栈非空，则说明有多余的左括号，说明有问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    LinkStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            Push(S, str[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span> || str[i] == <span class="string">&#x27;]&#x27;</span> || str[i] == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> ch;</span><br><span class="line">                Pop(S, ch);</span><br><span class="line">                <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (ch != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (ch != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (ch != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><h5 id="三种算术表达式"><a href="#三种算术表达式" class="headerlink" title="三种算术表达式"></a>三种算术表达式</h5><ol><li>中缀表达式：运算符在两个操作数的中间</li><li>前缀表达式：运算符在两个操作数的前面</li><li>后缀表达式：运算符在两个操作数的后面</li></ol><h5 id="后缀表达式-逆波兰式-转换及求值"><a href="#后缀表达式-逆波兰式-转换及求值" class="headerlink" title="后缀表达式(逆波兰式)转换及求值"></a>后缀表达式(逆波兰式)转换及求值</h5><h6 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h6><ul><li>中缀转后缀的手算方法：<ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，继续执行(2)</li></ol></li></ul><p>设计此转换算法时应满足转换时执行“左优先”原则，即只要左边的运算符能先计算，就优先算左边的，这样可以保证运算顺序的唯一性</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410154410.png" alt="image-20210410154410488"></p><ul><li>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾，可能遇到三种情况：<ol><li>遇到操作数。直接加入后缀表达式</li><li>遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式</li><li>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。</li></ol></li><li>按照上述方法处理完所有字符之后，将栈中剩余运算符依次弹出，并加入后缀表达式</li></ul><h6 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h6><ul><li><p>用栈实现后缀表达式的计算：</p><ol><li>从左向右扫描下一个元素</li><li>若扫描到操作数则压入栈，并回到1，否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压入栈顶，回到1</li></ol></li><li><p>用栈实现中缀表达式的计算：</p><ul><li>初始化两个栈，操作数栈和运算符栈</li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈(期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410160147.png" alt="image-20210410160146998"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToInteger</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; str.length()) &#123;</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        num += str[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strInfixExpression;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; strInfixExpression;</span><br><span class="line">    <span class="built_in">string</span> strNum;                  <span class="comment">// 暂存数字的字符串</span></span><br><span class="line">    <span class="built_in">string</span> strOP;                   <span class="comment">// 暂存运算符的字符串，因为逆波兰式队列我这里用的是string，所以需要char转换为str</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; polishReverse;    <span class="comment">// 用队列存储逆波兰式的每一项，便于计算时从前往后读</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stackOP;            <span class="comment">// 储运运算符的栈(转换时也储存括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;charInInfix : strInfixExpression) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charInInfix &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; charInInfix &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到数字就存储数字</span></span><br><span class="line">            strNum += charInInfix;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到的不是数字，这时候需要将数字压入逆波兰式队列中，并将暂存数字的字符串清空</span></span><br><span class="line">        <span class="keyword">if</span> (!strNum.empty()) &#123;</span><br><span class="line">            polishReverse.push(strNum);</span><br><span class="line">            strNum.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (charInInfix == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到左括号，压入运算符栈</span></span><br><span class="line">            stackOP.push(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charInInfix == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到右括号，将运算符栈中直到左括号的位置都压入逆波兰式队列中</span></span><br><span class="line">            <span class="keyword">while</span> (stackOP.top() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                strOP.clear();</span><br><span class="line">                strOP.insert(strOP.begin(), stackOP.top());</span><br><span class="line">                polishReverse.push(strOP);</span><br><span class="line">                stackOP.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 压出左括号</span></span><br><span class="line">            stackOP.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是左括号也不是右括号，也就是运算符</span></span><br><span class="line">            <span class="keyword">while</span> (!stackOP.empty() &amp;&amp; stackOP.top() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 在运算符栈非空或者遇到左括号之前，进行比较</span></span><br><span class="line">                <span class="keyword">if</span> ((charInInfix == <span class="string">&#x27;*&#x27;</span> || charInInfix == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (stackOP.top() == <span class="string">&#x27;+&#x27;</span> || stackOP.top() == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前运算符优先级比栈顶运算符高，则跳出，因为这时候需要直接将运算符压入逆波兰式队列</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前运算符优先级比栈顶低或者相等，则将栈顶运算符压入逆波兰式队列</span></span><br><span class="line">                strOP.clear();</span><br><span class="line">                strOP.insert(strOP.begin(), stackOP.top());</span><br><span class="line">                polishReverse.push(strOP);</span><br><span class="line">                stackOP.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前运算符压入运算符队列</span></span><br><span class="line">            stackOP.push(charInInfix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描技术后，如果最后一个位置是数字，就需要把数字压入逆波兰式队列中</span></span><br><span class="line">    <span class="keyword">if</span> (!strNum.empty()) &#123;</span><br><span class="line">        polishReverse.push(strNum);</span><br><span class="line">        strNum.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将还未被压入逆波兰式队列中的运算符压进去</span></span><br><span class="line">    <span class="keyword">while</span> (!stackOP.empty()) &#123;</span><br><span class="line">        strOP.clear();</span><br><span class="line">        strOP.insert(strOP.begin(), stackOP.top());</span><br><span class="line">        polishReverse.push(strOP);</span><br><span class="line">        stackOP.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 输出逆波兰式队列看看有没有问题</span></span><br><span class="line"><span class="comment">//    while (!polishReverse.empty()) &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; polishReverse.front() &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line"><span class="comment">//        polishReverse.pop();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackNums;</span><br><span class="line">    <span class="keyword">while</span> (!polishReverse.empty()) &#123;</span><br><span class="line">        <span class="comment">// 从前向后，取出第一个string，可以是num或者op</span></span><br><span class="line">        <span class="built_in">string</span> strTmp = polishReverse.front();</span><br><span class="line">        polishReverse.pop();</span><br><span class="line">        <span class="keyword">char</span> charOPTmp = strTmp[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果是op的话</span></span><br><span class="line">        <span class="keyword">if</span> (charOPTmp == <span class="string">&#x27;+&#x27;</span> ||</span><br><span class="line">            charOPTmp == <span class="string">&#x27;-&#x27;</span> ||</span><br><span class="line">            charOPTmp == <span class="string">&#x27;*&#x27;</span> ||</span><br><span class="line">            charOPTmp == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为栈先进后出，所以先出来的是latter</span></span><br><span class="line">            <span class="keyword">int</span> numLatter = stackNums.top();</span><br><span class="line">            stackNums.pop();</span><br><span class="line">            <span class="comment">// 后出来的是previous</span></span><br><span class="line">            <span class="keyword">int</span> numPrevious = stackNums.top();</span><br><span class="line">            stackNums.pop();</span><br><span class="line">            <span class="comment">// 待插入的数，即两数运算结果</span></span><br><span class="line">            <span class="keyword">int</span> numInsert;</span><br><span class="line">            <span class="keyword">switch</span> (charOPTmp) &#123;</span><br><span class="line">                <span class="comment">// 根据运算符的类型来决定运算结果</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    numInsert = numPrevious + numLatter;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    numInsert = numPrevious - numLatter;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    numInsert = numPrevious * numLatter;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    numInsert = numPrevious / numLatter;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将运算结果压入操作数栈</span></span><br><span class="line">            stackNums.push(numInsert);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是num直接入栈</span></span><br><span class="line">            stackNums.push(strToInteger(strTmp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = stackNums.top();</span><br><span class="line">    stackNums.pop();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前缀表达式-波兰式-转换及求值"><a href="#前缀表达式-波兰式-转换及求值" class="headerlink" title="前缀表达式(波兰式)转换及求值"></a>前缀表达式(波兰式)转换及求值</h5><h6 id="中缀表达式转前缀表达式"><a href="#中缀表达式转前缀表达式" class="headerlink" title="中缀表达式转前缀表达式"></a>中缀表达式转前缀表达式</h6><ul><li>中缀转前缀的手算方法：<ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[运算符 左操作数 右操作数]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，继续执行(2)</li></ol></li></ul><p>设计此转换算法时应满足转换时执行“右优先”原则，即只要右边的运算符能先计算，就优先算右边的，这样可以保证运算顺序的唯一性</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410154423.png" alt="image-20210410154423829"></p><h6 id="前缀表达式求值"><a href="#前缀表达式求值" class="headerlink" title="前缀表达式求值"></a>前缀表达式求值</h6><ul><li>用栈实现后缀表达式的计算：<ol><li>从右向左扫描下一个元素</li><li>若扫描到操作数则压入栈，并回到1，否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压入栈顶，回到1</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/20210410154743.png" alt="左操作数、右操作数、左优先原则、右优先原则是王道考研的咸鱼学长自己为了讲解所DIY的概念，答题时不可以这样写"></p><h4 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h4><p>函数在调用时，需要用一个栈来存储：①调用返回地址；②实参；③局部变量</p><p>在递归调用时，函数调用栈可以称为“递归工作栈”；每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息<br>可以自定义栈将递归算法改造成非递归算法</p><p>递归算法的缺点：效率低，太多层递归可能会导致栈溢出(即递归算法的空间复杂度高)；可能包含很多的重复计算</p><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><ol><li>树的层次遍历</li><li>图的广度优先遍历</li><li>操作系统中的FCFS(先来先服务)调度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统实验-第二章-数据库的完整性控制</title>
      <link href="2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
      <url>2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p></blockquote><h2 id="实验2-1——实体完整性"><a href="#实验2-1——实体完整性" class="headerlink" title="实验2.1——实体完整性"></a>实验2.1——实体完整性</h2><blockquote><p>实验目的：学习实体完整性的建立，以及实践违反实体完整性的结果</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在数据库School中建立表Stu_Union，进行主键约束，在没有违反实体完整性的前提下插入并更新一条记录</li><li>演示违反实体完整性的插入操作</li><li>演示违反实体完整性的更新操作</li><li>演示事务的处理，包括事务的建立、处理，以及出错时的事务回退</li><li>通过建立Scholarship表，插入数据，演示当与现有的数据环境不等时，无法建立实体完整性以及参照完整性</li></ol><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)输入下述SQL语句并执行。并思考为什么把sno设置为””没有违反NOT NULL的约束？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Stu_Union</span><br><span class="line">(</span><br><span class="line">    Sno   <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sname <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    Ssex  <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    Sage  <span class="type">INT</span>,</span><br><span class="line">    Sdept <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Stu_Union <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (sno)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10000&#x27;</span>, N<span class="string">&#x27;王敏&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="comment">-- 没有违反NOT NULL约束的原因：</span></span><br><span class="line"><span class="comment">-- NULL是一个&quot;不知道&quot;或者&quot;不确定&quot;的数据值，不是0不是空格</span></span><br><span class="line"><span class="comment">-- Sno=&#x27;&#x27; 这里的 &#x27;&#x27; 是一个空字符串，而不是NULL，不满足NULL定义</span></span><br><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="string">&#x27;95002&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> N<span class="string">&#x27;王敏&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417125938.png" alt="image-20210417125938690"></p><p>(2)输入下述SQL语句并执行。违反主键的唯一性属性，破坏实体完整性，系统中止操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95002&#x27;</span>, N<span class="string">&#x27;王嘉&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130047.png" alt="image-20210417130047224"></p><p>(3)输入下述SQL语句并执行。违反主键的NOT NULL属性，破坏实体完整性，系统中止操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;95002&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130116.png" alt="image-20210417130116287"></p><p>(4)输入下述SQL语句并执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T1;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95009&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95003&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95005&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130208.png" alt="image-20210417130208185"></p><p>当SET XACT_ABORT为ON时，如果Transact-SQL语句产生运行时错误，整个事务将终止并回滚；为OFF时，只回滚产生错误的Transact-SQL语句，而事务将继续进行处理。<br>编译错误(语法错误等)不受SET XACT_ABORT ON影响。<br>对于大多数OLE DB提供程序(包括SQL Server)，隐性或显式事务中的数据修改语句必须将XACT_ABORT设置为ON；唯一不需要设置该选项的情况是提供程序支持嵌套事务时。</p><p>(5)输入下述SQL语句并执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这是一个会因为破坏完整性而回滚的事务实例</span></span><br><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T2;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95007&#x27;</span>, N<span class="string">&#x27;李明&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95009&#x27;</span>, N<span class="string">&#x27;李进&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130414.png" alt="image-20210417130414187"></p><p>(6)输入下述SQL语句并执行。配合(5)展示在SET XACT_ABORT ON的情况下TRANSACTION中的语句出错时，前面的即使正确的语句也会回滚</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br></pre></td></tr></table></figure><p>(7)输入下述SQL语句并执行。新建一个Scholarship表并插入两条数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">(</span><br><span class="line">    M_ID    <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Stu_id  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    R_money <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;700000&#x27;</span>, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;800000&#x27;</span>, <span class="number">8000</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Scholarship;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130442.png" alt="image-20210417130442514"></p><p>(8)输入下述SQL语句并执行。当前的数据环境不满足M_ID称为主键，因为数据列M_ID不满足实体完整性的唯一属性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> PK_Scholarship <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (M_ID);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130507.png" alt="image-20210417130507461"></p><p>(9)输入下述SQL语句并执行。 Scholarship数据库中的数据，不满足Stu_id与STUDENTS表中的sid的对应性，所以创建参照完整性失败</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Scholarship <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Stu_id) <span class="keyword">REFERENCES</span> STUDENTS (sid);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130532.png" alt="image-20210417130532354"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在School数据库中建立一张新表Class<br>– 包括Class_id(varchar(4))，name(varchar(10))，Department(varchar(20))<br>– 并约束Class_id为主键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Class</span><br><span class="line">(</span><br><span class="line">    Class_id   <span class="type">VARCHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    name       <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Department <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Class <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2)创建事务T3，在事务中插入一个元组(‘00001’, ‘01CSC’, ‘CS’)<br>– 并在T3中嵌套创建事务T4，T4也插入和T3一样的元组，编写代码测试，查看结果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T3;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Class</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;01CSC&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Class;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Class</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;01CSC&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T4;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T3;</span><br><span class="line"><span class="comment">-- 执行失败，因为T4插入的元组破坏了实体完整性，导致T4事务失败，而T4事务处于T3事务内部，所以T3事务也相应失败，前面的插入语句回滚，Class表为空</span></span><br></pre></td></tr></table></figure><h2 id="实验2-2——参照完整性"><a href="#实验2-2——参照完整性" class="headerlink" title="实验2.2——参照完整性"></a>实验2.2——参照完整性</h2><blockquote><p>实验目的：学习建立外键，以及利用FOREIGN KEY……REFERENCES子句以及各种约束保证参照完整性</p></blockquote><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>演示参照完整性</li><li>演示涉及参照完整性的级联删除</li><li>演示涉及参照完整性的多重级联删除</li><li>修改外键的约束</li><li>演示互参照问题及解决方法</li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)为演示参照完整性，建立表Course，令Cno为其主键，并在Stu_Union中插入数据，为下面的实验步骤做预先准备</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course</span><br><span class="line">(</span><br><span class="line">    Cno     <span class="type">CHAR</span>(<span class="number">4</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Cname   <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Cpoints <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Cno)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;ComputerNetworks&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;0002&#x27;</span>, <span class="string">&#x27;Database&#x27;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130806.png" alt="image-20210417130806718"></p><p>(2)建立表SC，令Sno和Cno分别为参照Stu_Union表以及Course表的外键，设定为级联删除，并令(Sno, Cno)为其主键。在不违反参照完整性的前提下，插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(</span><br><span class="line">    Sno   <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    Cno   <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    Grade <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_SC <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Sno, Cno),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95002&#x27;</span>, <span class="string">&#x27;0001&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;95002&#x27;</span>, <span class="string">&#x27;0002&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;0001&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;0002&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130836.png" alt="image-20210417130835965"></p><p>(3)演示违反参照完整性的插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;99&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 语句与 FOREIGN KEY 约束&quot;FK__SC__Sno__6E01572D&quot;冲突。该冲突发生于数据库&quot;School&quot;，表&quot;dbo.Stu_Union&quot;, column &#x27;Sno&#x27;。</span></span><br><span class="line"><span class="comment">-- 即此插入语句中的Sno在Stu_Union表中不存在，Cno在Course表中不存在，不满足外键条件，破坏了参照完整性</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130901.png" alt="image-20210417130901529"></p><p>(4)在Stu_Union中删除数据，演示级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="comment">-- SC表中的Sno具有ON DELETE CASCADE具有连带删除作用，也就是在STUDENTS中删除某个学号，SC表中的对应这个学号为外键的所有记录都会被删除</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130934.png" alt="image-20210417130934721"></p><p>(5)在Course中删除数据，演示级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="comment">-- SC表中的Cno具有ON DELETE CASCADE具有连带删除作用，也就是在Course中删除某个课程号，SC表中的对应这个课程号为外键的所有记录都会被删除</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130951.png" alt="image-20210417130951369"></p><blockquote><p>PS：6~10第一遍的时候忘了截图，数据库中内容已经被删除了，可以通过换学号来重新演示，但是个人比较懒，就不换学号从头来一遍了</p></blockquote><p>(6)为了演示多重级联删除，建立Stu_Card表，令Stu_id为参照Stu_Union表的外键，令Card_id为其主键，并插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Stu_Card</span><br><span class="line">(</span><br><span class="line">    card_id        <span class="type">CHAR</span>(<span class="number">14</span>),</span><br><span class="line">    Stu_id         <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">REFERENCES</span> STUDENTS (sid) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    remained_money <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Stu_Card <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (card_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Card</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;05212567&#x27;</span>, <span class="string">&#x27;800001216&#x27;</span>, <span class="number">100.25</span>),</span><br><span class="line">       (<span class="string">&#x27;05212222&#x27;</span>, <span class="string">&#x27;800005753&#x27;</span>, <span class="number">200.50</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br></pre></td></tr></table></figure><p>(7)为了演示多重级联删除，建立ICBC_Card表，令Stu_card_id为参照Stu_Card表的外键，令bank_id为其主键，并插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">(</span><br><span class="line">    bank_id        <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    stu_card_id    <span class="type">CHAR</span>(<span class="number">14</span>) <span class="keyword">REFERENCES</span> Stu_Card (card_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    restored_money <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_ICBC_Card <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (bank_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ICBC_Card</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;9558844022312&#x27;</span>, <span class="string">&#x27;05212567&#x27;</span>, <span class="number">15000.1</span>),</span><br><span class="line">       (<span class="string">&#x27;9558844023645&#x27;</span>, <span class="string">&#x27;05212222&#x27;</span>, <span class="number">50000.3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(8)通过删除STUDENTS表中的一条记录，演示三个表的多重级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> CHOICES</span><br><span class="line">    <span class="keyword">DROP</span> [FK_CHOICES_STUDENTS];</span><br><span class="line"><span class="comment">-- 需要将CHOICES中引用STUDENTS表中的外键设置为ON DELETE CASCADE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> CHOICES</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> [FK_CHOICES_STUDENTS] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> ([sid]) <span class="keyword">REFERENCES</span> [dbo].[STUDENTS] ([sid]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800001216&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(9)演示事务中进行多重级联失败的处理。修改ICBC_Card表中的外键属性，使其变为On delete No action，演示事务中通过删除STUDENTS表中的一条记录，多重级联删除失败，整个事务回滚到事务的初始状态</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改外键约束类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> FK__ICBC_Card__stu_c__74AE54BC;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_ICBC <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (stu_card_id)</span><br><span class="line">        <span class="keyword">REFERENCES</span> Stu_Card (card_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="comment">-- ON DELETE NO ACTION不能级联删除</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION DEL;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800005753&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION DEL;</span><br><span class="line"><span class="comment">-- 查看上述操作是否生效(是否成功删除)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(10)演示互参照问题及其解决方法。要建立教师授课和课程教师听课关系的两张表，规定一个教师可以授多门课，但是每个课程只能指定一个教师去听课，所以要为两张表建立相互之间的参照关系</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以下建表会失败，因为定义Listen_Course表的时候Teach_Course表还没建立，无法作为外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">(</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>,</span><br><span class="line">    Tname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Listen_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Teacher_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Listen_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Course_id) <span class="keyword">REFERENCES</span> Teach_Course (Course_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teach_Course</span><br><span class="line">(</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Cname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Teach_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Course_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Teach_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Teacher_id) <span class="keyword">REFERENCES</span> Listen_Course (Teacher_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131407.png" alt="image-20210417131407273"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解决方法，先创建Listen_Course不带外键，再创建Teach_Course，再ALTER TABLE将外键插入到Listen_Course中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">(</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>,</span><br><span class="line">    Tname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Listen_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Teacher_id),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teach_Course</span><br><span class="line">(</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Cname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Teach_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Course_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Teach_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Teacher_id) <span class="keyword">REFERENCES</span> Listen_Course (Teacher_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Listen_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Course_id) <span class="keyword">REFERENCES</span> Teach_Course (Course_id);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131536.png" alt="image-20210417131536805"></p><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)用ALTER TABLE语句将SC表中的ON DELETE CASCADE改为ON DELETE NO ACTION，重新插入SC的数据，重复操作上述实验内容的4.5.观察结果，分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK__SC__Sno__6E01572D;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK__SC__Cno__6EF57B66;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Sno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Cno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="comment">-- 执行实验内容的4.5.时执行失败，因为ON DELETE NO ACTION不是级联删除，在删除的时候会不采取动作，产生冲突</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;95002&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;0001&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>(2)用ALTER TABLE语句将SC表中的ON DELETE CASCADE改为ON DELETE SET NULL，重新插入SC的数据，重复操作上述实验内容的4.5.观察结果，分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE SET NULL执行失败，因为外键参考的主键有不可为空的约束条件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK_SC_Sno,</span><br><span class="line">        FK_SC_Cno;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Sno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> FK_SC_Cno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>(3)创建一个班里的学生互助表，规定：包括学生编号，学生姓名，学生的帮助对象，每个学生有且仅有一个帮助对象，帮助对象也必须是班里的学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MutualAid</span><br><span class="line">(</span><br><span class="line">    Sno       <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sname     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    AidObject <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">REFERENCES</span> MutualAid (Sno),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_MutualAid <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Sno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(4)学校学生会的每个部们都有一个部长，每个部长领导多个部员，每个部只有一个部员有评测部长的权利。<br>– 给出体现这两种关系(领导和评测)的两张互参照的表的定义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Leader</span><br><span class="line">(</span><br><span class="line">    Leader_id <span class="type">CHAR</span>,</span><br><span class="line">    Lname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Depart_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Leader <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Leader_id),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Depart_Choose_Leader</span><br><span class="line">(</span><br><span class="line">    Depart_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Dname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Leader_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Depart_Choose_Leader <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Depart_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Depart_Choose_Leader <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Leader_id) <span class="keyword">REFERENCES</span> Leader (Leader_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Leader</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Leader <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Depart_id) <span class="keyword">REFERENCES</span> Depart_Choose_Leader (Depart_id);</span><br></pre></td></tr></table></figure><h2 id="实验2-3——用户自定义完整性"><a href="#实验2-3——用户自定义完整性" class="headerlink" title="实验2.3——用户自定义完整性"></a>实验2.3——用户自定义完整性</h2><blockquote><p>实验目的：学习用户自定义约束</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>掌握创建表时创建自定义UNIQUE约束、CHECK约束</li><li>掌握插入新建的用户自定义约束</li><li>掌握创建Rule以及Rule与表属性的绑定，以及绑定的解除</li></ol><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)创建Worker表，并自定义两个约束U1以及U2，其中U1规定Name字段唯一，U2规定Sage(级别)字段的上限是28</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">(</span><br><span class="line">    Number     <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    Name       <span class="type">CHAR</span>(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> U1 <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sex        <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    Sage       <span class="type">INT</span></span><br><span class="line">        <span class="keyword">CONSTRAINT</span> U2 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;=</span> <span class="number">20</span>),</span><br><span class="line">    Department <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Worker <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2)在Worker表中插入一条合法记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">14</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Worker;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131642.png" alt="image-20210417131642828"></p><p>(3)演示违反U2约束的例子，规定U2元组的sage属性的值必须小于等于28</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00002&#x27;</span>, N<span class="string">&#x27;王勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131709.png" alt="image-20210417131709916"></p><p>(4)去除U2约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">    <span class="keyword">DROP</span> U2;</span><br></pre></td></tr></table></figure><p>(5)重新插入(3)中想要插入的数据，由于去除了U2约束，所以插入成功</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00002&#x27;</span>, N<span class="string">&#x27;王勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Worker;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131747.png" alt="image-20210417131747154"></p><p>(6)创建规则rule_sex，规定插入或更新的值只能是M或F，并绑定到Worker的sex字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE rule_sex <span class="keyword">AS</span> <span class="variable">@value</span> <span class="keyword">IN</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line"><span class="keyword">EXEC</span> sp_bindrule rule_sex, <span class="string">&#x27;Worker.Sex&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(7)演示违反规则rule_sex的插入操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00003&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">25</span>, N<span class="string">&#x27;研发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131813.png" alt="image-20210417131813579"></p><p>(8)解除Worker.sex与rule_sex的绑定</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_unbindrule <span class="string">&#x27;Worker.Sex&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)加入约束U3，令Sage的值大于等于0</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> U3 <span class="keyword">CHECK</span> (Sage <span class="operator">&gt;=</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">-38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(2)加入规则R2，确保插入的记录的Sage值在1到100之间，并绑定的Sage上</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE rule_sage <span class="keyword">AS</span> <span class="variable">@value</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="variable">@value</span> <span class="operator">&lt;=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_bindrule rule_sage, <span class="string">&#x27;Worker.Sage&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00005&#x27;</span>, N<span class="string">&#x27;TEST-R2&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">99</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00006&#x27;</span>, N<span class="string">&#x27;R2-WA&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">101</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="实验2-4——触发器"><a href="#实验2-4——触发器" class="headerlink" title="实验2.4——触发器"></a>实验2.4——触发器</h2><blockquote><p>实验目的：通过实验使学生加深对数据完整性的理解，学会创建和使用触发器</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>创建和使用触发器，学习使用SQL Server的触发器(与SQL标准的触发器语法不太一样)</li><li>测试使用违法触发器约束的语句时的结果</li><li>学习INSTEAD OF触发器在不可更新视图上的应用</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)为worker表创建触发器T1，当插入或是更新表中数据时，保证所操作的记录的Sage值大于0</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T1</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">INSERT</span> , <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF (<span class="keyword">SELECT</span> Sage</span><br><span class="line">           <span class="keyword">FROM</span> inserted) <span class="operator">&lt;</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;Sage must be a integer more than zero! Transaction fail&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(2)为Worker表建立触发器T2，禁止删除编号为00001的CEO</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T2</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">DELETE</span></span><br><span class="line">    <span class="keyword">AS</span> IF (<span class="keyword">SELECT</span> Number</span><br><span class="line">           <span class="keyword">FROM</span> deleted) <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;He is the CEO! Delete Fail!&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(3)Worker表中的人员的编号是不可改变的，创建触发器T3实现更新中编号的不可改变性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T3</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF <span class="keyword">UPDATE</span>(Number)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;Every number cannot be changed!&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(4)演示违反T1触发器的约束的插入操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00005&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">-10</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120142.png" alt="image-20210417120142140"></p><p>(5)演示违反T1触发器的约束的更新操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span> <span class="number">-7</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120232.png" alt="image-20210417120232781"></p><p>(6)演示违反T2触发器的约束的删除操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Worker</span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120452.png" alt="image-20210417120452503"></p><p>(7)演示违反T3触发器的约束的更新操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Number<span class="operator">=</span><span class="string">&#x27;00007&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417121116.png" alt="image-20210417121116420"></p><p>(8)演示INSTEAD OF触发器在不可更新视图上的运用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建不可更新视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> StudentScholarShip <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ST.sid, ST.sname, ST.grade, SC.R_money</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS ST,</span><br><span class="line">     Scholarship SC</span><br><span class="line"><span class="keyword">WHERE</span> ST.sID <span class="operator">=</span> SC.Stu_id;</span><br><span class="line"><span class="comment">-- 测试不可更新视图</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentScholarShip</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="number">2003</span>, <span class="number">1500</span>);</span><br><span class="line"><span class="comment">-- 创建触发器，将原本一次性插入到StudentScholarShip视图的INSERT语句分解，从而避免一次对多个基表进行操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Ins_Stu_Scholarship</span><br><span class="line">    <span class="keyword">ON</span> StudentScholarShip</span><br><span class="line">    INSTEAD <span class="keyword">OF</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line">    IF (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">            <span class="keyword">FROM</span> STUDENTS S,</span><br><span class="line">                 inserted i</span><br><span class="line">            <span class="keyword">WHERE</span> S.sid <span class="operator">=</span> i.sid</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS</span><br><span class="line">            <span class="keyword">SELECT</span> sid, sname, <span class="keyword">null</span>, grade</span><br><span class="line">            <span class="keyword">FROM</span> inserted</span><br><span class="line">            <span class="keyword">DECLARE</span> <span class="variable">@MAX</span>_M_ID <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="variable">@MAX</span>_M_ID <span class="operator">=</span> <span class="built_in">MAX</span>(M_ID)</span><br><span class="line">            <span class="keyword">FROM</span> Scholarship</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="variable">@MAX</span>_M_ID <span class="operator">+</span> <span class="number">1</span>, sid, R_money</span><br><span class="line">            <span class="keyword">FROM</span> inserted</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        PRINT N<span class="string">&#x27;数据已经存在&#x27;</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">-- 测试插入，此时可以进行更新</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentScholarShip</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="number">2003</span>, <span class="number">1500</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> StudentScholarShip;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;1000&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Scholarship</span><br><span class="line"><span class="keyword">WHERE</span> Stu_id <span class="operator">=</span> <span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417122314.png" alt="image-20210417122314341"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)建立一个在Work表上的触发器T4，要求插入记录的Sage值必须比表中已记录的最大的Sage值大</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T4</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">AS</span> IF (((<span class="keyword">SELECT</span> Sage</span><br><span class="line">             <span class="keyword">FROM</span> inserted) <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">Max</span>(sage)</span><br><span class="line">                               <span class="keyword">FROM</span> Worker))</span><br><span class="line">            <span class="keyword">OR</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                 <span class="keyword">FROM</span> Worker</span><br><span class="line">                 <span class="keyword">WHERE</span> Sage <span class="operator">=</span> (</span><br><span class="line">                     <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Sage)</span><br><span class="line">                     <span class="keyword">FROM</span> Worker</span><br><span class="line">                 )) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;SOMETHING WRONG&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不满足触发器条件的插入语句会拒绝执行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 满足触发器条件的插入语句顺利执行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">39</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417125209.png" alt="image-20210417125209016"></p><p>(2)建立一个在Worker表上的触发器T5，要求当更新一个记录的时候，表中记录的Sage值要比老记录的Sage大，因为一般工资级别只能升不能降</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T5</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF ((<span class="keyword">SELECT</span> Sage</span><br><span class="line">            <span class="keyword">FROM</span> inserted) <span class="operator">&lt;=</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                               <span class="keyword">FROM</span> deleted))</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不满足触发器条件的更新语句会拒绝执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage <span class="operator">=</span> Sage <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00005&#x27;</span>;</span><br><span class="line"><span class="comment">-- 满足触发器条件的更新语句顺利执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage <span class="operator">=</span> Sage <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00005&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417124003.png" alt="image-20210417124003208"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第二章-进程管理</title>
      <link href="2021/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《操作系统考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统网课</a>。</p></blockquote><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的基本知识"><a href="#进程的基本知识" class="headerlink" title="进程的基本知识"></a>进程的基本知识</h3><ul><li>程序：一个指令序列。<ul><li>在早期的计算机中，只支持<strong>单道</strong>程序，也就是同一时间计算机的所有设备(CPU、内存、I/O设备等)都是只为这一道程序服务，这个阶段<strong>只有程序段和数据段</strong>：<ul><li>程序段：存放程序的代码</li><li>数据段：存放程序运行过程中处理的数据(如变量)</li></ul></li><li>引入<strong>多道</strong>程序技术之后，内存中同时存放多道程序，各个程序的代码、运算数据存放的位置不同。为了方便操作系统管理，完成<strong>各程序并发执行</strong>，引入了<strong>进程</strong>和<strong>进程实体</strong>的概念，<strong>PCB、程序段、数据段</strong>这三部分共同构成了<strong>进程实体</strong>(进程映像)<ul><li>PCB：进程控制块，是操作系统为每个运行的程序配置的一个数据结构，<strong>用来描述进程的各种信息</strong>(如<strong>程序代码存放位置</strong>及程序计数器、程序状态字、各种数据寄存器等<strong>处理机现场信息</strong>)</li></ul></li></ul></li></ul><p>进程实体(进程映像)：由程序段、数据段、PCB三部分组成。一般情况下，我们把进程实体简称为进程(实际上进程是动态的，进程实体是静态的)，例如，所谓创建进程，实质上就是创建进程实体中的PCB；而撤销进程，实质上就是撤销进程实体中的PCB，<strong>PCB是进程存在的唯一标志</strong>。</p><ul><li>进程的定义：强调“动态性”<ol><li>进程是程序的一次<strong>执行过程</strong></li><li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong></li><li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，是系统进行资源分配和调度的一个独立单位</li></ol></li><li>引入进程实体的概念之后，可以把进程定义为：<ul><li>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位</li></ul></li></ul><blockquote><p>可知，严格意义上来说，进程实体和进程并不一样，进程实体是<strong>静态</strong>的，而进程是<strong>动态</strong>的。不过，除非题目专门考察二者的区别，否则可以认为进程实体就是进程。因此也可以说“进程是由程序段、数据段、PCB三部分组成”，但并不严谨</p></blockquote><ul><li>进程的组成(进程<strong>内部</strong>由哪些部分构成)：进程(进程实体)由<strong>程序段、数据段、PCB三部分组成</strong><ol><li>程序段：存放程序的代码</li><li>数据段：存放程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量等</li><li>PCB：操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需要的各种信息——<strong>进程管理者(操作系统)所需要的数据</strong>都在PCB里；与之相对的，程序段和数据段存放的是<strong>程序本身运行所需的数据</strong><ol><li>进程描述信息</li><li>进程控制和管理信息</li><li>资源分配清单</li><li>处理机相关信息</li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401184534.png" alt="image-20210401184534228"></p><ul><li>进程的组织(<strong>多个进程之间</strong>的组织方式问题)<ol><li>链接方式：<ol><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ol></li><li>索引方式：<ol><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有各个索引表的指针</li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401185832.png" alt="image-20210401185832616"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401190012.png" alt="image-20210401190012228"></p><ul><li>进程的特征<ol><li>动态性(最基本的特征)：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性：内不能中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位；<strong>进程是资源分配、接受调度的基本单位</strong></li><li>异步性：各进程按给自独立的、不可预知的速度向前推进，操作系统要提供<strong>“进程同步机制”</strong>来解决异步问题——异步性会导致并发程序执行结果的不确定性。</li><li>结构性：每个进程都会配置一个PCB；从结构上看，进程由程序段、数据段和PCB组成</li></ol></li></ul><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><ul><li>进程的三种基本状态：<ol><li>运行态(Running)：占有CPU，并在CPU上运行<ol><li>在单核CPU环境下，每一个时刻最多只有一个进程处于运行态；n核处理机环境下可以有n个进程处于运行态</li></ol></li><li>就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU而暂时不能运行<ol><li>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，就可以进入运行态开始运行</li></ol></li><li>阻塞态(Waiting/Blocked，等待态)：因等待某一事件而暂时不能运行，完成这件事之后会进入就绪态<ol><li>例如等待操作系统分配打印机、等待读写磁盘操作的结果</li><li>CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</li></ol></li></ol></li><li>进程的另外两种状态：<ol><li>创建态(New，新建态)：操作系统需要完成创建进程——操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB</li><li>终止态(Terminated，结束态)：进程运行结束(或由于Bug导致进程无法继续执行下去，例如数组越界错误)，需要撤销进程——操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销进程PCB等工作</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401192743.png" alt="image-20210401192743370"></p><ul><li><p>进程的状态(五状态模型)：</p><ul><li>运行态：拥有CPU，拥有其他所需资源</li><li>就绪态：没有CPU，拥有其他所需资源</li><li>阻塞态：没有CPU，没有其他所需资源</li><li>创建态：操作系统为新进程分配资源、创建PCB</li><li>终止态：操作系统回收进程的资源、撤销PCB</li></ul></li><li><p>进程状态间的转换(五状态模型)：</p><ul><li>就绪态-&gt;运行态：进程被调度</li><li>运行态-&gt;就绪态：时间片到，或CPU被其他高优先级进程抢占</li><li>运行态-&gt;阻塞态：等待系统资源分配，或等待某事件发生(主动行为)</li><li>阻塞态-&gt;就绪态：资源分配到位，等待的事件发生(被动行为)</li><li>创建态-&gt;就绪态：系统完成创建进程相关的工作</li><li>运行态-&gt;终止态：进程运行结束，或运行过程中遇到不可修复的错误</li></ul></li><li><p>进程的状态(七状态模型)：除了上述五状态以外，还有两种挂起状态——挂起态(Suspend)，即暂时调到外存等待的进程状态为挂起状态</p><ul><li>就绪挂起：</li><li>阻塞挂起：</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402132124.png" alt="image-20210402132124159"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能——<strong>实现进程状态转换</strong></p><ul><li>进程控制的需要实现的功能：<ul><li>创建进程：初始化PCB、分配系统资源</li><li>创建态-&gt;就绪态：修改PCB内容和相应队列</li><li>就绪态-&gt;运行态：恢复进程运行环境、修改PCB内容和相应队列</li><li>运行态-&gt;阻塞态：保存进程运行环境、修改PCB内容和相应队列</li><li>阻塞态-&gt;就绪态：修改PCB内容和相应对列；如果等待的是资源，还需为进程分配系统资源</li><li>运行态-&gt;就绪态(进程切换)：保存进程运行环境、修改PCB内容和相应对列</li><li>运行态-&gt;终止态：回收进程拥有的资源、撤销PCB</li></ul></li></ul><p>用<strong>原语</strong>(操作系统内核的一部分，运行在核心态)实现进程控制，原语的特点是<strong>执行期间不允许中断</strong>，只能一气呵成；这种不可以被中断的操作被称为<strong>原子操作</strong>。原语采用“关中断指令”和“开中断指令”来实现——当使用<strong>关中断指令</strong>之后，对接受到的外部中断信号不采取措施，只有使用<strong>开中断指令</strong>之后，收到外部中断信号才会进入相应的中断处理程序——显然，<strong>开中断/关中断指令</strong>属于特权指令，只能在核心态下执行。</p><ul><li>原语：<ol><li>更新PCB中的信息(修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<ol><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复其运行环境</li></ol></li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol></li></ul><ol><li>进程的创建：<ul><li>创建原语：无-&gt;创建态-&gt;就绪态<ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul></li><li>引起进程创建的事件：<ul><li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些情况时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul></li></ul></li><li>进程的终止：<ul><li>撤销原语：就绪态/阻塞态/运行态-&gt;终止态-&gt;无<ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的事件：<ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul></li></ul></li><li>进程的阻塞和唤醒——阻塞原语和唤醒原语成对使用<ul><li>进程的阻塞：<ul><li>阻塞原语：运行态-&gt;阻塞态<ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>等待系统分配某种资源</li><li>等待相互合作的其他进程完成工作</li></ul></li></ul></li><li>进程的唤醒：<ul><li>唤醒原语：阻塞态-&gt;就绪态<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件：<ul><li>等待的事件发生——因何事阻塞，应由何事唤醒</li></ul></li></ul></li></ul></li><li>进程的切换：<ul><li>切换原语：运行态-&gt;阻塞态/就绪态、就绪态-&gt;运行态<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应对列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li>引起进程切换的事件<ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401200220.png" alt="image-20210401200220258"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><strong>进程通信：进程之间的信息交换。</strong>因为进程是分配系统资源的基本单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立，为了保证系统安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>，但是进程之间的信息交换必须实现，为了保证进程间的安全通信，操作系统提供了三种方法：共享存储、消息传递、管道通信。</p><ol><li>共享存储——两个进程对共享空间的访问必须是<strong>互斥</strong>的(互斥访问通过操作系统提供的工具实现)，操作系统只负责提供<strong>共享空间</strong>和<strong>同步互斥工具(P/V操作等)</strong><ol><li>基于数据结构的共享：只能存放固定的数据结构，比如共享空间里只能存放一个长度为10的数组。<ol><li>速度慢、限制多，是<strong>低级通信方式</strong></li></ol></li><li>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。<ol><li>速度快，是<strong>高级通信方式</strong></li></ol></li></ol></li><li>管道通信——<strong>管道</strong>是指用于连接读写进程的一个共享文件，有名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区<ol><li>管道只能采用<strong>半双工通信</strong>，<strong>某一时间段内只能实现单向的传输</strong>，如果要实现双向<strong>同时</strong>通信则需要设置两个管道</li><li>各进程要<strong>互斥</strong>的访问管道</li><li>数据以字符流的形式写入管道，当<strong>管道写满</strong>时，写进程的write()系统调用将被阻塞，等待读进程将数据取走；当读进程将数据全部取走后，<strong>管道变空</strong>，此时读进程的read()系统调用将被阻塞</li><li>如果没写满，就不允许读；如果管道没读空，就不允许写</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程同一时间最多只能有一个</strong>，否则可能会有读错数据的情况</li></ol></li><li>消息传递——进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换<ol><li>格式化的消息：消息头和消息体组成。消息头包括发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(比如计算机网络中的“报文”就是格式化的消息)</li><li>直接通信方式——直接将消息挂到接收进程的消息缓冲队列上<ol><li>发送方使用发送原语将消息发送到接收方的消息缓冲队列的尾部</li><li>接收方使用接收原语从消息缓冲队列中依次读取消息</li></ol></li><li>间接通信方式——消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”，可以类比做计算机网络中的电子邮件系统<ol><li>发送方使用发送原句将消息发送到信箱中</li><li>接收方使用接收原语从信箱中取出属于自己的消息</li></ol></li></ol></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401202503.png" alt="image-20210401202503528"></p><h3 id="线程及多线程模型"><a href="#线程及多线程模型" class="headerlink" title="线程及多线程模型"></a>线程及多线程模型</h3><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”来增加<strong>并发度</strong>。传统的进程是程序执行流的最小单位，引入线程之后，同一个进程下可以有多个线程，<strong>线程成为了程序执行流的最小单位</strong>。</p><p><strong>线程是一个基本的CPU执行单元，是程序执行流的最小单位</strong>；引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可并发</strong>，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务(可以类比为QQ能视频、聊天、传文件)；引入线程之后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>(如打印机、内存地址空间等都是分配给进程的)</p><ul><li>线程机制引发的变化<ul><li>资源分配、调度<ul><li>传统进程机制：进程是资源分配、调度的基本单位</li><li>引入线程后：进程是资源分配的基本单位；线程是调度的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制：只能进程间并发</li><li>引入线程后：各线程间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统进程并发：需要切换进程的运行环境，系统开销大</li><li>线程并发：如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后：并发所带来的系统开销减小</li></ul></li></ul></li><li>线程的属性：<ol><li>线程是处理机调度的基本单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块(TCB)</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程间的线程间通信无需系统干预</li><li>同一进程间的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销小</li><li>切换进程，系统开销大</li></ol></li></ul><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>引入目的</td><td>能并发执行，提高资源利用率和系统吞吐量</td><td>提高并发执行的速度，进一步提高资源利用率和系统吞吐量</td></tr><tr><td>并发性</td><td>较低</td><td>较高</td></tr><tr><td>基本属性(调度)</td><td>资源分配(拥有)的基本单位；独立调度/分派的基本单位</td><td>资源分配(拥有)的基本单位——进程；独立调度/分配的基本单位——线程</td></tr><tr><td>基本状态</td><td>就绪、执行、等待</td><td>就绪、执行、等待</td></tr><tr><td>拥有资源</td><td>资源拥有的基本单位——进程</td><td>资源拥有的基本单位——进程</td></tr><tr><td>系统开销</td><td>创建/撤销/切换时空开销较大</td><td>创建/撤销/切换时空开销较小</td></tr><tr><td>系统操作</td><td>创建，撤销，切换</td><td>创建，撤销，切换</td></tr><tr><td>存在标志</td><td>进程控制块PCB</td><td>进程控制块PCB，线程控制块TCB</td></tr></tbody></table><p>进程与线程的关系：单进程单线程；单进程多线程；多进程多单线程；多进程多线程</p><ul><li>线程的实现方式<ul><li>用户级线程(User-Level Thread, ULT)——由应用程序通过线程库实现，“从用户视角可以看到的线程”<ul><li>所有的线程管理工作都由应用程序负责(包括线程切换)</li><li>用户级线程中，线程切换在用户态下即可完成，无需操作系统干预</li><li>在用户看来，有多个线程；但是操作系统内核看来，意识不到线程的存在(用户级线程对用户不透明，对操作系统透明)</li></ul></li><li>内核级线程(Kernel-Level Thread， KLT， 内核支持的线程)——从操作系统内核视角可以看到的线程<ul><li>内核级线程的管理工作由操作系统内核完成</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成</li></ul></li></ul></li><li>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n&gt;=m)<ul><li>操作系统只“看得见”内核级线程，故<strong>内核级线程才是处理机分配的单位</strong></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401205201.png" alt="image-20210401205201171"></p><ul><li>多线程模型：<ul><li>多对一模型：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程<ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可以在多核处理机上并行运行</li></ul></li><li>一对一模型：一个用户级线程对应一个内核级线程，每个用户进程都有与之线程同数量的内核级线程<ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li><li>多对多模型：n用户级线程映射到m个内核级线程(n&gt;=m)，每个用户进程对应m个内核级线程<ul><li>克服了多对一模型并发度不高的缺点</li><li>克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401210113.png" alt="image-20210401210113278"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401210328.png" alt="image-20210401210328731"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="处理机调度的概念、层次"><a href="#处理机调度的概念、层次" class="headerlink" title="处理机调度的概念、层次"></a>处理机调度的概念、层次</h3><p>调度：当有一堆任务要处理的时候，由于资源有限，这些事情没法同时处理，这时需要确定<strong>某种规则来决定处理这些任务的顺序</strong>，这就是调度研究的问题。</p><p>处理机调度：在多道程序系统中，进程的数量往往多于处理机的个数，这样不可能同时并行地处理各个进程。处理机调度就是从就绪队列中<strong>按照一定的算法选择一个进程并将处理机分配给它运行</strong>，以实现进程的<strong>并发执行</strong>。</p><ul><li>调度的三个层次：高级调度、中级调度、低级调度</li></ul><ol><li>高级调度(作业调度)：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使其获得竞争处理机的权利。<ol><li>原因：由于内存空间有限，有时无法将用户提交的作用全部放入内存，因此需要确定某种规则来决定将作业调入内存的顺序</li><li>高级调度是<strong>辅存(外存)与内存之间</strong>的调度。每个作业只调入一次调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li><li>高级调度主要是指<strong>调入</strong>的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出</li></ol></li><li>中级调度(内存调度)：决定将哪个处于挂起状态的进程重新调入内存<ol><li>为了提高内存利用率和系统吞吐量，引入了<strong>虚拟存储技术</strong>，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存</li><li><strong>挂起状态</strong>：暂时调至外存等待的进程状态为挂机状态。<ol><li><strong>PCB并不会一起调至外存，而是会常驻内存</strong>。PCB中记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理</li><li>被挂起的进程PCB会被放到<strong>挂起队列</strong>中</li></ol></li><li>一个进程可能会被多次调出调入内存，故而中级调度发生的频率比高级调度高</li></ol></li><li>低级调度(进程调度)：安装某种方法和策略从就绪队列中选取一个进程，将处理机分配给它<ol><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须设置进程调度</li><li>进程调度的频率很高，一般几十毫秒一次</li></ol></li></ol><table><thead><tr><th></th><th>要做什么</th><th>调度发生位置</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度(作业调度)</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存-&gt;内存(面向作业)</td><td>最低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度(内存调度)</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存中</td><td>外存-&gt;内存(面向进程)</td><td>中等</td><td>挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td></tr><tr><td>低级调度(进程调度)</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td>内存-&gt;CPU</td><td>最高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402132742.png" alt="image-20210402132742382"></p><h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p>进程调度(低级调度)——按照某种算法从就绪队列中选择一个进程为其分配处理机</p><ul><li><strong>需要进行</strong>进程调度与切换的情况：有的操作系统只允许进程主动放弃处理机；有的操作系统允许有更紧急的任务需要处理时，会强行剥夺处理机(被动放弃)<ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I/O)</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I/O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能进行</strong>进程调度与切换的情况：<ol><li>在<strong>处理中断的过程中</strong>。中断过程处理复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在<strong>操作系统内核程序临界区</strong>中<ol><li>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换——√</li><li>进程处于<strong>临界区</strong>时<strong>不能</strong>进行处理机调度——×——访问普通临界资源如打印机可以进程处理机调度<ol><li>临界资源：一个时间段内只允许一个进程使用的资源，各进程<strong>互斥</strong>访问临界资源</li><li>临界区：访问临界资源的那段代码。比如打印机是一种普通的临界资源，访问打印机的临界区是可以进行调度与切换的</li><li>内核程序临界区：一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列(由各就绪进程的PCB组成)</li></ol></li></ol></li><li>在**原子操作过程中(原语)**。原子操作不可中断，要一气呵成(如修改PCB中进程状态标志，并把PCB放到相应对列)</li></ol></li></ul><p>进程调度的方式——非剥夺调度方式(非抢占方式)、剥夺调度方式(抢占方式)</p><ul><li>非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机<ul><li>在运行过程中即便有更紧迫的任务到达时，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li><li>实现简单，系统开销小但是无法及时处理紧急任务，适用于早起的批处理系统</li></ul></li><li>剥夺调度方式(抢占方式)：允许操作系统剥夺处理机(被动放弃)<ul><li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的那个进程</li><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)，适用于分时操作系统、实时操作系统</li></ul></li></ul><p><strong>广义的进程调度</strong>包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤</p><ul><li>狭义的进程调度(选择一个进程)：从就绪队列中选中一个要运行的进程。这个进程可以使刚刚被暂停执行的进程，也可能是另一个进程，后一种情况需要进程切换</li><li>进程切换：一个进程让出处理机，另一个进程占用处理机的过程<ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ol></li></ul><p>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换必然会使整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行过程的时间减少。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402141045.png" alt="image-20210402141044978"></p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><ol><li>CPU利用率：CPU“忙碌”的时间占总时间的比例<ul><li>CPU利用率=CPU忙碌的时间/总时间</li></ul></li><li>系统吞吐量：单位时间内完成作业的数量<ul><li>系统吞吐量=总共完成了多少道作业/完成作业的总时间</li></ul></li><li>周转时间：作业被提交给系统开始，到作业完成为止的这段时间间隔<ul><li>周转时间=作业完成时间-作业提交时间(用户关心单个作业周转时间)<ol><li>作业在外存后备队列上等待作业调度(高级调度)的时间——有且仅有一次</li><li>进程在就绪队列上等待进程调度(低级调度)的时间——可能发生多次</li><li>进程在CPU上执行的时间——可能发生多次</li><li>进程等待I/O操作完成的时间——可能发生多次</li></ol></li><li>平均周转时间=各作业周转时间之和/作业数(操作系统关心系统整体表现)</li><li>带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行的时间<ul><li>带权周转时间&gt;=1</li><li>带权周转时间与周转时间都是越小越好</li></ul></li><li>平均带权周转时间=各作业带权周转时间之和/作业数</li></ul></li><li>等待时间：进程/作业处于等待处理机状态时间之和<ul><li>对于<strong>进程</strong>来说，等待时间是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实是进程也是在被服务的，所以不计入等待时间</li><li>对于<strong>作业</strong>来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li><li>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间</li></ul></li><li>响应时间：从用户提交请求到首次产生响应所用的时间</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402143215.png" alt="image-20210402143215451"></p><h3 id="进程调度算法-一"><a href="#进程调度算法-一" class="headerlink" title="进程调度算法(一)"></a>进程调度算法(一)</h3><p>是否会导致<strong>饥饿</strong>：某进程/作业长时间得不到服务</p><h4 id="FCFS——先来先服务"><a href="#FCFS——先来先服务" class="headerlink" title="FCFS——先来先服务"></a>FCFS——先来先服务</h4><p>FCFS-First Come First Serve</p><blockquote><p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。</p><p>但是没有考虑到作业的运行时间，因此导致了对短作业不友好</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>主要从“公平”的角度考虑</td></tr><tr><td>算法规则</td><td>按照作业/进程到达的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占</td><td>非抢占式算法</td></tr><tr><td>优点</td><td>公平、算法实现简单</td></tr><tr><td>缺点</td><td>排在长作业(进程)后面的短作业(进程)需要等待很长时间，带权周转时间很大，对短作业用户来说用户体验不好。即<strong>FCFS算法对长作业有利，对短作业不利</strong></td></tr><tr><td>是否会导致饥饿</td><td>不会出现某进程/作业长期得不到服务的情况</td></tr></tbody></table><table><thead><tr><th>FCFS(实例)</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>11</td><td>12</td><td>16</td></tr><tr><td>周转时间(完成时间-到达时间)</td><td>7</td><td>9</td><td>8</td><td>11</td></tr><tr><td>带权周转时间(周转时间/运行时间)</td><td>7/7=1</td><td>9/4</td><td>8/1=8</td><td>11/4</td></tr><tr><td>等待时间(周转时间-运行时间)</td><td>0</td><td>5</td><td>7</td><td>7</td></tr></tbody></table><p>运行顺序：P1-&gt;P2-&gt;P3-&gt;P4</p><p>注：如果是既有计算又有I/O操作的进程，则等待时间=周转时间-运行时间-I/O操作时间</p><h4 id="SJF——短作业优先"><a href="#SJF——短作业优先" class="headerlink" title="SJF——短作业优先"></a>SJF——短作业优先</h4><p>SJF-Shortest Job First</p><blockquote><p>SJF算法是选择一个执行时间最短的作业为其服务。</p><p>因为完全不考虑各个作业的等待时间，导致了对长作业不友好，甚至会造成饥饿问题</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</td></tr><tr><td>算法规则</td><td>最短的作业/进程优先得到服务(所谓“最短”，指要求的服务时间最短)</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF，Shortest Process First)算法”</td></tr><tr><td>是否可抢占</td><td>SJF和SPF是<strong>非抢占式</strong>算法，但也有抢占式的版本——<strong>最短剩余时间优先(SRTN，Shortest Remaining Time Next)算法</strong></td></tr><tr><td>优点</td><td>“最短的”平均等待时间、平均周转时间(需要有限定条件，不然最短的是SRTN)</td></tr><tr><td>缺点</td><td>不公平；<strong>对短作业有利，对长作业不利</strong>；可能产生饥饿现象；作业/进程的运行时间由用户提供，不一定真实，不一定能真正的短作业优先</td></tr><tr><td>是否会导致饥饿</td><td>会。如果源源不断地有短作业/进程到来，可能使长作业进场长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为“饿死”</td></tr></tbody></table><table><thead><tr><th>SPF</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>周转时间(完成-到达)</td><td>7</td><td>10</td><td>4</td><td>11</td></tr><tr><td>带权周转时间(周转/运行)</td><td>7/7=1</td><td>10/4=2.5</td><td>4/1=4</td><td>11/4</td></tr><tr><td>等待时间(周转-运行)</td><td>0</td><td>6</td><td>3</td><td>7</td></tr></tbody></table><p>运行顺序：P1-&gt;P3-&gt;P2-&gt;P4</p><h4 id="SRTN-最短剩余时间算法"><a href="#SRTN-最短剩余时间算法" class="headerlink" title="SRTN-最短剩余时间算法"></a>SRTN-最短剩余时间算法</h4><ul><li>最短剩余时间算法(<strong>抢占式</strong>)：每当有进程加入就绪队列就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列；当一个进程完成时也需要调度</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402153629.png" alt="image-20210402153629614"></p><table><thead><tr><th>时刻/剩余时间</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th><th>运行</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td><td></td></tr><tr><td>完成时间</td><td>7</td><td>4</td><td>1</td><td>4</td><td></td></tr><tr><td>0</td><td>7</td><td>-</td><td>-</td><td>-</td><td>P1</td></tr><tr><td>2</td><td>5</td><td>4</td><td>-</td><td>-</td><td>P1-&gt;P2</td></tr><tr><td>4</td><td>5</td><td>2</td><td>1</td><td>-</td><td>P2-&gt;P3</td></tr><tr><td>5</td><td>5</td><td>2</td><td>-</td><td>4</td><td>P3-&gt;P2</td></tr><tr><td>7</td><td>5</td><td>-</td><td>-</td><td>4</td><td>P2-&gt;P4</td></tr><tr><td>11</td><td>5</td><td>-</td><td>-</td><td>-</td><td>P4-&gt;P5</td></tr><tr><td>16</td><td>-</td><td>-</td><td>-</td><td>-</td><td>结束</td></tr></tbody></table><table><thead><tr><th>SRTN</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>16</td><td>7</td><td>5</td><td>11</td></tr><tr><td>周转时间(完成-到达)</td><td>16</td><td>5</td><td>1</td><td>6</td></tr><tr><td>带权周转时间(周转/运行)</td><td>16/7</td><td>5/4=1.25</td><td>1/1=1</td><td>6/4=1.5</td></tr><tr><td>等待时间(周转-运行)</td><td>9</td><td>1</td><td>0</td><td>2</td></tr></tbody></table><h4 id="SJF与SRTN"><a href="#SJF与SRTN" class="headerlink" title="SJF与SRTN"></a>SJF与SRTN</h4><ol><li>如果题目未特殊说明，则“短作业/进程优先算法”<strong>默认是非抢占式</strong>的</li><li>各种限定条件下平均等待时间、平均周转时间最少的调度算法：<ol><li>在<strong>所有进程同时可运行</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</li><li>在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</li><li><strong>抢占式</strong>的短作业/进程优先调度算法(SRTN)的平均等待时间、平均周转时间最少</li></ol></li><li>虽然SJF的平均等待时间、平均周转时间并不一定最少，但相比其他算法(如FCFS算法)，SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>当选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项时，<strong>当且仅当其他选项有明显错误的情况下，才可以认为这是一个正确选项</strong></li></ol><h4 id="HRRN——高响应比优先"><a href="#HRRN——高响应比优先" class="headerlink" title="HRRN——高响应比优先"></a>HRRN——高响应比优先</h4><p>HRRN-Highest Response Ratio Next</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>综合考虑作业/进程的等待时间和要求服务的时间</td></tr><tr><td>算法规则</td><td>在每次调度时先计算各个作业/进程的响应比，选择<strong>响应比最高</strong>的作业/进程为其服务。<strong>响应比=(等待时间+要求服务时间)/要求服务时间</strong></td></tr><tr><td>用于作业/进程调度</td><td>既可以用于作业调度，又可以用于进程调度</td></tr><tr><td>是否可抢占</td><td><strong>非抢占式</strong>算法，只有当前运行的作业/进程主动放弃处理机时(正常、异常完成或主动阻塞)，才需要调度，才需要计算响应比(计算所有就绪进程的响应比，选最高的进程)</td></tr><tr><td>优点</td><td>综合考虑了等待时间和运行时间(要求服务时间)；等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)</td></tr><tr><td>缺点</td><td></td></tr><tr><td>是否会导致饥饿</td><td>不会导致饥饿——不会出现某进程/作业长期得不到服务的情况。对于长作业来说，随着等待时间越来越久，其响应比会越来越大，从而避免了长作业饥饿的问题</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402161226.png" alt="image-20210402161226172"></p><table><thead><tr><th>HRRN</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>周转时间(完成-到达)</td><td>7</td><td>10</td><td>4</td><td>11</td></tr><tr><td>带权周转时间(周转/运行)</td><td>7/7=1</td><td>10/4=2.5</td><td>4/1=4</td><td>11/4</td></tr><tr><td>等待时间(周转-运行)</td><td>0</td><td>6</td><td>3</td><td>7</td></tr></tbody></table><h4 id="FCFS、SJF-SPF、HRRN算法总结"><a href="#FCFS、SJF-SPF、HRRN算法总结" class="headerlink" title="FCFS、SJF/SPF、HRRN算法总结"></a>FCFS、SJF/SPF、HRRN算法总结</h4><p>FCFS、SJF/SPF、HRRN这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，不区分任务的紧急程度，因此对于用户来说，交互性槽糕。因此这三种算法一般适用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他算法使用，在现在也扮演着很重要的角色。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402161940.png" alt="image-20210402161940048"></p><h3 id="进程调度算法-二"><a href="#进程调度算法-二" class="headerlink" title="进程调度算法(二)"></a>进程调度算法(二)</h3><h4 id="时间片轮转调度算法-RR"><a href="#时间片轮转调度算法-RR" class="headerlink" title="时间片轮转调度算法(RR)"></a>时间片轮转调度算法(RR)</h4><p>RR-Round-Robin</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td></tr><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</td></tr><tr><td>是否可抢占</td><td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</td></tr><tr><td>优点</td><td>公平；响应快，适用于分时操作系统</td></tr><tr><td>缺点</td><td>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</td></tr><tr><td>是否会导致饥饿</td><td>不会出现某进程/作业长期得不到服务的情况</td></tr><tr><td>时间片太大时</td><td>每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为FCFS(先来先服务)调度算法，并且会增大进程响应时间；因此<strong>时间片不能太大</strong></td></tr><tr><td>时间片太小时</td><td>导致进程调度、切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少；因此<strong>时间片不能太小</strong>，一般来说，设计时间片时要让切换进程的开销不超过1%</td></tr></tbody></table><p>时间片轮转调度算法(RR)一般用于分时操作系统，更关注“响应时间”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402171543.png" alt="image-20210402171543640"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402171931.png" alt="image-20210402171931125"></p><table><thead><tr><th></th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>5</td><td>4</td><td>1</td><td>6</td></tr><tr><td>完成时间(RR时间片大小为2)</td><td>12</td><td>9</td><td>7</td><td>16</td></tr><tr><td>完成时间(RR时间片大小为5)</td><td>5</td><td>9</td><td>10</td><td>16</td></tr><tr><td>完成时间(FCFS)</td><td>5</td><td>9</td><td>10</td><td>16</td></tr></tbody></table><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>随着计算机的发展，特别是实时操作系统的实现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td></tr><tr><td>算法规则</td><td>每个作业/进程有格子的优先级，调度时选择优先级最高的作业/进程</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可以用于进程调度。设置还可以用于I/O调度中</td></tr><tr><td>是否可抢占</td><td>抢占式、非抢占式都有。做题时区别：非抢占式只需在进程主动放弃处理机时进行调度即可，抢占式还需要在就绪队列变化时检查是否会发生抢占</td></tr><tr><td>优点</td><td>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</td></tr><tr><td>缺点</td><td>若源源不断地有高优先级进程到来，则可能导致饥饿</td></tr><tr><td>是否会导致饥饿</td><td>会导致饥饿——会出现某进程/作业长期得不到服务的情况。</td></tr></tbody></table><ul><li>以下示例中规定：优先数越大，优先级越高(具体优先级确定方法视题目要求而定)</li></ul><table><thead><tr><th>优先级调度算法</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>优先数</td><td>1</td><td>2</td><td>3</td><td>2</td></tr><tr><td>完成时间(非抢占式)</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>完成时间(抢占式)</td><td>16</td><td>7</td><td>5</td><td>11</td></tr></tbody></table><ul><li>上述非抢占式优先级算法示例中的执行顺序：P1-&gt;P3-&gt;P2-&gt;P4</li><li>上述抢占式优先级算法示例执行过程见下图</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402175305.png" alt="image-20210402175305500"></p><p>PS：就绪队列未必只有一个，可以按照不同优先级来组织，另外，也可以把优先级高的进程排在更靠近队头的位置。</p><ul><li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种<ul><li>静态优先级——创建进程时确定，之后一直不变；进程优先级(通常情况下)：<ul><li>系统进程优先级高于用户进程</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好I/O型进程(或称I/O繁忙型进程)<ul><li>与<strong>I/O繁忙型进程</strong>相对的是<strong>计算型进程</strong>(或称CPU繁忙型进程)</li><li>I/O设备和CPU可以<strong>并行</strong>工作。如果优先让I/O繁忙型进程优先运行的话，越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li></ul></li></ul></li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul></li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><blockquote><p>FCFS算法——公平<br>SJF算法——能尽快处理完短作业，平均等待/周转时间等参数很优秀<br>RR算法——可以让各个进程得到及时的响应<br>优先级调度算法——可以灵活地调整各种进程被服务的机会</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>对其他调度算法的折中权衡</td></tr><tr><td>算法规则</td><td>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。2.新进程到达时先进入到第1级队列，按FCFS原则排序等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾；如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占</td><td><strong>抢占式</strong>算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，<strong>新进程会抢占处理机，原来运行的进程放回k级队列队尾</strong></td></tr><tr><td>优点</td><td>对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点);短进程只用较少的时间就可完成(FPF的优点);不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、I/O密集型进程(PS：可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</td></tr><tr><td>缺点</td><td></td></tr><tr><td>是否会导致饥饿</td><td>会出现某进程/作业长期得不到服务的情况——如果有源源不断的短进程(比如可以在第一级队列中被处理完的短进程)到达，那么在低级就绪队列的长进程就会长期得不到服务</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402201559.png" alt="image-20210402201559273"></p><table><thead><tr><th></th><th>P1</th><th>P2</th><th>P3</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>1</td><td>5</td></tr><tr><td>运行时间</td><td>8</td><td>4</td><td>1</td></tr><tr><td>完成时间</td><td>13</td><td>8</td><td>6</td></tr></tbody></table><h4 id="进程调度算法-二-总结"><a href="#进程调度算法-二-总结" class="headerlink" title="进程调度算法(二)总结"></a>进程调度算法(二)总结</h4><p>比起早期的批处理操作系统，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时交互系统)更注重系统的<strong>响应时间、公平性、平衡性等指标</strong>。这几种算法恰好也能较好地满足交互式系统的需求，故而这三种算法适用于<strong>交互式系统</strong>(UNIX系统使用的就是多级反馈队列调度算法)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402202547.png" alt="image-20210402202547892"></p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><p>进程的异步性：各并发执行的进程以各自独立的、不可预知的速度向前推进。比如管道通信，读进程与写进程并发地运行，由于并发必然导致异步，因此“写数据”与“读数据”这两个操作执行的先后顺序是不确定的，而实际应用中又要求按照“写数据-&gt;读数据”的顺序执行，<strong>进程同步</strong>所讨论的内容就是解决这种异步问题</p><ul><li>同步亦称直接制约关系<strong>，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上</strong>协调它们的工作次序而产生的制约关系**，进程间的直接制约关系就是源于它们之间的相互合作</li></ul><p>对于<strong>临界资源</strong>(一个时间段内只允许一个进程使用的资源)的访问必须<strong>互斥</strong>地进行。(许多物理设备，比如摄像头、打印机，都属于临界资源；除此之外还有许多的变量、数据、内存缓冲区等也都属于临界资源)</p><ul><li><p>互斥亦称间接制约关系<strong>，是指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须</strong>等待**；当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p></li><li><p>对于临界资源的互斥访问在逻辑上可以分为四个部分：</p><ol><li>进入区(entry section)：负责检查是否可进入临界区，若可进入，则应**设置正在访问临界资源的标志(可理解为“上锁”)**，以阻止其他进程同时进入临界区<ul><li>与退出区组成<strong>负责实现互斥的代码段</strong></li></ul></li><li>临界区(critical section，又称为“临界段”)：访问临界资源的那段代码</li><li>退出区(exit section)：负责<strong>解除正在访问临界资源的标志(可理解为“解锁”)</strong><ul><li>与进入区组成<strong>负责实现互斥的代码段</strong></li></ul></li><li>剩余区(remainder section)：做其他处理</li></ol></li><li><p>进程互斥需要遵循的原则：</p><ol><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403102038.png" alt="image-20210403102038161"></p><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想：两个进程在<strong>访问完临界区之后</strong>会把使用临界区的权限转交给另一个进程，即<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p><p>单标志法可以实现<strong>同一时刻最多只允许一个进程访问临界区</strong>，且一般情况下要求<strong>轮流顺序访问</strong>；如下图示例，P0和P1互斥，同一时间他们之中只有一个进程可以访问临界区，而且是按照P0-&gt;P1-&gt;P0-&gt;P1……的轮流顺序来访问的(P0结束后turn=1，P1结束之后turn=0)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403102704.png" alt="image-20210403102704430"></p><p>单标志法存在的问题：<strong>违背空闲让进原则</strong>。如上图示例，因为是<strong>轮流访问</strong>，所以初始允许进入临界区的进程是P0，倘若P0一直不访问临界区，那么<strong>虽然此时临界区空闲，但是并不允许P1进入临界区</strong>。</p><h4 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h4><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如”flag[0]=true”表示0号进程P0想要进入临界区；flag[]初始化的时候每个位置都设置为false；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应标志flag[i]设置为true，之后再开始访问临界区。</p><p>双标志先检查法存在的问题：<strong>违背忙则等待原则</strong>，原因在于<strong>进入区的检查和上锁这两个处理不是一气呵成的(不是原子操作)<strong>，在</strong>检查之后上锁之前可能发生进程切换</strong>。由于进程是并发执行的，进程异步推进，当按照某种顺序执行的时候，各个进程是有可能同时访问临界区，例如下图示例中，如果按照<strong>①⑤②⑥③⑦……</strong>这样的顺序执行，P0和P1会同时访问临界区</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403104139.png" alt="image-20210403104139666"></p><h4 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h4><p>算法思想：双标志先检查法的改版，由<strong>先检查后上锁</strong>改为了<strong>先上锁后检查</strong>的方法来避免出现两个进程同时进入临界区的问题。</p><p>双标志后检查法存在的问题：<strong>违背空闲让进、有限等待原则</strong>，会因各进程都长期无法访问临界资源而产生饥饿现象；原因在于<strong>进入区的上锁和检查这两个处理不是一气呵成的(不是原子操作)<strong>，在</strong>上锁之后检查之前可能发生进程切换</strong>。由于进程是并发执行的，进程异步推进，当按照某种顺序执行的时候，各个进程是有可能都不可以访问临界区，例如下图示例中，如果按照<strong>①⑤②⑥……</strong>这样的顺序执行，P0和P1将都不能访问临界区</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403104556.png" alt="image-20210403104556404"></p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><blockquote><p>上诉三种算法出现问题的地方往往是<strong>两个或多个进程并发执行的时候</strong>，并发执行的异步性容易导致问题的出现，比如<strong>标志位的设置与检查不是原子操作</strong>就会导致问题。</p></blockquote><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但谁也不让谁，最后谁都无法进入临界区，Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，<strong>主动让对方先使用临界区。</strong></p><p>进入区：1.主动争取。2.主动谦让。3.检查对方是否也想使用，且最后一次是不是自己说了“客气话”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403110310.png" alt="image-20210403110310835"></p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然<strong>未遵循让权等待</strong>的原则。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403110532.png" alt="image-20210403110531969"></p><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>算法思想：利用<strong>开/关中断指令</strong>实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p><ul><li>优点：简单、高效</li><li>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(开/关中断指令只能运行于内核态)</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403111014.png" alt="image-20210403111014606"></p><h4 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet(TS指令/TSL指令)"></a>TestAndSet(TS指令/TSL指令)</h4><p>TestAndSet指令简称为TS指令，也有地方称为TestAndSetLock指令，简称为TSL指令。<strong>TSL指令使用硬件实现，执行的过程不允许被中断</strong>，只能一气呵成。</p><p>算法思想：使用布尔型共享变量lock来描述临界区是否被加锁，TSL指令会加锁lock并返回lock指令原本的值(存在old中)，当且仅当返回值为false时，当前进程才可以使用临界区，否则只能一直执行TSL指令等待其他进程解锁lock(解锁临界区)</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：<strong>不满足让权等待原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403111648.png" alt="image-20210403111648624"></p><h4 id="Swap-XCHG指令"><a href="#Swap-XCHG指令" class="headerlink" title="Swap(XCHG指令)"></a>Swap(XCHG指令)</h4><p>Swap指令有时叫Exchange指令，或简称XCHG指令；<strong>Swap指令使用硬件实现，执行过程不允许被中断</strong>，只能一气呵成。</p><p>算法思想：逻辑上看Swap思想与TSL并无太大区别(在硬件层面的具体实现上有区别)，都是先记录当前临界区是否被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：<strong>不满足让权等待原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403112214.png" alt="image-20210403112214670"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403112609.png" alt="image-20210403112609307"></p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>进程互斥的软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法</p><p>进程互斥的硬件实现方式：中断屏蔽算法、TS/TSL指令、Swap/SCHG指令</p><ol><li>在双标志先检查法中，<strong>进入区的检查与上锁操作不能一气呵成</strong>，从而导致了两个进程有可能同时进入临界区</li><li>所有的解决方案都<strong>无法实现让权等待</strong></li></ol><p>用户进程可以通过使用操作系统提供的一对原语来对<strong>信号量</strong>进行操作，从而方便的实现了进程互斥、进程同步。其中，<strong>信号量其实是一个变量</strong>(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如系统中只有一台打印机，可以设置一个初始值为1的信号量来表示打印机资源的可使用情况(1表示有一台可用，0表示此资源已被其他进程占用)</p><p><strong>一对原语</strong>：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数；wait、signal原语通常简称为P、V操作(来自荷兰语proberen和verhogen)，因此wait(S)可简写为P(S)，signal(S)可以简写为V(S)</p><blockquote><p><strong>信号量机制</strong>可以实现互斥、同步、对一类系统资源的申请和释放</p><ol><li>互斥：设置初值为1的互斥信号量</li><li>同步：设置初值为0的同步信号量(实现一前一后)</li><li>对一类系统资源的申请和释放：设置一个信号量，初始值即为系统资源的数量(本质上也是同步问题，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续向下执行)</li></ol></blockquote><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量：用一个整数型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong>；与普通整数变量的区别——对信号量的操作只有三种，即<strong>初始化、P操作、V操作</strong></p><p>比如系统中只有一台打印机，可以使用整型信号量来表示打印机资源的数量：初始化S=1；wait(S)操作相当于“进入区”，先检查S资源数量，若<strong>资源数量不够则循环等待</strong>，若资源数量够则占用一个资源S-=1；signal(S)操作相当于“退出区”，释放一个资源S+=1。</p><p>整型信号量存在的问题：<strong>不满足让权等待原则</strong></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403123348.png" alt="image-20210403123348310"></p><p>PS：有一点逻辑问题——上面的wait(S)中，因为这是一个原语，所以while循环等待的时候处于原子操作中，无法被中断，也就无法切换进程，但实际情况上并非如此，此处仅是展示算法思想才这么写</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>记录型信号量：使用记录型数据结构表示信号量，以解决整型信号量存在的“忙等”问题；</p><ol><li>记录型数据结构除了记录剩余资源数量以外，还会记录<strong>等待队列</strong>；</li><li>wait(S)操作中，先假设此进程会占用一个系统资源(S.value–)，若没有可用资源(S.value&lt;0)，会<strong>将当前进程放入等待队列中(block操作)<strong>，让出处理机，实现了</strong>忙则等待</strong>；</li><li>signal(S)操作中，除了释放占用的资源外(S.value++)，还会判断等待队列中有没有处于等待状态的进程(S.value&lt;=0)，如果有的话，**取出并恢复队头进程(wakeup操作)**。</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403125102.png" alt="image-20210403125102299"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403125309.png" alt="image-20210403125309641"></p><p>PS：题目中遇到的信号量不做特殊说明的情况下，默认是<strong>记录型信号量</strong></p><h3 id="信号量机制实现进程互斥、同步、前驱关系"><a href="#信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="信号量机制实现进程互斥、同步、前驱关系"></a>信号量机制实现进程互斥、同步、前驱关系</h3><h4 id="进程互斥-信号量机制"><a href="#进程互斥-信号量机制" class="headerlink" title="进程互斥(信号量机制)"></a>进程互斥(信号量机制)</h4><ol><li>分析并发进程的关键活动，划定临界区(如对临界资源打印机的访问就应放在临界区中)</li><li>设置互斥信号量mutex(一般设置为这个名字)，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p>PS：对于不同的临界资源需要设置不同的互斥信号量；P、V操作必须成对出现，缺少P操作就不能保证临界资源的互斥访问，缺少V操作就会导致资源永不被释放，等待进程永不被唤醒</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403131159.png" alt="image-20210403131159580"></p><h4 id="进程同步-信号量机制"><a href="#进程同步-信号量机制" class="headerlink" title="进程同步(信号量机制)"></a>进程同步(信号量机制)</h4><p>进程同步：各并发执行的进程按要求有序地推进</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>假设如图所示的两个进程，P2进程的代码4必须在P1进程的代码2之后执行：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403131633.png" alt="image-20210403131633850"></p><h4 id="进程前驱关系-信号量机制"><a href="#进程前驱关系-信号量机制" class="headerlink" title="进程前驱关系(信号量机制)"></a>进程前驱关系(信号量机制)</h4><p>其实<strong>每一对前驱关系</strong>都是<strong>一个进程同步问题</strong>，即需要保证一前一后的操作</p><ol><li>为每一对前驱关系设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行V操作</li><li>在“后操作”之前对相应的同步变量执行P操作</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403132206.png" alt="image-20210403132206665"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403132305.png" alt="image-20210403132305485"></p><h3 id="经典进程互斥同步问题"><a href="#经典进程互斥同步问题" class="headerlink" title="经典进程互斥同步问题"></a>经典进程互斥同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用(这里的产品可理解为某种数据)</p><ol><li>生产者消费者共享一个初始为空，大小为n的缓冲区；<ol><li>空闲缓冲区初始值数量为n</li><li>非空闲缓冲区(产品)的数量为0</li></ol></li><li>只有<strong>缓冲区没满</strong>时，生产者才能把产品放入缓冲区中，否则必须等待<ol><li>同步关系。缓冲区满时，生产者要等待消费者取走产品</li></ol></li><li>只有<strong>缓冲区不空</strong>时，消费者才能从中取出产品，否则必须等待<ol><li>同步关系。缓冲区空时，消费者要等待生产者放入产品</li></ol></li><li>缓冲区是指临界资源，各进程必须<strong>互斥</strong>地访问<ol><li>倘若缓冲区不互斥，那么可能出现两个生产者进程同时向缓冲区放数据的情况，有可能导致缓冲区内数据顺序错乱，或者一个进程放的时候已经将缓冲区放满了，另一个进程强行放的时候将数据覆盖</li></ol></li></ol><ul><li>生产者消费者问题-PV操作题目分析步骤：<ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序<ol><li>生产者每次消耗(P)一个空闲缓冲区，并生产(V)一个产品</li><li>消费者每次消耗(P)一个产品，并释放(V)一个空闲缓冲区</li><li>往缓冲区放入/取走产品需要互斥</li></ol></li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值；互斥信号量初值一般设置为1，同步信号量的初始值要看对应的系统资源的初始值是多少</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty&#x3D;n;  &#x2F;&#x2F; 同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full&#x3D;0;   &#x2F;&#x2F; 同步信号量，表示非空闲缓冲区(产品)的数量</span><br><span class="line">producer()&#123;  &#x2F;&#x2F; 生产者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);        &#x2F;&#x2F; 把产品放入空闲缓冲区</span><br><span class="line">        P(mutex);        &#x2F;&#x2F; 占用缓冲区(互斥操作)</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);        &#x2F;&#x2F; 取消占用缓冲区(互斥操作)</span><br><span class="line">        V(full);         &#x2F;&#x2F; 增加一个产品(非空闲缓冲区)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123; &#x2F;&#x2F; 消费者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);         &#x2F;&#x2F; 消耗一个产品(非空闲缓冲区)</span><br><span class="line">        P(mutex);        &#x2F;&#x2F; 占用缓冲区(互斥操作)</span><br><span class="line">        从缓冲区中去除一件产品;</span><br><span class="line">        V(mutex);        &#x2F;&#x2F; 取消占用缓冲区(互斥操作)</span><br><span class="line">        V(empty);        &#x2F;&#x2F; 增加一个空闲缓冲区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥是<strong>同一进程</strong>中进程一对PV操作</li><li>实现同步是在其中一个进程中执行P，在另一个进程中执行V</li></ul><blockquote><ol><li>实现互斥的P操作一定要在实现同步的P操作之后</li><li>V操作不会使进程进入阻塞状态，因此两个V操作顺序可以变换</li></ol></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403135609.png" alt="两组同步关系及PV顺序"></p><h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放苹果，妈妈专门向盘子中放橘子，儿子专门等着吃盘子中的橘子，女儿专门等着吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；当且仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出水果。</p><ul><li>多生产者-多消费者问题，PV操作题目分析步骤：<ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系<ol><li>互斥关系：对缓冲区(盘子)的访问要互斥地进行</li><li>同步关系：<ol><li>爸爸将苹果放入盘子后，女儿才能取苹果</li><li>妈妈将句子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果(盘子为空这个事件由儿子或女儿取出水果后触发)</li></ol></li></ol></li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值；互斥信号量初值一般设置为1，同步信号量的初始值要看对应的系统资源的初始值是多少<ol><li>互斥关系：对缓冲区(盘子)的访问设置一个信号量mutex=1</li><li>同步关系：<ol><li>爸爸和女儿之间由苹果联系，设置apple=0</li><li>妈妈和儿子之间由橘子联系，设置orange=0</li><li>爸爸和妈妈放水果需要看盘子，设置plate=1</li></ol></li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403141212.png" alt="image-20210403141212426"></p><p>PS：对于本题来说，由于<strong>缓冲区的大小为1</strong>，所以在任何时刻，apple、orange、plate三个同步信号量最多只有一个是1，所以在任何时刻最多只有一个进程的P操作不会被阻塞，能顺利进入临界区，也就是<strong>对于本题来说</strong>，即便不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象；但倘若<strong>缓冲区的大小设置为2及以上</strong>的话，就可能出现两个进程(如爸爸进程和妈妈进程)同时访问缓冲区的情况，有可能导致两个进程的写入缓冲区的数据相互覆盖的情况。</p><blockquote><ol><li>如果<strong>缓冲区的大小大于1</strong>，就<strong>必须设置</strong>一个专门的<strong>互斥信号量mutex</strong>来保证互斥访问缓冲区</li><li>如果<strong>缓冲区的大小为1</strong>，那么<strong>有可能不需要设置</strong>一个专门的<strong>互斥信号量mutex</strong>来保证互斥访问缓冲区(可不可以不设置互斥信号量需要具体问题具体分析)</li></ol></blockquote><p>在分析同步问题(一前一后问题)的时候，不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系，即正确的分析方法是<strong>从“事件”的角度</strong>来考虑，可以把“进程行为的前后关系”抽象为“事件的前后关系”。</p><p>比如可以从上面示例中找出与盘子(缓冲区)有关的<strong>四种前后关系(还有其他前后关系)</strong>(1)女儿取走盘子中的苹果-&gt;爸爸向盘子中放苹果、(2)女儿取走盘子中的苹果-&gt;妈妈向盘子中放橘子、(3)儿子取走盘子中的橘子-&gt;妈妈向盘子中放橘子、(4)儿子取走盘子中的橘子-&gt;爸爸向盘子中放苹果；<br>可以将<strong>“前”和“后”</strong>抽象为<strong>两种事件</strong>，即<strong>盘子为空事件</strong>和<strong>放入水果事件</strong>，其中盘子为空事件由女儿或者儿子取走水果引发，放入水果事件由爸爸或者妈妈放入水果引发；<br><strong>上述的四种前后关系可以抽象为一种前后关系——盘子为空事件-&gt;放入水果事件</strong>，这样就可以用一个同步信号量plate来表示盘子是否为空了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403144030.png" alt="image-20210403144029959"></p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>问题描述：设计一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽调一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一支烟并抽掉他，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(<strong>让三个抽烟者轮流地抽烟</strong>)</p><p>问题分析：可以将桌子抽象为容量为1的缓冲区，要互斥访问；由三个抽烟者所需物品可提供三种组合方式，组合一为纸和胶水，组合二为烟草和胶水，组合三为烟草和纸；桌子上有组合一-&gt;第一个抽烟者拿走东西，桌子上有组合二-&gt;第二个抽烟者拿走东西，桌子上有组合三-&gt;第三个抽烟者拿走东西，桌子上没有东西(抽烟者拿走东西，发出信号)-&gt;供应者往桌子上放下一个组合</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404100159.png" alt="image-20210404100159828"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore offer1&#x3D;0; &#x2F;&#x2F; 桌子上组合一的数量</span><br><span class="line">semaphore offer2&#x3D;0; &#x2F;&#x2F; 桌子上组合二的数量</span><br><span class="line">semaphore offer3&#x3D;0; &#x2F;&#x2F; 桌子上组合三的数量</span><br><span class="line">semaphore finish&#x3D;0; &#x2F;&#x2F; 抽烟是否完成</span><br><span class="line">int i&#x3D;0;            &#x2F;&#x2F; 用于实现“三个抽烟者轮流抽烟”</span><br><span class="line">&#x2F;&#x2F; 缓冲区容量为1，可以不设置互斥信号量</span><br><span class="line">provider() &#123;  &#x2F;&#x2F; 供应者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            将组合一放到桌子上;</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;</span><br><span class="line">            将组合二放到桌子上;</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;</span><br><span class="line">            将组合三放到桌子上;</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i&#x3D;(i+1)%3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1() &#123;   &#x2F;&#x2F; 抽烟者一进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        从桌子上拿走组合一；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2() &#123;   &#x2F;&#x2F; 抽烟者二进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌子上拿走组合二；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3() &#123;   &#x2F;&#x2F; 抽烟者三进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌子上拿走组合三；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置信号量数组——不确定这种是否可行，仅是看完哲学家进餐问题的解放方案之后的个人想法</span><br><span class="line">semaphore offer[3]&#x3D;&#123;0,0,0&#125;; &#x2F;&#x2F; 桌子上三种组合各自的数量</span><br><span class="line">semaphore finish&#x3D;0;         &#x2F;&#x2F; 抽烟是否完成</span><br><span class="line">int i&#x3D;0;                    &#x2F;&#x2F; 用于实现“三个抽烟者轮流抽烟”</span><br><span class="line">&#x2F;&#x2F; 缓冲区容量为1，可以不设置互斥信号量</span><br><span class="line">provider() &#123;  &#x2F;&#x2F; 供应者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            将组合一放到桌子上;</span><br><span class="line">            V(offer[0]);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;</span><br><span class="line">            将组合二放到桌子上;</span><br><span class="line">            V(offer[1]);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;</span><br><span class="line">            将组合三放到桌子上;</span><br><span class="line">            V(offer[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        i&#x3D;(i+1)%3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smokeri() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;         &#x2F;&#x2F; 吸烟者一</span><br><span class="line">            P(offer[0]);</span><br><span class="line">            从桌子上拿走组合一；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;  &#x2F;&#x2F; 吸烟者二</span><br><span class="line">            P(offer[1]);</span><br><span class="line">            从桌子上拿走组合二；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;  &#x2F;&#x2F; 吸烟者三</span><br><span class="line">            P(offer[2]);</span><br><span class="line">            从桌子上拿走组合三；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>吸烟者问题可以解决<strong>“可以生产多个产品的单生产者”</strong>问题：<br><strong>轮流</strong>让各个吸烟者吸烟必须<strong>轮流</strong>地在桌子上放上组合一、二、三，这里可以用<strong>一个整型变量i递增取模</strong>的方式实现这个<strong>轮流</strong>的过程；<br>如果改为<strong>随机</strong>让一个吸烟者吸烟的话，可以采用random的方式来决定每次是谁吸烟。</p></blockquote><p>若一个生产者要生产多种产品(或者说会引发多种前驱事件)，那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程(与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据)同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程和写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出</p><p>两类进程——写进程、读进程；互斥关系——写进程-写进程、写进程-读进程</p><p>写进程和任何进程都互斥，可设置一个<strong>互斥信号量rw</strong>，通过P(rw)和V(rw)操作来对共享文件进程“上锁”和“解锁”，既然各个读进程都需要同时访问，而读进程与写进程之间又必须互斥访问，那么可以<strong>让第一个访问文件的读进程“加锁”</strong>，<strong>让最后一个访问文件的读进程“解锁”</strong>，可以设置一个count来记录当前有几个读进程在访问文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore rw&#x3D;1;     &#x2F;&#x2F; 当前是否有进程在访问共享文件，实现互斥</span><br><span class="line">int count&#x3D;0;        &#x2F;&#x2F; 记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 用于保证对count变量的互斥访问</span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(rw);  &#x2F;&#x2F; 写之前“加锁”</span><br><span class="line">        写文件……</span><br><span class="line">        V(rw);  &#x2F;&#x2F; 写之后“解锁”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            P(rw);   &#x2F;&#x2F; 第一个读进程负责“加锁”</span><br><span class="line">        count++;     &#x2F;&#x2F; 访问文件的读进程数+1</span><br><span class="line">        V(mutex);</span><br><span class="line">        读文件……</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        count--;     &#x2F;&#x2F; 访问文件的读进程数-1</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            V(rw);   &#x2F;&#x2F; 最后一个读进程负责“解锁”</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这种方法存在的问题：只要有读进程在读，写进程就会被阻塞，可能“饿死”，违背了有限等待，这种算法中读进程优先，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了解决上述的“写进程可能会饿死”的情况，新增加一个互斥信号量w</span><br><span class="line">semaphore rw&#x3D;1;     &#x2F;&#x2F; 当前是否有进程在访问共享文件，实现互斥</span><br><span class="line">int count&#x3D;0;        &#x2F;&#x2F; 记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 用于保证对count变量的互斥访问</span><br><span class="line">semaphore w&#x3D;1;      &#x2F;&#x2F; 实现“写优先”(先来先服务，并不是真正的写优先</span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);  &#x2F;&#x2F; 写之前“加锁”</span><br><span class="line">        写文件……</span><br><span class="line">        V(rw);  &#x2F;&#x2F; 写之后“解锁”</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            P(rw);   &#x2F;&#x2F; 第一个读进程负责“加锁”</span><br><span class="line">        count++;     &#x2F;&#x2F; 访问文件的读进程数+1</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件……</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        count--;     &#x2F;&#x2F; 访问文件的读进程数-1</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            V(rw);   &#x2F;&#x2F; 最后一个读进程负责“解锁”</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也不是真正的写优先，而是相对公平的先来先服务原则</span><br><span class="line">&#x2F;&#x2F; 即写进程会将w上锁，使后面的连续不断的读进程暂时进入等待队列，写进程结束之后才会解锁，按照到达的顺序执行后续的进程，保证了先来的写进程不会被后来的读进程淹没</span><br></pre></td></tr></table></figure><blockquote><p>读者-写者问题为解决<strong>复杂的互斥问题</strong>提供了思路：<br>核心思想在于设置<strong>一个计数器count</strong>用来记录当前正在访问共享文件的读进程数，可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出同一进程的不同处理；<br>由于<strong>对count的检查和赋值不能一气呵成，故需要互斥信号量</strong>，从而避免多个读进程同时成为第一个读进程的情况；对于写进程饥饿的情况，可以设置一个互斥信号了来保证<strong>先来先服务</strong>的原则。</p></blockquote><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：一个圆桌上坐着5位哲学家，每两个哲学家之间的桌子上摆一根筷子，桌子中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人，只有当哲学家饥饿时，才试图拿起左、右两根筷子(<strong>一根一根拿起</strong>)，如果筷子已经在他人手上，则需要等待，饥饿的哲学家<strong>只有同时拿起两根筷子才可以开始进餐</strong>，当进餐完毕之后，放下筷子继续思考。</p><p>系统中有五个哲学家进程，5位哲学家与左右邻居对其中间的筷子的访问是互斥关系；每个哲学家进程需要同时持有<strong>两个临界资源</strong>才能开始吃饭，如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓；定义<strong>互斥信号量数组chopstick[5]={1,1,1,1,1}<strong>来实现5个筷子的互斥访问，并对哲学家进行编号</strong>0~4</strong>，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404111614.png" alt="image-20210404111614235"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照题目描述，似乎可以直接写出下述算法，但这种算法存在死锁的情况</span><br><span class="line">&#x2F;&#x2F; 当5个哲学家并发地拿起了左手边的筷子时，会进入死锁状态——所有哲学家都拥有自己左手边的筷子，所有哲学家右手边的筷子都被别人拿走了，没有任何一个哲学家拥有两根筷子，也就没有任何一个哲学家会释放资源，都无法吃放都无法思考，所有哲学家都循环等待右边的哲学放下筷子(哲学家进程进入阻塞状态)，系统进入死锁状态</span><br><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最多允许4名哲学家同时进餐"><a href="#最多允许4名哲学家同时进餐" class="headerlink" title="最多允许4名哲学家同时进餐"></a>最多允许4名哲学家同时进餐</h5><p>最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore max&#x3D;4;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        wait(max);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        signal(max);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="奇数号哲学家先左后右，偶数号哲学家先右后左"><a href="#奇数号哲学家先左后右，偶数号哲学家先右后左" class="headerlink" title="奇数号哲学家先左后右，偶数号哲学家先右后左"></a>奇数号哲学家先左后右，偶数号哲学家先右后左</h5><p>要求奇数号哲学家先拿左手边的筷子，再拿右手边的筷子，偶数号哲学家先拿右手边的筷子，再拿左手边的筷子；可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞，避免了占有一只筷子后等待另一只的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if (i%2&#x3D;&#x3D;1) &#123;</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AND信号量机制，同时拿两只筷子"><a href="#AND信号量机制，同时拿两只筷子" class="headerlink" title="AND信号量机制，同时拿两只筷子"></a>AND信号量机制，同时拿两只筷子</h5><p>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子，使用AND信号量机制(Swait和Ssignal)可以避免多个资源共享导致的死锁，即多个资源<strong>同时“上锁”</strong>或<strong>同时“解锁”</strong>，不会出现申请完一个资源之后因为另一个资源无法使用而进入阻塞状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        Swait(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        Ssignal(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哲学家互斥地拿筷子"><a href="#哲学家互斥地拿筷子" class="headerlink" title="哲学家互斥地拿筷子"></a>哲学家互斥地拿筷子</h5><p>各哲学家拿筷子这件事必须互斥的执行，保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子；当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 互斥地拿筷子</span><br><span class="line">Pi()&#123;               &#x2F;&#x2F; i号哲学家进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-3号哲学家先左后右，4号哲学家先右后左"><a href="#0-3号哲学家先左后右，4号哲学家先右后左" class="headerlink" title="0~3号哲学家先左后右，4号哲学家先右后左"></a>0~3号哲学家先左后右，4号哲学家先右后左</h5><p>要求0~3号哲学家先拿左手边的筷子，再拿右手边的筷子，4号哲学家先拿右手边的筷子，再拿左手边的筷子；可以保证如果3号和4号哲学家或者4号和0号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞，避免了占有一只筷子后等待另一只的情况；即可以保证最起码五个哲学家中有一个能拿到两只筷子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if (i&#x3D;&#x3D;4) &#123;</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哲学家进餐问题的关键在于<strong>解决进程死锁</strong>，这些进程之间仅存在互斥关系，而且每个进程都需要<strong>同时持有两个临界资源</strong>，因此存在<strong>死锁</strong>的隐患；当遇到需要<strong>同时持有多个临界资源</strong>的情况，可以参考哲学家进餐问题的解决方案，分析进程之间是否存在循环等待，是否会发生死锁</p></blockquote><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>引入管程的原因：信号量机制存在编写程序困难、易出错的问题；希望设计一种机制，<strong>让程序员写程序时不需要关注复杂的PV操作</strong>，让写代码更轻松</p><p>1973年，Brinch Hansen在程序设计语言(Pascal)中引入了“管程”——一种<strong>高级同步机制</strong></p><ul><li>管程是一种特殊的<strong>软件模块</strong>，组成部分如下：<ol><li>局部于管程的<strong>共享数据结构</strong>说明</li><li>对该数据结构进行操作的一组<strong>过程</strong>(可以理解为“函数”)</li><li>对局部于管程的共享数据<strong>设置初始值</strong>的语句</li><li>管程有一个名字</li></ol></li><li>管程的<strong>基本特征</strong>：<ol><li>局部于管程的数据只能被局部于管程的过程所访问<ul><li>管程中的数据只能通过管程的函数访问</li></ul></li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据<ul><li>进程必须通过管程的函数才能访问管程中的数据</li></ul></li><li>每次仅允许一个进程在管程内执行某个内部过程<ul><li>同一时间只有一个进程可以使用管程中的某个函数</li></ul></li></ol></li></ul><h4 id="用管程解决生产者消费者问题"><a href="#用管程解决生产者消费者问题" class="headerlink" title="用管程解决生产者消费者问题"></a>用管程解决生产者消费者问题</h4><p>引入管程的目的是为了<strong>更方便地实现进程互斥和同步</strong></p><ol><li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——即局部于管程的过程(可以理解为函数)，比如下述示例中的讲产品放入缓冲区的insert函数和从缓冲区中取出产品的remove函数</li><li>只有通过这些特定的“入口”才可以访问共享数据</li><li>管程中有很多“入口”，但<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>，如下述示例中各进程需要互斥地访问共享缓冲区，管程的这一特性即可保证同一时间段内最多只会有一个进程在访问缓冲区。(PS：这种互斥特性是由编译器负责实现的，程序员无需关心)</li><li>可以在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li></ol><p>程序员可以通过某种特殊的语法定义一个管程，之后其他程序员就可以使用这个管程提供的“入口”(<strong>封装的思想</strong>)很方便地使用实现进程同步/互斥了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下是类C的伪代码，非实际代码</span><br><span class="line">&#x2F;&#x2F; 管程</span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">  condition full, empty;    &#x2F;&#x2F; 条件变量用来实现同步(排队)</span><br><span class="line">  int count&#x3D;0;              &#x2F;&#x2F; 缓冲区内部的产品数量</span><br><span class="line">  &#x2F;&#x2F; 省去了对于缓冲区的定义，实际应用中需要定义</span><br><span class="line">  void insert(Item item) &#123;  &#x2F;&#x2F; 把产品item放入缓冲区</span><br><span class="line">    if(count&#x3D;&#x3D;N)</span><br><span class="line">      wait(full);</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    if(count&#x3D;&#x3D;1)</span><br><span class="line">      signal(empty);</span><br><span class="line">  &#125;</span><br><span class="line">  Item remove() &#123;           &#x2F;&#x2F; 从缓冲区中取出一个产品</span><br><span class="line">    if(count&#x3D;&#x3D;0)</span><br><span class="line">      wait(empty);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;N-1)</span><br><span class="line">      signal(full);</span><br><span class="line">    return remove_item();</span><br><span class="line">  &#125;</span><br><span class="line">end monitor;</span><br><span class="line">&#x2F;&#x2F; 生产者进程</span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item&#x3D;生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消费者进程</span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item&#x3D;ProducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java中类似于管程的机制"><a href="#Java中类似于管程的机制" class="headerlink" title="Java中类似于管程的机制"></a>Java中类似于管程的机制</h4><p>Java中，如果用<strong>关键字synchronized</strong>来描述一个函数，那么这个函数在同一时间段内只能被一个线程调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">monitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> Item[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404133849.png" alt="image-20210404133849669"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><ul><li>死锁：在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</strong>的现象。(发生死锁后若无外力干涉，这些进程都将无法向前推进)</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如SPF算法中若有源源不断的短进程到来，则长进程就一直得不到处理机，从而发生长进程饥饿</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑Bug导致的，有时是程序员故意设计的</li></ul><p>三者的共同点：都是<strong>进程无法顺利向前推进的现象</strong>(故意设计的死循环除外)</p><table><thead><tr><th></th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>死锁一定是<strong>循环等待对方手里的资源</strong>导致的，因此如果有死锁现象，那么<strong>至少有两个及以上的进程同时发生死锁</strong>，另外，发生死锁的进程一定处于<strong>阻塞态</strong></td></tr><tr><td>饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是<strong>阻塞态</strong>(如长期得不到I/O设备)，也可能是<strong>就绪态</strong>(长期得不到处理机)</td></tr><tr><td>死循环</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是<strong>运行态</strong>)，只不过无法像期待的那样顺利推进。</td></tr></tbody></table><ul><li><p>死锁和饥饿是由于操作系统分配资源的策略不合理导致的，死循环是由代码的错误导致的</p></li><li><p>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者(应用程序员)的问题</p></li><li><p>死锁的四个<strong>必要条件</strong>：</p><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这种可以同时让多个进程使用的资源是不会导致死锁的，因为进程不用阻塞等待这种资源</li><li>不剥夺条件：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ol></li></ul><p>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(<strong>循环等待是死锁的必要不充分条件</strong>)；如果同类资源数大于1，则即使有循环等待，也未必发生死锁，但如果系统中<strong>每类资源都只有一个</strong>，那循环等待就是死锁的<strong>充分必要条件</strong>了。</p><ul><li><p>什么时候会发生死锁：<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></p><ol><li>对资源的竞争。各进程对不可剥夺资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占用了资源R1、R2，之后进程P1又紧接着申请资源R2，进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li><li>信号量的使用不当。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能会发生死锁(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li></ol></li><li><p>死锁的处理策略：</p><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li><li>死锁的检测和接触。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施来接触死锁</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404141928.png" alt="image-20210404141928545"></p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>预防死锁：破坏死锁产生的四个必要条件中的一个或几个，只要其中有一个或几个条件不满足，就不会发生死锁</p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术，操作系统可以使用SPOOLing技术<strong>把独占设备在逻辑上改造为共享设备</strong>，例如将打印机改造为共享设备，实际上还是仅有一个打印机，但是要输出的内容会先被放入“输出进程”中，然后由输出进程响应了进程的“打印”这一请求，被响应的进程可以不必等待打印事件真正完成就继续执行，而各个进程需要打印的东西会由输出进程交由打印机来进行打印。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404142956.png" alt="image-20210404142734435"></p><p>缺点：并不是所有的资源都可以改造成可以共享使用的资源，并且为了系统安全，狠多地方还必须保护这种互斥性。因此<strong>很多时候都无法破坏互斥条件</strong></p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p><ul><li><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</p></li><li><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p></li><li><p>破坏不剥夺条件策略<strong>缺点</strong>：</p><ol><li>实现比较复杂；</li><li>释放已获得的资源可能造成前一段工作的失效。故而这种方法一般只适用于易保存和恢复状态的资源，如CPU；</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量；</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ol></li></ul><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</p><p>可以<strong>采用静态分配方法</strong>，即<strong>进程在运行前一次申请完它所需要的全部资源</strong>，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>缺点：有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有可能导致某些进程饥饿</p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可以<strong>采用顺序资源分配法</strong>，即首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。</p><p>原理分析：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已经持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。即在任何一个时刻，总有一个进程拥有的资源编号是最大的，那个进程申请之后的资源必然畅通无阻，也就不会出现所有进程都阻塞的死锁现象</p><ul><li>破坏循环等待条件策略<strong>缺点</strong>：<ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能会和编号递增顺序不一致，会导致资源浪费；因为占有资源的顺序是递增，当要先使用编号大的资源后使用编号小的资源时，在使用编号大的资源的过程中，编号小的资源是处于被占用却闲置的状态的，即资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404145804.png" alt="image-20210404145804635"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全序列：如果系统按照这种序列分配资源，则<strong>每个进程都能顺利完成</strong>，只要能找出一个安全序列，系统就是<strong>安全状态</strong>，<strong>安全序列可能有多个</strong></p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。当然，如果有进程<strong>提前归还了一些资源</strong>，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况</p><p>如果系统处于安全状态，<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能</strong>发生死锁(<strong>处于不安全状态未必就是发生了死锁，发生死锁时一定是处于不安全状态</strong>)</p><p><strong>银行家算法</strong>的核心思想：可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求；在进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>把<strong>单维</strong>的数字拓展为<strong>多维</strong>的向量，由专为银行系统设计的算法拓展为可以被用于操作系统中的银行家算法(操作系统中的资源种类极多，不像银行系统只有一种资源——钱)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404153242.png" alt="银行家算法实例"></p><table><thead><tr><th>Process</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td>P0</td><td>(7, 5, 3)</td><td>(0, 1, 0)</td><td>(7, 4, 3)</td><td>(3, 3, 2)</td></tr><tr><td>P1</td><td>(3, 2, 2)</td><td>(2, 0, 0)</td><td>(1, 2, 2)</td><td></td></tr><tr><td>P2</td><td>(9, 0, 2)</td><td>(3, 0, 2)</td><td>(6, 0, 0)</td><td></td></tr><tr><td>P3</td><td>(2, 2, 2)</td><td>(2, 1, 1)</td><td>(0, 1, 1)</td><td></td></tr><tr><td>P4</td><td>(4, 3, 3)</td><td>(0, 0, 2)</td><td>(4, 3, 1)</td><td></td></tr></tbody></table><table><thead><tr><th>Process</th><th>Available</th><th>Need</th><th>Allocation</th><th>Available+Allocation</th><th>Finish</th></tr></thead><tbody><tr><td>P1</td><td>(3, 3, 2)</td><td>(1, 2, 2)</td><td>(2, 0, 0)</td><td>(5, 3, 2)</td><td>true</td></tr><tr><td>P3</td><td>(5, 3, 2)</td><td>(0, 1, 1)</td><td>(2, 1, 1)</td><td>(7, 4, 3)</td><td>true</td></tr><tr><td>P4</td><td>(7, 4, 3)</td><td>(4, 3, 1)</td><td>(0, 0, 2)</td><td>(7, 4, 5)</td><td>true</td></tr><tr><td>P2</td><td>(7, 4, 5)</td><td>(6, 0, 0)</td><td>(3, 0, 2)</td><td>(10, 4, 7)</td><td>true</td></tr><tr><td>P0</td><td>(10, 4, 7)</td><td>(7, 4, 3)</td><td>(0, 1, 0)</td><td>(10, 5, 7)</td><td>true</td></tr></tbody></table><p>即P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0也是一个安全序列(可以有多个安全序列)。</p><ul><li>数据结构：<ul><li>长度为m的一维数组Available表示还有多少可用资源</li><li>n*m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max-Allocation=Need矩阵表示各进程最多还需要多少资源</li></ul></li><li>银行家算法步骤：<ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性检查算法检查此次分配是否会导致系统进入不安全状态</li></ol></li><li>安全性检查算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列</li></ul><h3 id="死锁的检测和接触"><a href="#死锁的检测和接触" class="headerlink" title="死锁的检测和接触"></a>死锁的检测和接触</h3><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。这种情况下，系统应当提供两种算法：①死锁检测算法；②死锁解除算法</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ol><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><ul><li>对系统是否已经发生了死锁进行检测：<ol><li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已经进入死锁状态</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404155056.png" alt="image-20210404155056782"></p><ol><li>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利执行下去</li><li>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待的进程被激活，并顺序地执行下去</li><li>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程</li></ol><p>如果按照上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可以完全简化的</strong>，此时一定<strong>没有发生死锁</strong>，相当于能找到一个安全序列；如果<strong>不能消除所有边</strong>，那么此时就是已经发生了死锁；最终还连着边的那些进程就是处于死锁状态的进程</p><ul><li>求解资源分配图是否可以消除所有边，有两种方法：<ol><li>方案一：按照上述的求解顺序直接对资源分配图进行操作，执行完一个进程之后更新一次资源分配图，能消除所有边则不死锁，不能消除所有边则会死锁</li><li>方案二：对资源分配图进行分析，将其转化为银行家算法的形式，能求一个安全序列则不死锁，不能求出一个安全序列则会死锁</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404162240.png" alt="image-20210404162240022"></p><p>由上述示例(小规模问题)可知方案一十分快捷且直观，而方案二较为繁琐，但是当问题规模很大时，转化为银行家算法再处理会更为方便</p><ul><li>检测死锁的算法：<ol><li>在资源分配图中，找出既不阻塞又不孤点的进程Pi(即找出一条有向边与它相连，且该有向边对应资源的申请数小于等于该系统中已有空闲资源数量。如上述实例中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的结点，如上述示例中，P1是满足此条件的进程结点，于是消去P1的所有边</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。如上述示例中，消去P1之后，P2成为了非阻塞进程，根据1.中方法进行一系列简化之后，若能消除图中的所有边，则称改图是可以<strong>完全简化</strong>的</li></ol></li></ul><p>死锁定理：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，则此时系统<strong>死锁</strong></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。PS：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程才是死锁进程</strong>，即要先将资源分配图化简，再接触死锁</p><ul><li>解除死锁的<strong>主要方法</strong>：<ol><li>资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程，但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会更大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止就功亏一篑了，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ol></li><li>决定“对谁下手”：<ol><li>进程优先级——进程优先级低的</li><li>已经执行了多长时间——执行了时间短的</li><li>还要多久能完成——还需要时间长的</li><li>进程已经使用了多少资源——占用资源多的</li><li>进程是交互式的还是批处理式的——批处理式的</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404164443.png" alt="image-20210404164443163"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统实验-第一章-SQL语言</title>
      <link href="2021/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/"/>
      <url>2021/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p><p>本片文章中使用的是SQL Server配合DataGrip，仅对DataGrip做一些基础使用的介绍，不赘述SQL Server安装过程</p></blockquote><h2 id="配置DataGrip"><a href="#配置DataGrip" class="headerlink" title="配置DataGrip"></a>配置DataGrip</h2><blockquote><p>这里介绍的是如何使用DataGrip连接SQL Server，而且DataGrip是一款付费软件(可以通过学生认证白嫖使用权)，如果使用的是SSMS连接SQL Server，那么可以直接跳过这部分</p></blockquote><h3 id="什么是DataGrip"><a href="#什么是DataGrip" class="headerlink" title="什么是DataGrip"></a>什么是DataGrip</h3><p>DataGrip是JetBrains公司为数据库开发的一款IDE，一开始其相应功能仅是作为大名鼎鼎的IDEA的插件，后来独立成为了一款IDE，理论上来说完全可以通过为IDEA添加插件来实现相应功能，但是我喜欢一款IDE仅做一方面的工作，所以我还是安装了DataGrip，既然是JetBrains公司出品的，那么补全功能就是他们的一贯作风，我是离不开自动补全了，顺别贴一下我使用的软件(红框中的都是JetBrains公司出品的)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331122521.png" alt="image-20210331122521597"></p><p>安装DataGrip有两种方法，一种是下载安装包安装，一种是使用JetBrains ToolBox安装，因为我使用学生认证白嫖了JetBrains全家桶，所以我使用JetBrains ToolBox进行相应的管理，这里不做安装过程的展示。</p><blockquote><p>DataGrip：<a href="https://www.jetbrains.com/datagrip/">https://www.jetbrains.com/datagrip/</a><br>JetBrains ToolBox：<a href="https://www.jetbrains.com/toolbox-app/">https://www.jetbrains.com/toolbox-app/</a></p></blockquote><h3 id="开启SQL-Server的TCP-IP协议"><a href="#开启SQL-Server的TCP-IP协议" class="headerlink" title="开启SQL Server的TCP/IP协议"></a>开启SQL Server的TCP/IP协议</h3><blockquote><p>使用DataGrip连接SQL Server需要其开启TCP/IP功能，因为DataGrip不同于SSMS，并不属于官方工具，需要通过TCP/IP连接</p></blockquote><p>打开SQL Server 2019 配置管理器(如果严格按照老师的要求应该是安装2016)，可以在开始菜单中找到，也可以通过”Win+Q”搜索找到，比如：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331123557.png" alt="image-20210331123557040"></p><p>然后依次点开”SQL Server网络配置”-&gt;”MSSQLSERVER的协议”-&gt;”TCP/IP”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331124748.png" alt="image-20210331124748076"></p><p>然后依次点开”SQL Server服务”-&gt;”SQL Server(MSSQLSERVER)”重启</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331125117.png" alt="image-20210331125117364"></p><h3 id="DataGrip连接SQL-Server"><a href="#DataGrip连接SQL-Server" class="headerlink" title="DataGrip连接SQL Server"></a>DataGrip连接SQL Server</h3><p>依次点击”File”-&gt;”New”-&gt;”Data Source”-&gt;”Microsoft SQL Server”(SQL Server在Data Source中的顺序不一定与我的一致，因为我已经添加过了，开头第一个不是的话往下翻看找找)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331125305.png" alt="image-20210331125305269"></p><p>然后填写信息即可，这里做一下简单的介绍：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331130122.png" alt="image-20210331130121845"></p><p>Test Connection成功示例：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331130154.png" alt="image-20210331130154139"></p><p>DataGrip主窗口，布局介绍大致如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331154813.png" alt="image-20210331154813362"></p><p>很多内容默认是不列出的，比如SQL Server数据库的默认SCHEMA是dbo，但是上述新建的TEST数据库中列出的SCHEMA居然一个也没有，这时候就需要手动使dboSCHEMA可见：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331155144.png" alt="image-20210331155144823"></p><p>这样新建表或者对表进行操作之后，表的信息就可以在左侧看到了。</p><h2 id="实验1-1——数据定义"><a href="#实验1-1——数据定义" class="headerlink" title="实验1.1——数据定义"></a>实验1.1——数据定义</h2><blockquote><p>实验目的：熟悉SQL的数据定义语言，能够熟练地使用SQL语句来创建和更改基本表，创建和取消索引</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>使用CREATE语句创建基本表</li><li>更改基本表的定义，增加列，删除列，修改列的数据类型</li><li>创建表的升降序索引</li><li>取消表、表的索引或表的约束</li></ul><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)使用SQL语句创建关系数据库表：人员表PERSON(P#, Pname, Page, Pgender)，房间表ROOM(R#, Rname, Rarea)，表P-R(P#, R#, Date)。其中P#是表PERSON的主键，具有唯一性约束，Page具有约束：大于18；R#是表ROOM的主键，具有唯一性约束；表P-R中的P#，R#是外键。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">(</span><br><span class="line">    P#    <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Pname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Page  <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (P#),</span><br><span class="line">    <span class="keyword">CHECK</span> (Page <span class="operator">&gt;</span> <span class="number">18</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">(</span><br><span class="line">    R#    <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Rname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Rarea <span class="type">FLOAT</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (R#)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PR</span><br><span class="line">(</span><br><span class="line">    P#   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    R#   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="type">Date</span> DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (P#, R#),</span><br><span class="line"><span class="comment">--     FOREIGN KEY (P#) REFERENCES PERSON ON DELETE CASCADE,</span></span><br><span class="line"><span class="comment">--     FOREIGN KEY (R#) REFERENCES ROOM ON DELETE CASCADE</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (P#) <span class="keyword">REFERENCES</span> PERSON,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (R#) <span class="keyword">REFERENCES</span> ROOM</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331161736.png" alt="image-20210331161736235"></p><p>(2)更改表PERSON，增加属性Rtype(类型是CHAR，长度为10)，取消Page大于18的约束。把表ROOM中的属性Rname的数据类型改为长度是30。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">    <span class="keyword">ADD</span> Ptype <span class="type">CHAR</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> CK__PERSON__Page__25869641;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Rname <span class="type">CHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331161948.png" alt="image-20210331161948051"></p><p>(3)删除表ROOM的一个属性Rarea。<br>(4)取消表PR。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> Rarea;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> PR;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162029.png" alt="image-20210331162029687"></p><p>(5)为ROOM表创建按R#降序排列的索引。<br>(6)为PERSON表创建按P#升序排列的索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ROOMINDEX <span class="keyword">ON</span> ROOM (R# <span class="keyword">DESC</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX PERSONINDEX <span class="keyword">ON</span> PERSON (P# <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162131.png" alt="image-20210331162131025"></p><p>(7)创建表PERSON的按Pname升序排列的唯一性索引。<br>(8)取消PERSON表P#升序索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX PERSONUNIQUE <span class="keyword">ON</span> PERSON (Pname <span class="keyword">ASC</span>);</span><br><span class="line"><span class="keyword">DROP</span> INDEX PERSON.PERSONINDEX;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162235.png" alt="image-20210331162235807"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)创建数据库表CUSTOMSERS(CID, CNAME, CITY, DISCNT)，数据库表AGENTS(AID, ANAME, CITY, PERCENT)，数据库表PRODUCTS(PID, PNAME)。其中CID，AID，PID分别是各表的主键，具有唯一性约束。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> CUSTOMSERS</span><br><span class="line">(</span><br><span class="line">    CID    <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    CNAME  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    CITY   <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    DISCNT <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (CID)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> AGENTS</span><br><span class="line">(</span><br><span class="line">    AID       <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    ANAME     <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    CITY      <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    [<span class="keyword">PERCENT</span>] <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (AID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">(</span><br><span class="line">    PID   <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    PNAME <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (PID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170201.png" alt="image-20210331170201880"></p><p>(2)创建数据库表ORDERS(ORDNA, MONTH, CID, AID, PID, QTY, DOLLARS)。其中ORDNA是主键，具有唯一性约束；CID，AID，PID是外键，分别参照的是表CUSTOMSERS的CID字段，表AGENTS的AID字段，PRODUCTS的PID字段。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ORDERS</span><br><span class="line">(</span><br><span class="line">    ORDNA   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="keyword">MONTH</span>   <span class="type">INT</span>,</span><br><span class="line">    CID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    AID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    PID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    QTY     <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    DOLLARS MONEY,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (ORDNA),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (CID) <span class="keyword">REFERENCES</span> CUSTOMSERS (CID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (AID) <span class="keyword">REFERENCES</span> AGENTS (AID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (PID) <span class="keyword">REFERENCES</span> PRODUCTS (PID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170241.png" alt="image-20210331170241663"></p><p>(3)增加数据库表PRODUCTS的三个属性列：CITY，QUANTITY，PRICE。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> CITY <span class="type">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> QUANTITY <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> PRICE MONEY;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170327.png" alt="image-20210331170327361"></p><p>(4)为以上四个表建立各自的按主键增序排列的索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX CUSINDEX <span class="keyword">ON</span> CUSTOMSERS (CID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX AGENTSINDEX <span class="keyword">ON</span> AGENTS (AID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX PROINDEX <span class="keyword">ON</span> PRODUCTS (PID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX ORDERSINDEX <span class="keyword">ON</span> ORDERS (ORDNA);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170414.png" alt="image-20210331170413980"></p><p>(5)取消步骤(4)建立的四个索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX CUSTOMSERS.CUSINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX AGENTS.AGENTSINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX PRODUCTS.PROINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX ORDERS.ORDERSINDEX;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170535.png" alt="image-20210331170535101"></p><h2 id="实验1-2——数据查询"><a href="#实验1-2——数据查询" class="headerlink" title="实验1.2——数据查询"></a>实验1.2——数据查询</h2><blockquote><p>实验目的：熟悉SQL语句的数据查询语言，能够使用SQL语句对数据库进行单表查询、连接查询、嵌套查询、集合查询和统计查询。通过实验理解在数据库表中的对数据的NULL值的处理。</p></blockquote><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>虽然直接写出SELECT语句也可以，但是为了直观的看出自己写的对不对，还是要先导入School数据库，一般情况下导入数据库时遇到的最多的问题就是“访问权限”问题，修改一下权限即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331172611.png" alt="image-20210331172611053"></p><p>在DataGrip的console或者SSMS的查询中执行如下语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_attach_db <span class="variable">@dbname</span> <span class="operator">=</span> <span class="string">&#x27;School&#x27;</span>,</span><br><span class="line">     <span class="variable">@filename1</span> <span class="operator">=</span> N<span class="string">&#x27;D:\Study\2021-Spring\数据库系统\Experiment\实验数据库\School_Data.MDF&#x27;</span>,</span><br><span class="line">     <span class="variable">@filename2</span> <span class="operator">=</span> N<span class="string">&#x27;D:\Study\2021-Spring\数据库系统\Experiment\实验数据库\School_Log.LDF&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>其中：<ul><li>dbname即数据库名称，可以自己改</li><li>filename1和filename2分别是mdf和ldf文件的路径，替换为自己的路径即可</li></ul></li></ul><p>如果使用的是DataGrip，可能还需要使导入的数据库可见，参照前面的”配置DataGrip”中的介绍即可。</p><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><p>本节内容主要是对数据库进行查询操作，包括如下4类查询方式：</p><ol><li>单表查询<ul><li>查询的目标表达式为所有列、指定列或指定列的运算</li><li>使用DISTINCT保留字消除重复行</li><li>对查询结果排序和分组</li><li>集合分组使用集函数进行各项统计</li></ul></li><li>连接查询<ul><li>笛卡尔连接和等值连接</li><li>自连接</li><li>外连接</li><li>复合条件连接</li><li>多表连接</li></ul></li><li>嵌套查询<ul><li>通过实验验证对子查询的两个限制条件</li><li>体会相关子查询和不相关子查询的不同</li><li>考察4类谓词的用法，包括：<ul><li>第1类：IN，NOT IN</li><li>第2类：带有比较运算符的子查询</li><li>第3类：SOME, ANY或ALL谓词的子查询</li><li>第4类：带有EXISTS谓词的子查询</li></ul></li></ul></li><li>集合运算<ul><li>使用保留字UNION进行集合或运算</li><li>采用逻辑运算符AND或OR来实现集合交和减运算</li></ul></li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>以School数据库为例，在该数据库中存在4张表格，分别为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STUDENTS(sid, sname, email, grade)</span><br><span class="line">TEACHERS(tid, tname, email, salary)</span><br><span class="line">COURSES(cid, cname, <span class="keyword">hour</span>)</span><br><span class="line">CHOICES(<span class="keyword">no</span>, sid, tid, cid, score)</span><br></pre></td></tr></table></figure><p>在数据库中，存在这样的关系：学生可以选择课程。一个课程对应一个教师。在表CHOICES中保存学生的选课记录</p><p>(1)查询年级为2001的所有学生的名称，按编号升序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="number">2001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p>(2)查询学生的选课成绩合格的课程成绩，并把成绩换算为绩点(60分对应绩点为1，每增加1，绩点增加1)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score <span class="operator">-</span> <span class="number">60</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="comment">-- SELECT score - 59</span></span><br><span class="line"><span class="comment">-- FROM CHOICES</span></span><br><span class="line"><span class="comment">-- WHERE score &gt;= 60;</span></span><br></pre></td></tr></table></figure><p>(3)查询课时是48或64的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="keyword">IN</span> (<span class="number">48</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>(4)查询所有课程名称中含有data的课程编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="keyword">LIKE</span> <span class="string">&#x27;%data%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5)查询所有选课记录的课程号(不重复显示)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p>(6)统计所有老师的平均工资</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p>(7)查询所有学生的编号、姓名和平均成绩，按总平均成绩降序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, sname, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENTS.sid, sname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(score) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>(8)统计各个课程的选课人数和平均成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> sid) <span class="string">&#x27;COUNT-PEOPLE&#x27;</span>, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br></pre></td></tr></table></figure><p>(9)查询至少选修了三门课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid) <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>(10)查询编号为800009026的学生所选的全部课程的课程名和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname, score</span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.sid <span class="operator">=</span> <span class="string">&#x27;800009026&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(11)查询所有选了database的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;database&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid;</span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;database&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(12)求出选择了同一个课程的学生对</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid, SECOND.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">!=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> SECOND.cid;</span><br></pre></td></tr></table></figure><p>(13)求出至少被两名学生选修的课程编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> sid) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>(14)查询选修了编号为80009026的学生所选的某个课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800009026&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(15)查询学生的基本信息及选修课程编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.<span class="operator">*</span>, CHOICES.cid, CHOICES.score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> STUDENTS.sid, CHOICES.score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>(16)查询学号850955252的学生的姓名和选修的课程名称及成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, cname, score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> <span class="string">&#x27;850955252&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid;</span><br></pre></td></tr></table></figure><p>(17)查询学号850955252的学生同年级的所有学生资料</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;850955252&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(18)查询所有的有选课的学生的详细信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> STUDENTS.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(19)查询没有学生选的课程的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(20)查询选修了课程名为C++的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> cid</span><br><span class="line">        <span class="keyword">FROM</span> COURSES</span><br><span class="line">        <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;c++&#x27;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid;</span><br></pre></td></tr></table></figure><p>(21)找出选修课程成绩最差的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> score</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score)</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(22)找出和课程UML或课程C++的课时一样的课程名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span></span><br><span class="line">       <span class="keyword">OR</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> FIRST.cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES <span class="keyword">FIRST</span>,</span><br><span class="line">     COURSES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> (SECOND.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span> <span class="keyword">OR</span> SECOND.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> FIRST.hour <span class="operator">=</span> SECOND.hour;</span><br></pre></td></tr></table></figure><p>(23)查询所有选修编号10001的课程的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(24)查询选修了所有课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> COURSES</span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> CHOICES</span><br><span class="line">                <span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">                  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>(25)利用集合运算，查询选修课程C++或课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合运算——UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> (COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span> <span class="keyword">OR</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(26)实现集合加运算，查询既选修课程C++又选修课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合加运算——INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合加运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">AND</span> SECOND.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(27)实现集合减运算，查询选修课程C++而没有选修课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合减运算——EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">    <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合减运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">AND</span> SECOND.sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)查询全部课程的详细记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(2)查询所有有选修课的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p>(3)查询课时&lt;88小时的课程的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">88</span>;</span><br></pre></td></tr></table></figure><p>(4)请找出总分超过400分的学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(score) <span class="operator">&gt;</span> <span class="number">400</span>;</span><br></pre></td></tr></table></figure><p>(5)查询课程的总数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(6)查询所有课程和选修该课程的学生总数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COURSES.<span class="operator">*</span>, <span class="built_in">COUNT</span>(sid) <span class="string">&#x27;COUNT-SID&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> COURSES.cid, cname, <span class="keyword">hour</span>;</span><br></pre></td></tr></table></figure><p>(7)查询选修成绩合格的课程超过两门的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(cid) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>(8)统计各个学生的选修课程数目和平均成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, <span class="built_in">COUNT</span>(cid) <span class="string">&#x27;COUNT-CID&#x27;</span>, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CHOICES.sid;</span><br></pre></td></tr></table></figure><p>(9)查询选修Java的所有学生的编号及姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES,</span><br><span class="line">     STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(10)分别使用等值连接和谓词IN两种方式查询姓名为sssht的学生所选的课程的编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">  <span class="keyword">AND</span> sname <span class="operator">=</span> <span class="string">&#x27;sssht&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;sssht&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(11)查询其他课时比课程C++多的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(12)查询选修C++课程的成绩比姓名为znkoo的学生高的所有学生的编号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> CHOICES.score <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> score</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">         CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> STUDENTS.sname <span class="operator">=</span> <span class="string">&#x27;znkoo&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">      <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(13)找出和学生883794999或学生8509555252的年级一样的学生的姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;883794999&#x27;</span></span><br><span class="line">       <span class="keyword">OR</span> sid <span class="operator">=</span> <span class="string">&#x27;8509555252&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(14)查询没有选修Java的学生名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(15)找出课时最少的课程的详细信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(<span class="keyword">hour</span>)</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(16)查询工资最高的教师的编号和开设的课程号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CHOICES.tid, CHOICES.cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     TEACHERS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.tid <span class="operator">=</span> TEACHERS.tid</span><br><span class="line">  <span class="keyword">AND</span> TEACHERS.salary <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> TEACHERS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(17)找出选修课程ERP成绩最高的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;ERP&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score)</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;ERP&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(18)查询没有学生选修的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(19)找出讲授课程UML的教师讲授的所有课程名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> tid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> tid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(20)查询选修了编号200102901的教师开设的所有课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES X</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> CHOICES Y</span><br><span class="line">        <span class="keyword">WHERE</span> Y.tid <span class="operator">=</span> <span class="string">&#x27;200102901&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> CHOICES Z</span><br><span class="line">                <span class="keyword">WHERE</span> Z.sid <span class="operator">=</span> X.sid</span><br><span class="line">                  <span class="keyword">AND</span> Z.cid <span class="operator">=</span> Y.cid</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>(21)查询选修课程Database的学生集合与选修课程UML的学生集合的并集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(22)实现集合交运算，查询既选修课程Database又选修课程UML的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(23)实现集合减运算，查询选修课程Database而没有选修课程UML的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line">    <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="实验1-3——数据更新"><a href="#实验1-3——数据更新" class="headerlink" title="实验1.3——数据更新"></a>实验1.3——数据更新</h2><blockquote><p>实验目的：熟悉数据库的数据更新操作，能够使用SQL语句对数据库进程数据的插入、更新、删除操作</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><p>本次实验中，主要内容是如何使用SQL语句对数据进行更新：</p><ul><li>使用INSERT INTO语句插入数据，包括插入一个元组或将子查询的结果插入到数据库中两种方式</li><li>使用SELECT INTO语句，产生一个新表并插入数据</li><li>使用UPDATE语句可以修改指定表中满足WHERE子句条件的元组，有三种修改的方式：修改一个元组，修改多个元组的值，带子查询的修改语句</li><li>使用DELETE语句删除数据：删除某一个元组的值，删除多个元组的值，带子查询的删除语句</li></ul><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School;</span><br></pre></td></tr></table></figure><p>(1)使用SQL语句向STUDENTS表中插入元组<br>– (编号：700045678；名字：LiMing；EMAIL：<a href="mailto:&#76;&#88;&#x40;&#99;&#x64;&#x65;&#109;&#103;&#x2e;&#x63;&#x6f;&#x6d;">&#76;&#88;&#x40;&#99;&#x64;&#x65;&#109;&#103;&#x2e;&#x63;&#x6f;&#x6d;</a>；年级：1992</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> STUDENTS(SID, SNAME, EMAIL, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;700045678&#x27;</span>, <span class="string">&#x27;LiMing&#x27;</span>, <span class="string">&#x27;LX@cdemg.com&#x27;</span>, <span class="number">1992</span>);</span><br><span class="line"><span class="comment">-- 查询插入前和插入后的区别</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;700045678&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405094124.png" alt="image-20210405094123962"></p><p>(2)对每个课程，求学生的选课人数和学生的平均成绩，并把结果存入数据库。<br>– 使用SELECT INTO和INSERT INTO两种方法实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一步，建表——COURSEINFO_INSERT</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COURSEINFO_INSERT</span><br><span class="line">(</span><br><span class="line">    Cid       <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Students  <span class="type">INT</span>,</span><br><span class="line">    Avg_score <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 第二步，使用INSERT INTO的方式</span></span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> COURSEINFO_INSERT(CID, STUDENTS, AVG_SCORE)</span><br><span class="line"><span class="keyword">SELECT</span> cid, <span class="built_in">COUNT</span>(sid), <span class="built_in">AVG</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br><span class="line"><span class="comment">-- 查询插入结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSEINFO_INSERT;</span><br><span class="line"><span class="comment">-- 使用SELECT INTO的方式</span></span><br><span class="line"><span class="keyword">SELECT</span> cid        <span class="keyword">AS</span> Cid,</span><br><span class="line">       <span class="built_in">COUNT</span>(sid) <span class="keyword">AS</span> Students,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">INTO</span> COURSEINFO_SELECT</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br><span class="line"><span class="comment">-- 查询插入结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSEINFO_SELECT;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405100406.png" alt="image-20210405100405951"></p><p>(3)在STUDENTS表中使用SQL语句将姓名为”LiMing”的学生的年级改为”2002”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> STUDENTS</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">2002</span></span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405100739.png" alt="image-20210405100739228"></p><p>(4)在TEACHERS表中使用SQL语句将所有教师的工资多加500元</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span>salary <span class="operator">+</span> <span class="number">500</span>;</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405101503.png" alt="image-20210405101503520"></p><p>(5)将姓名为zapyv的学生的课程”C”的成绩加上5分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CHOICES</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> STUDENTS <span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;zapyv&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> cid <span class="operator">=</span> (<span class="keyword">SELECT</span> Cid <span class="keyword">FROM</span> COURSES <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, sname, COURSES.Cid, cname, score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> sname <span class="operator">=</span> <span class="string">&#x27;zapyv&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102339.png" alt="image-20210405102339558"></p><p>(6)在STUDENTS表中使用SQL语句删除姓名为”LiMing”的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102512.png" alt="image-20210405102512765"></p><p>(7)删除所有选修课程”Java”的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> (<span class="keyword">SELECT</span> cid</span><br><span class="line">             <span class="keyword">FROM</span> COURSES</span><br><span class="line">             <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.<span class="operator">*</span>, cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102943.png" alt="image-20210405102943220"></p><p>(8)对COURSES表做删去时间&lt;48的元组的操作，并讨论该删除操作所受到的约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">48</span>;</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">48</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2021-04-05 10:31:39] [23000][547] DELETE 语句与 REFERENCE 约束&quot;FK_CHOICES_COURSES&quot;冲突。该冲突发生于数据库&quot;School&quot;，表&quot;dbo.CHOICES&quot;, column &#39;cid&#39;。</span><br></pre></td></tr></table></figure><p>因为COURSES中的cid在CHOICES表中作为外键存在，所以与约束冲突，删除失败</p><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)向STUDENTS表中插入编号是’800022222’且姓名是”WangLan”的元组</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> STUDENTS(sid, sname)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;800022222&#x27;</span>, <span class="string">&#x27;WangLan&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(2)向TEACHERS表插入元组(‘200001000’, ‘LXL’, ‘s4zrck@pew.net’, ‘3024’)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> TEACHERS(TID, TNAME, EMAIL, SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;200001000&#x27;</span>, <span class="string">&#x27;LXL&#x27;</span>, <span class="string">&#x27;s4zrck@pew.net&#x27;</span>, <span class="string">&#x27;3024&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(3)将TEACHERS表中编号为’200010493’的老师的工资改为4000</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span><span class="number">4000</span></span><br><span class="line"><span class="keyword">WHERE</span> tid <span class="operator">=</span> <span class="string">&#x27;200010493&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(4)将TEACHERS表中所有工资小于2500的老师工资改为2500</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span><span class="number">2500</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">2500</span>;</span><br></pre></td></tr></table></figure><p>(5)将由编号为’200016731’的老师所授的课程全部改为由姓名为’rnupx’的老师讲授</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CHOICES</span><br><span class="line"><span class="keyword">SET</span> tid<span class="operator">=</span>(<span class="keyword">SELECT</span> tid <span class="keyword">FROM</span> TEACHERS <span class="keyword">WHERE</span> tname <span class="operator">=</span> <span class="string">&#x27;rnupx&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> tid <span class="operator">=</span> <span class="string">&#x27;200016731&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(6)更新编号为’800071780’的学生年级为2001</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> STUDENTS</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">2001</span></span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800071780&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(7)删除没有学生选修的课程</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(8)删除年级高于1998的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="number">1998</span>;</span><br></pre></td></tr></table></figure><p>(9)删除没有选修课程的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(10)删除成绩不及格的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="实验1-4——视图"><a href="#实验1-4——视图" class="headerlink" title="实验1.4——视图"></a>实验1.4——视图</h2><blockquote><p>实验目的：熟悉SQL语言支持的有关视图的操作，能够熟练使用SQL语句来创建需要的视图，对视图进行查询和取消视图</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>定义常见的视图形式，包括：<ul><li>行列子集视图</li><li>WITH CHECK OPTION视图</li><li>基于多个基表的视图</li><li>基于视图的视图</li><li>带表达式的视图</li><li>分组视图</li></ul></li><li>通过实验考察WITH CHECK OPTION这一语句在视图定义后产生的影响，包括对修改操作、删除操作、插入操作的影响</li><li>讨论视图的数据更新情况，对子行列视图进行数据更新</li><li>使用DROP语句删除一个视图，由该视图导出的其他视图定义仍在数据字典中，但已不能使用，必须显式删除。同样的原因，删除基表时，由该基表导出的所有视图定义都必须显式删除</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)创建一个行列子集视图，给出选课成绩合格的学生的编号，所选课程号和该课程成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Qualified</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083446.png" alt="image-20210414083445992"></p><p>(2)创建基于多个基表的视图，这个视图由学生姓名和其所选修的课程名及讲授该课程的教师姓名构成</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SCT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, cname, tname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     TEACHERS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> TEACHERS.tid <span class="operator">=</span> CHOICES.tid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083327.png" alt="image-20210414083327445"></p><p>(3)创建带表达式的视图，由学生姓名、所选课程名和所有课程成绩都比原来多5分这几个属性组成</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ExpressionVIEW</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, cname, score <span class="operator">+</span> <span class="number">5</span> <span class="keyword">AS</span> SCORE</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083748.png" alt="image-20210414083748742"></p><p>(4)创建分组视图，将学生的学号及其平均成绩定义为一个视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> GroupingVIEW</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083843.png" alt="image-20210414083842937"></p><p>(5)创建一个基于视图的视图，基于(1)中建立的视图，定义一个包含学生编号，学生所选课数目和平均成绩的视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BASEDONVIWE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid,</span><br><span class="line">       <span class="built_in">COUNT</span>(cid) <span class="keyword">AS</span> Count_cid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">FROM</span> Qualified</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083950.png" alt="image-20210414083950141"></p><p>(6)查询所有选修课程Software Engineering的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> SCT</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;Software Engineering&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084014.png" alt="image-20210414084014100"></p><p>(7)插入元组(600000000, 823069829, 10010, 59)到视图CS中<br>– 若是在视图的定义中存在WITH CHECK OPTION子句对插入操作有什么影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, sid, cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> CS(<span class="keyword">NO</span>, SID, CID, SCORE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;600000000&#x27;</span>, <span class="string">&#x27;823069829&#x27;</span>, <span class="string">&#x27;10010&#x27;</span>, <span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>含有WITH CHECK OPTION会进行检查，由于待插入元组的Score为59不及格，故插入失败</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414090019.png" alt="image-20210414084124700"></p><p>(8)将视图CS(包含WITH CHECK OPTION)中，所有课程编号为10010的课程的成绩都减去5分。<br>– 这个操作数据库是否会正确执行，为什么？<br>– 如果加上5分(原来95分以上的不变)呢？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">-</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>减去5分的操作不会正确执行，因为CS具有WITH CHECK OPTION检查，部分元组减去5分后会检查出错，不再及格</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;=</span> <span class="number">95</span>;</span><br></pre></td></tr></table></figure><p>增加5分可以正确执行，因为增加5分这项操作不会触碰WITH CHECK OPTION的检查</p><p>(9)在视图CS(包含WITH CHECK OPTION)中，删除编号为804529880学生的记录，会产生什么结果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;804529880&#x27;</span>;</span><br><span class="line"><span class="comment">-- 由于视图不保存数据内容，而是保存类似于“索引”的东西，所以删除操作是作用在原本的CHOICES表中，即在CHOICES表中，学号为804529880的学生的选课记录均会被删除</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;804529880&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(10)取消视图SCT和视图CS</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> SCT;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> CS;</span><br><span class="line"><span class="comment">-- 自己定义的第(1)中的名字是Qualified(及格)，相当于CS，而BASEDONVIEW视图基于此视图，需要显式删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> Qualified;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BASEDONVIWE;</span><br><span class="line"><span class="comment">-- 顺便删除其他的视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> ExpressionVIEW;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> GroupingVIEW;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084215.png" alt="image-20210414084215852"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)定义选课信息和课程名称的视图VIEWC</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VIEWC</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.<span class="operator">*</span>, cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid;</span><br></pre></td></tr></table></figure><p>(2)定义学生姓名和选课信息的视图VIEWS</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不知道为啥，VIEWS报错，需要加[VIEWS]</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> [VIEWS]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, CHOICES.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid;</span><br></pre></td></tr></table></figure><p>(3)定义年级低于1998的学生的视图S1(SID, SNANE, GRADE)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, sname, grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;</span> <span class="number">1998</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>(4)查询姓名为”uxjof”的学生的选课信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> [VIEWS]</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5)查询选修课程”UML”的学生的编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> VIEWC</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(6)向视图S1插入记录(‘60000001’, ‘Lily’, 2001)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;60000001&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="number">2001</span>);</span><br></pre></td></tr></table></figure><p>(7)定义包括更新和插入约束的视图S1，尝试向视图插入记录(‘60000001’, ‘Lily’, 1997)<br>– 删除所有年级为1999的学生记录，讨论更新和插入约束带来的影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;60000001&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="number">1997</span>);</span><br><span class="line"><span class="comment">-- 因为已经在(6)中插入过学号为&#x27;60000001&#x27;的信息，由于UNIQUE约束，无法插入</span></span><br><span class="line"><span class="comment">-- 去除原本的学号为&#x27;60000001&#x27;的元组信息后，由于WITH CHECK OPTION约束，1997年级比1998高，无法插入</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> S1</span><br><span class="line"><span class="keyword">WHERE</span> GRADE <span class="operator">=</span> <span class="number">1999</span>;</span><br><span class="line"><span class="comment">-- 删除失败，且由于视图的性质，删除操作针对的是原表STUDENTS，而STUDENTS中sid是表CHOICES的外键，发生REFERENCE冲突</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="number">1999</span>;</span><br></pre></td></tr></table></figure><p>(8)在视图VIEWS中将姓名为’uxjof’的学生的选课成绩都加上5分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [VIEWS]</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> [VIEWS]</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(9)取消以上建立的所有视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [VIEWS];</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> VIEWC;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> S1;</span><br></pre></td></tr></table></figure><h2 id="实验1-5——数据控制"><a href="#实验1-5——数据控制" class="headerlink" title="实验1.5——数据控制"></a>实验1.5——数据控制</h2><blockquote><p>实验目的：熟悉SQL的数据控制功能，能够使用SQL语句来向用户授予和回收权限</p></blockquote><h3 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>使用GRANT语句对用户授权，对单个用户和多个用户授权，或使用保留字PUBLIC对所有用户授权。对不同的操作对象包括数据库、视图、基本表等进行不同权限的授权</li><li>使用WITH GRANT OPTION子句授予用户传播该权限的权利</li><li>在授权时发生循环授权，考察DBS能否发现这个错误。如果不能，结合取消权限操作，查看DBS对循环授权的控制</li><li>使用REVOKE子句收回授权，取消授权的级联反应</li></ol><h3 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>在数据库school中建立三个用户USER1，USER2和USER3，它们在数据库中的角色是PUBLIC。按以下要求，分别以管理员身份或这三个用户的身份登录到数据库中，进行操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER1 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER2 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER3 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="comment">-- 一些基础语句：</span></span><br><span class="line"><span class="comment">-- 1.查看所有用户</span></span><br><span class="line"><span class="keyword">exec</span> sp_helpuser;</span><br><span class="line"><span class="comment">-- 2.切换到指定用户</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.切换回数据库管理员-REVERT-好像是撤销指令</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="comment">-- 4.查看当前用户名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">SELECT</span> SUSER_NAME();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084430.png" alt="image-20210414084429943"></p><p>(1)授予所有用户对表COURSES的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(2)授予USER1对表STUDENTS插入和更新的权限，但不授予删除权限，并且授予USER1传播这两个权限的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(3)允许USER2在表CHOICES中插入元组，更新SCORE列，可以选取除了SID以外的所有列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>, <span class="comment">/* 在CHOICES中插入元组 */</span></span><br><span class="line">    <span class="keyword">UPDATE</span> (score) <span class="comment">/* 在CHOICES中更新SCORE列 */</span></span><br><span class="line">    <span class="keyword">ON</span> CHOICES</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br><span class="line"><span class="comment">-- 创建视图，此视图仅没有sid</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CHOICE_NO_SID(<span class="keyword">no</span>, cid, tid, score)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, cid, tid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="comment">/* 对USER2授予查询上述新建的视图的权限 */</span></span><br><span class="line">    <span class="keyword">ON</span> CHOICE_NO_SID</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085128.png" alt="image-20210414085128273"></p><p>(4)USER1授予USER2对表STUDENTS插入和更新的权限，并且授予USER2传播插入操作的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>; <span class="comment">/* 切换为USER1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* 对USER2授予更新STUDENTS的权限，不可传播 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="comment">/* 对USER2授予插入STUDENTS的权限，可传播 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(5)收回USER1对表COURSES查询的授权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">FROM</span> USER1;</span><br></pre></td></tr></table></figure><p>(6)由上面(2)和(4)的授权，再由USER2对USER3授予表STUDENTS插入和更新的权限，并且授予USER3传播插入操作的权利。<br>– 这时候，如果由USER3对USER1授予表STUDENTS的插入和更新权限是否能够成功？<br>– 如果能够成功，那么如果由USER2取消对USER3的授权，对USER1会有什么影响？<br>– 如果再由DBA取消USER1的权限，对USER2有什么影响？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* USER2不具有更新SUTDENTS的权限，授权失败 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER3;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="comment">/* USER3给USER1授予STUDENTS的插入权限成功 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER3</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这时候，如果由USER3对USER1授予表STUDENTS的插入和更新权限是否能够成功？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER3&#x27;</span>; <span class="comment">/* 切换为USER3 */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* USER3不具有更新SUTDENTS的权限 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果能够成功，那么如果由USER2取消对USER3的授权，对USER1会有什么影响？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="comment">/* 取消对USER3的授权 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER3 CASCADE;</span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>; <span class="comment">/* 切换为USER1 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (SID, SNAME, EMAIL, GRADE) <span class="comment">/* 测试INSERT */</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;TEST-USER1&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="number">2021</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;TEST-USER1&#x27;</span>; <span class="comment">/* 插入成功，并不会影响USER1 */</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085700.png" alt="image-20210414085700166"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果再由DBA取消USER1的权限，对USER2有什么影响？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> , <span class="keyword">UPDATE</span> <span class="comment">/* 取消对USER1的授权 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (SID, SNAME, EMAIL, GRADE) <span class="comment">/* 测试INSERT */</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;TEST-USER2&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="number">2021</span>);</span><br><span class="line"><span class="comment">-- USER2也不再具有对STUDENTS的插入权限</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085806.png" alt="image-20210414085806673"></p><h3 id="自我实践-4"><a href="#自我实践-4" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)授予所有用户对表STUDENTS的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(2)授予所有用户对表COURSES的查询和更新权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(3)授予USER1对表TEACHERS的查询，更新工资的权限，且允许USER1可以传播这些权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> (salary)</span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER1</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(4)授予USER2对表CHOICES的查询，更新成绩的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> (score)</span><br><span class="line">    <span class="keyword">ON</span> CHOICES</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p>(5)授予USER2对表TEACHERS的除了工资以外的所有信息的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> TEACHERS_NO_SALARY(TID, TNAME, EMAIL)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> tid, tname, email</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS_NO_SALARY</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p>(6)由USER1授予USER2对表TEACHERS的查询权限和传播此项权限的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(7)由USER2授予USER3对表TEACHERS的查询权限和传播此项权限的权利。<br>– 再由USER3授予USER2上述权限，这样的SQL语句能否成功得到执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER3</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="comment">-- 再由USER3授予USER2上述权限，可以执行</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER3&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(8)取消USER1对表STUDENTS的查询权限，考虑由USER2的身份对表STUDENTS进行查询，操作能否成功？为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 操作可以成功，因为对表STUDENTS的查询权限是授予所有用户的，用户之间此权限无相关性</span></span><br></pre></td></tr></table></figure><p>题目应该改为——取消USER1对表TEACHERS的查询权限，考虑由USER2的身份对表TEACHERS进行查询，操作能否成功？为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br><span class="line"><span class="comment">-- 此时操作不成功，因为权限被级联删除，USER2的对TEACHERS表的查询权限是由USER1授予的，回收USER1的权限的时候，USER2的权限被自动回收</span></span><br></pre></td></tr></table></figure><p>(9)取消USER1和USER2的关于COURSES的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES</span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">FROM</span> USER1, USER2;</span><br></pre></td></tr></table></figure><h2 id="实验1-6——空值和空集的处理"><a href="#实验1-6——空值和空集的处理" class="headerlink" title="实验1.6——空值和空集的处理"></a>实验1.6——空值和空集的处理</h2><blockquote><p>实验目的：认识NULL值在数据库中的特殊含义，了解空值和空集对于数据库的数据查询操作，特别是空值在条件表达式中与其他的算术运算符或者逻辑运算符的运算中，空集作为嵌套查询的子查询的返回结果时候的特殊性，能够熟练使用SQL语句来进行与空值、空集相关的操作</p></blockquote><h3 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h3><p>通过实验验证在SQL Server对NULL的处理，包括：</p><ol><li>再查询的目标表达式中包含空值的运算</li><li>在查询条件中控制与比较运算符的运算结果</li><li>使用”IS NULL”和”IS NOT NULL”来判断元组该列是否为空值</li><li>对存在取空值的列按值进行ORDER BY排序</li><li>使用保留字DISTINCT对空值的处理，区分数据库的多种取值与现实中的多种取值的不同</li><li>使用GROUP BY对存在取空值的属性值进行分组</li><li>结合分组考察控制对各个集合函数的影响，特别注意对COUNT(*)和COUNT(列名)的不同影响</li><li>考察结果集市空集时，各个集函数的处理情况</li><li>验证嵌套查询中返回空集的情况下与各个谓词的运算结果</li><li>进行与空值有关的等值连接运算</li></ol><h3 id="实验步骤-5"><a href="#实验步骤-5" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)查询所有选课记录的成绩并将其转换为五分制(满分为5分，合格为3分)，注意SCORE取NULL的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score, score <span class="operator">/</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093054.png" alt="image-20210414093054312"></p><p>(2)查询选修编号为10028的课程的学生的人数，其中成绩合格的的学生人数，不合格的学生人数，讨论NULL值的特殊含义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(sid)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">-- 选修了课程号为10028的学生总人数6042</span></span><br><span class="line"><span class="comment">-- 其中及格的人数为4812</span></span><br><span class="line"><span class="comment">-- 其中不及格的人数为755</span></span><br><span class="line"><span class="comment">-- 其中成绩为NULL的人数为475</span></span><br><span class="line"><span class="comment">-- 如果将成绩为NULL视为不及格，则查询语句应如下：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(sid)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> (score <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line">    <span class="keyword">OR</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- 在CHOICES的定义中，score是可以取空值的，NULL&gt;=60和NULL&lt;60都不是TRUE</span></span><br></pre></td></tr></table></figure><p>(3)通过实验检验在使用ORDER BY进行排序时，取NULL的项是否出现在结果中？如果有，在什么位置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 实际测试中，取值为NULL的项会出现在结果中，升序(ASC)排序时在开头，降序(DESC)排序时在末尾</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093118.png" alt="image-20210414093118323"></p><p>(4)在上面的查询的过程中如果加上保留字DISTINCT会有什么效果呢</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 使用DISTINCT时，若查询项仅有一项，那么所有的NULL会被视为相同的值</span></span><br><span class="line"><span class="comment">-- 比如SELECT score时会罗列所有的NULL，而SELECT DISTINCT score仅罗列一个NULL</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093152.png" alt="image-20210414093152686"></p><p>(5)通过实验说明使用分组GROUP BY对取值为NULL的项的处理</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 可知GROUP BY中取NULL的被视为一个分组</span></span><br></pre></td></tr></table></figure><p>(6)结合分组，使用集合函数求每个同学的平均分，总的选课记录，最高成绩，最低成绩，总成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(cid) <span class="string">&#x27;COUNT-COURSE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(score) <span class="string">&#x27;SUM-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(score);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093516.png" alt="image-20210414093434674"></p><p>(7)查询成绩小于0的选课记录，统计总数，平均分，最大值和最小值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)   <span class="string">&#x27;COUNT-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-RECORD&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093928.png" alt="image-20210414093927972"></p><p>(8)采用嵌套查询的方式，利用比较运算符合谓词ALL的结合来查询表COURSES中最少的课时。<br>– 假设数据库中只有一个记录时，使用前面的方法会得到什么结果，为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- (1)自己的想法</span></span><br><span class="line"><span class="comment">-- 数据库中只有一个记录时，若这个记录的hour不为空，则展示这个记录的hour；若hour为空，则返回空集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (2)书上的示例</span></span><br><span class="line"><span class="comment">-- 当只有一个记录时，逻辑上来说怎么都返回空集，但是DBS做了特殊处理？</span></span><br><span class="line"><span class="comment">-- hour值不为NULL时会返回这个记录；hour值为NULL时返回空集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES C1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES C2</span><br><span class="line">    <span class="keyword">WHERE</span> C1.cid <span class="operator">!=</span> C2.cid</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立一个只有一个记录的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> C_TEMP</span><br><span class="line">(</span><br><span class="line">    CID  <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">HOUR</span> <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C_TEMP(CID, <span class="keyword">HOUR</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP</span><br><span class="line"><span class="keyword">WHERE</span> CID <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C_TEMP(CID, <span class="keyword">HOUR</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">-- (1)自己的思路</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">HOUR</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">HOUR</span></span><br><span class="line">    <span class="keyword">FROM</span> C_TEMP C2</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (2)书上的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP C1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">HOUR</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">HOUR</span></span><br><span class="line">    <span class="keyword">FROM</span> C_TEMP C2</span><br><span class="line">    <span class="keyword">WHERE</span> C1.CID <span class="operator">!=</span> C2.CID</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(9)创建一个学生表S(NO, SID, SNAME)，教师表T(NO, TID, TNAME)作为实验用的表<br>– 其中，NO分别是这两个表的主键，其他键允许为空；NO为整型，其他字段为字符串型<br>– 向S中插入元组(1, ‘0129871001’, ‘王小明’),(2, ‘0129871002’, ‘李兰’),(3, ‘0129871005’, NULL),(4, ‘0129871004’, ‘关红’)<br>– 向T中插入元组(1, ‘100189’, ‘王小明’),(2, ‘100180’, 李小),(3, ‘100121’, NULL),(4, ‘100128’, NULL)<br>– 对这两个表作对姓名的等值连接运算，找出既是老师又是学生的人员的学生编号和教师编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> S</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NO</span>    <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    SID   <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    SNAME <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NO</span>    <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    TID   <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    TNAME <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S(<span class="keyword">NO</span>, SID, SNAME)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;0129871001&#x27;</span>, N<span class="string">&#x27;王小明&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;0129871002&#x27;</span>, N<span class="string">&#x27;李兰&#x27;</span>),</span><br><span class="line">       (<span class="number">3</span>, <span class="string">&#x27;0129871005&#x27;</span>, <span class="keyword">NULL</span>),</span><br><span class="line">       (<span class="number">4</span>, <span class="string">&#x27;0129871004&#x27;</span>, N<span class="string">&#x27;关红&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(<span class="keyword">NO</span>, TID, TNAME)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;100189&#x27;</span>, N<span class="string">&#x27;王小明&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;100180&#x27;</span>, N<span class="string">&#x27;李小&#x27;</span>),</span><br><span class="line">       (<span class="number">3</span>, <span class="string">&#x27;100121&#x27;</span>, <span class="keyword">NULL</span>),</span><br><span class="line">       (<span class="number">4</span>, <span class="string">&#x27;100128&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">SELECT</span> SNAME, SID, TID</span><br><span class="line"><span class="keyword">FROM</span> S,</span><br><span class="line">     T</span><br><span class="line"><span class="keyword">WHERE</span> S.SNAME <span class="operator">=</span> T.TNAME;</span><br><span class="line"><span class="comment">-- 等值连接使用的运算符是等号，NULL不得TRUE</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414094131.png" alt="image-20210414094131014"></p><h3 id="自我实践-5"><a href="#自我实践-5" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)查询所有课程记录的上课学时(数据库中为每星期学时)，以一个学期十八个星期计算每个课程的总学时，注意HOUR取NULL值的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, <span class="keyword">hour</span> <span class="operator">*</span> <span class="number">18</span> <span class="string">&#x27;ALL-HOUR&#x27;</span>, <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(2)通过查询选修课程C++的学生的人数，其中成绩合格的学生人数，不合格的学生人数，讨论NULL值的特殊含义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>(3)查询选修课程C++的学生的编号和成绩，使用ORDER BY按成绩进行排序时，取NULL的项是否出现在结果中？如果有，在什么位置？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 会出现，视为最小值，升序开头，降序结尾</span></span><br></pre></td></tr></table></figure><p>(4)在上面的查询的过程中，如果加上保留字DISTINCT会有什么效果呢？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 由于查询的是“编号和成绩”，而不是单独的成绩，当且仅当两个元组的“编号”和“成绩”都相同(两个NULL视为相同)时，才会发生变化</span></span><br></pre></td></tr></table></figure><p>(5)按年级对所有的学生进行分组，能得到多少个组？与现实的情况有什么不同</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="string">&#x27;COUNT-PEOPLE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br><span class="line"><span class="comment">-- 能得到15个组，NULL的被视为了一组</span></span><br></pre></td></tr></table></figure><p>(6)结合分组，使用集合函数求每个课程选修的学生的平均分，总的选课记录数，最高成绩，最低成绩，讨论考察取空值的项对集合函数的作用的影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>)   <span class="string">&#x27;COUNT-PEOPLE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br></pre></td></tr></table></figure><p>(7)采用嵌套查询的方式，利用比较运算符和谓词ALL的结合来查询表STUDENTS中最晚入学的学生年级。<br>– 当存在GRADE取空值的项时，考虑可能出现的情况，并解释原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 由于GRADE中存在空值，所以ALL中包含空值，任何一个grade&gt;=ALL都无法得到TRUE，所以得到的结果为空</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 对子查询中进行IS NOT NULL约束之后得到最晚的年级——2004</span></span><br></pre></td></tr></table></figure><p>(8)将操作步骤中的表的数据进行更新，<br>– 使得表S中，NO为2和3的记录的SID列取NULL值，<br>– T表的NO为4的记录的TID取NULL值，NO为3的TID取0129871005<br>– 然后，对这两个表按T.TID=S.SID作等值连接运算，找出编号相同的学生和教师的姓名，并分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> S</span><br><span class="line"><span class="keyword">SET</span> SID<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="keyword">IN</span> (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> TID <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> TID<span class="operator">=</span><span class="number">01298710005</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> S.SID, SNAME, TNAME</span><br><span class="line"><span class="keyword">FROM</span> S,</span><br><span class="line">     T</span><br><span class="line"><span class="keyword">WHERE</span> S.SID <span class="operator">=</span> T.TID</span><br><span class="line"><span class="comment">-- 查询结果为空集，因为等值连接的运算符是等号，对于NULL=NULL来说取值不为TRUE</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第一章-计算机系统概述</title>
      <link href="2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《操作系统考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统网课</a>。</p></blockquote><h2 id="操作系统的概念、功能和目标"><a href="#操作系统的概念、功能和目标" class="headerlink" title="操作系统的概念、功能和目标"></a>操作系统的概念、功能和目标</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328130119.png" alt="image-20210328130118951"></p><p>操作系统(Operating System, OS)：控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong></p><ul><li><p>操作系统的角色：</p><ol><li>作为系统资源的管理者</li><li>作为用户与计算机硬件之间的接口</li><li>作为最接近硬件的层次</li></ol></li><li><p>操作系统作为<strong>系统资源的管理者</strong>(这些资源包括软件、硬件、文件等)</p><ol><li>提供的功能：<ol><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ol></li><li>目标：安全、高效</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328131225.png" alt="系统资源管理者图解实例"></p><ul><li>操作系统作为<strong>用户与计算机硬件之间的接口</strong>，要为其上层的用户、应用程序提供简单易用的服务<ol><li>提供的功能：<ol><li>命令接口：允许用户<strong>直接</strong>使用<ol><li>联机命令接口——说一句做一句</li><li>脱机命令接口——说一堆做一堆</li></ol></li><li>程序接口：允许用户通过程序<strong>间接</strong>使用——系统调用</li><li>GUI(图形用户界面, Graphical User Interface)：现代操作系统中最流行的图形用户接口；用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令、参数</li></ol></li><li>目标：方便用户使用</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328132321.png" alt="image-20210328132321801"></p><ul><li>操作系统作为<strong>最接近硬件的层次</strong>，需要在纯硬件的基础上<ol><li>提供的功能和目标：实现对硬件机器的拓展</li></ol></li></ul><ol><li>裸机：没有任何软件支持的计算机<ol><li>在裸机上安装操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ol></li><li>扩充机器(虚拟机)：覆盖了软件的机器</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328133227.png" alt="image-20210328133227457"></p><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ul><li>操作系统的特征：其中并发和共享是两个<strong>最基本的特征</strong>，两者互为存在条件<ul><li>并发、共享、虚拟、异步</li></ul></li></ul><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><ul><li>并发：计算机系统中同时存在着多个运行着的程序<ul><li>并发：两个或多个事件在<strong>同一时间间隔内</strong>发生——宏观上同时发生，微观上交替发生</li><li>并行(与并发进行对比)：两个或多个事件在<strong>同一时刻同时</strong>发生</li></ul></li></ul><p>一个<strong>单核</strong>处理器(CPU)<strong>同一时刻只能执行一个程序</strong>，因此操作系统会负责协调多个程序交替执行(这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行)。事实上，操作系统就是伴随着<strong>多道程序技术</strong>出现的，因此，操作系统和程序并发是一起诞生的。即便现在的CPU大都是多核处理器，但是操作系统的并发性依然必不可少，因为计算机往往有高于核心数的程序需要同时工作，例如打开Windows的资源管理器，可以发现正在运行的程序/进程要远远多于CPU的核心数。</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><ul><li>共享：即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用<ul><li>互斥共享：虽然可以提供给多个进程使用，但是一个时间段内<strong>只允许一个进程</strong>访问该资源<ul><li>例如使用QQ和微信视频聊天——摄像头资源就是互斥资源，同一时间只能分配给一个进程，QQ和微信视频聊天</li></ul></li><li>同时共享：允许一个时间段内<strong>多个进程同时</strong>(宏观同时，微观交替进行，即<strong>微观分时共享</strong>)对它们进行访问<ul><li>例如使用QQ和微信发送文件——宏观上两者是同时读取并发送文件，微观上交替访问硬盘资源，此时的硬盘资源属于可以同时共享的系统资源</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328140650.png" alt="image-20210328140649972"></p><h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><ul><li><p>虚拟：把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)实际存在，逻辑上对应物(后者)是用户感受到的</p><ul><li>空分复用技术：如虚拟存储器技术</li><li>时分复用技术：如虚拟处理器技术</li></ul></li><li><p>背景知识：一个程序需要<strong>放入内存</strong>并<strong>分配CPU</strong>才能执行</p></li><li><p>假设同时运行多个程序，如GTA5(需4GB内存)、QQ(256MB)、网易云音乐(256MB)等(上述仅是举例，非实际内存要求)，而<strong>电脑内存假设只有4GB</strong>。那么这些程序同时运行需要的内存远大于4GB，为什么还可以在电脑上上同时运行：</p><ul><li>使用了<strong>虚拟存储器技术</strong>。实际只有4GB，但是在用户看来似乎远远大于4GB(虚拟技术中的“空分复用技术”)</li></ul></li><li><p>假设在某<strong>单核CPU的计算机</strong>中同时运行多个程序，既然一个程序需要被分配CPU才能正常执行，为什么单核CPU的电脑能同时运行多个程序：</p><ul><li>使用了<strong>虚拟处理器技术</strong>。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务(虚拟技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务)</li></ul></li></ul><p>显然：如果失去了并发性，那么一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性就谈不上虚拟性</strong></p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</p><p>当某个互斥系统资源需要被多个程序使用时，若这个资源被某个程序占用，其他程序需要使用这个资源时只能等待占用中的程序释放这个资源，即其他程序会进入阻塞状态，停顿下来，获得这个资源之后才可以再次进入执行状态</p><p>显然：如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。因此，<strong>系统只有拥有并发性，才有可能导致异步性</strong></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328143005.png" alt="image-20210328143005236"></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><ol><li>手工操作阶段<ol><li>缺点：用户独占全机、人机速度矛盾(CPU处理速度快，I/O慢，人工I/O更慢)——资源利用率极低</li></ol></li><li>单道批处理系统：引入<strong>脱机I/O技术</strong>(用磁带完成)，并由<strong>监督程序</strong>(操作系统的雏形)负责控制作业的输入输出<ol><li>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li>缺点：<ol><li>内存中仅能有<strong>一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序</li><li>CPU有大量的时间是在<strong>等待I/O</strong>完成(CPU处理速度快，I/O慢)</li><li>即资源利用率依然很低</li></ol></li></ol></li><li>多道批处理系统：每次往内存中输入多道程序，各个程序并发执行。<strong>操作系统正式诞生</strong>，并引入了中断技术，由操作系统负责管理这些程序的运行<ol><li>优点：<ol><li>多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。</li><li><strong>资源利用率大幅提升</strong>，CPU和其他资源保持“忙碌”状态(不同程序的I/O和计算阶段并发，无需等待某个程序彻底执行完毕)，系统吞吐量增大</li></ol></li><li>缺点：<ol><li>用户响应时间长，<strong>没有人机交互功能</strong>(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行)</li></ol></li></ol></li><li>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户/作业服务，各个用户可通过<strong>终端</strong>与计算机进行<strong>交互</strong><ol><li>优点：<ol><li>用户请求立可以被即使响应，<strong>解决了人机交互问题</strong></li><li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li></ol></li><li>缺点：不能优先处理一些紧急任务<ol><li>操作系统对各个用户/作业是完全公平的，循环地为每个用户/作业服务一个时间片，<strong>不区分任务的紧急性</strong></li></ol></li></ol></li><li>实时操作系统：计算机系统接收到外部信号后<strong>及时</strong>进行处理，并且要在<strong>严格的时限</strong>内处理完事件——及时性和可靠性<ol><li>分类：<ol><li>硬实时系统：必须在<strong>绝对严格的规定时间内</strong>完成处理——如导弹控制系统、自动驾驶系统</li><li>软实时系统：能接受<strong>偶尔违反</strong>时间规定——如12306火车订票系统</li></ol></li><li>优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队</li></ol></li><li>其他操作系统(了解即可)<ol><li>网络操作系统：伴随计算机网络的发展而诞生的操作系统，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信</strong>。(如Windows NT就是一个典型的网络操作系统，网站服务器就可以使用)</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong></li><li>个人计算机系统：如Win10、MacOS、Linux系统</li></ol></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328150044.png" alt="image-20210328150044425"></p><h2 id="操作系统的运行机制与体系结构"><a href="#操作系统的运行机制与体系结构" class="headerlink" title="操作系统的运行机制与体系结构"></a>操作系统的运行机制与体系结构</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328150431.png" alt="image-20210328150431061"></p><ul><li><p>指令：处理器(CPU)能够识别、执行的最基本命令</p><ul><li>特权指令：<strong>不允许用户程序使用</strong>；如内存清零指令</li><li>非特权指令：如普通的运算指令</li></ul></li><li><p>处理器状态：用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。例如以0为用户态，以1为核心态(仅是举例，非真正状态标识)</p><ul><li>核心态(管态)：<strong>特权指令</strong>、非特权指令都可执行</li><li>用户态(目态)：此时CPU只能执行非特权指令</li></ul></li><li><p>用户态与核心态的切换：(<strong>中断见下文的中断与异常</strong>)</p><ul><li>用户态–&gt;核心态：通过<strong>中断</strong>实现，并且<strong>中断是唯一途径</strong></li><li>核心态–&gt;用户态：通过<strong>执行一个个特权指令</strong>，将<strong>程序状态字(PSW)的标志位</strong>设置为用户态</li></ul></li><li><p>程序：</p><ul><li>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，<strong>运行在核心态</strong></li><li>应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328151508.png" alt="计算机系统的层次结构(操作系统划分)"></p><p>内核：计算机配置上的<strong>底层软件</strong>，是操作系统最基本、最核心的部分<br><strong>内核程序</strong>：实现操作系统内核功能的程序</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328151733.png" alt="操作系统的内核"></p><ul><li><p>操作系统的体系结构：</p><ul><li>微内核：只把<strong>最基本的功能</strong>保留在内核<ul><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li><li>举例：例如在“计算机系统的层次结构”示意图中，微内核可以是仅负责时钟管理、中断处理、原语这一层最基本功能的内核</li></ul></li><li>大内核：将操作系统的<strong>主要功能模块</strong>都作为系统内核，<strong>运行在核心态</strong><ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li><li>举例：例如在“计算机系统的层次结构”示意图中，大内核可以是不仅负责最基本功能那一层，还负责进程管理、存储器管理、设备管理等功能的内核</li></ul></li></ul></li><li><p>对于内核的类比</p><ul><li>内核：企业的管理层，负责一些重要的工作。只有<strong>管理层才能执行特权指令</strong>，普通员工只能执行非特权指令。用户态、核心态之间的<strong>状态切换</strong>相当于普通员工和管理层之间的<strong>工作交接</strong></li><li>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。<ul><li>优点：效率高——管理层处理大部分使，无需大量交接</li><li>缺点：组织混乱，难以维护——管理层分工不明确</li></ul></li><li>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。<ul><li>优点：组织结构清晰，方便维护——专人专事，遇到事件找特定的人即可</li><li>缺点：效率低——管理层和普通员工之间需要不断交接</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328153632.png" alt="image-20210328153632378"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>为了解决由于处理速度快、I/O速度慢而导致<strong>各程序只能串行执行的情况下，系统资源利用率低</strong>的问题，人们发明了操作系统作为计算机的管理者，引入<strong>中断机制</strong>，实现了多道程序的并发执行</p><ul><li>中断的特点：<ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol></li><li>发生了中断，就意味着需要操作系统的介入，开展管理工作(中断的<strong>本质</strong>)。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断</strong>可以使CPU从用户态转为核心态，<strong>使操作系统获得计算机的控制权</strong>。有了中断，才能实现多道程序并发执行</li></ul><blockquote><p>中断是用户态切换为核心态的唯一途径</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328155936.png" alt="中断的分类(一)"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328160106.png" alt="中断的分类(二)"></p><ul><li>外中断的处理：<ol><li>执行完每个指令之后，CPU都要检查当前是否有<strong>外部中断信号</strong></li><li>如果检测到外部中断信号，则需要<strong>保护被中断进程的CPU环境</strong>(如程序状态字PSW、程序计数器PC、各种通用寄存器)</li><li>根据<strong>中断信号类型</strong>转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328160656.png" alt="image-20210328160656578"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用：操作系统<strong>提供给应用程序(程序员/编程人员)使用的接口</strong>，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此<strong>系统调用的相关处理</strong>需要在<strong>核心态</strong>下进行</p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出请求服务请求，由操作系统代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328164331.png" alt="image-20210328164331282"></p><ol><li>普通应用程序：可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及<ol><li>涉及系统调用的库函数：如创建一个新文件、读写文件</li><li>不涉及系统调用的库函数：如取绝对值、算术运算</li></ol></li><li>编程语言：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便</li><li>操作系统：向上提供系统调用</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328165724.png" alt="image-20210328165724300"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328171017.png" alt="image-20210328170440288"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第七章-查找</title>
      <link href="2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/"/>
      <url>2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/20210327124531.png" alt="image-20210327124531136"></p><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p>查找——在数据集合中寻找满足某种条件的数据元素的过程；查找结果分为查找成功和查找失败</p><p>查找表——用于查找的数据集合，由同一种数据类型(或记录)的组成，可以是一个数组或链表等数据类型</p><ul><li>查找操作：<ol><li>查询某个特定的数据元素是否在查找表中</li><li>检索满足条件的某个特定的数据元素的各种属性</li><li>在查找表中插入一个数据元素</li><li>在查找表中删除一个数据元素</li></ol></li></ul><ol><li>静态查找表：有且仅有上述查找操作的前两个操作的查找表——即不会对查找表进行更改</li><li>动态查找表：具有上述四种查找操作的查找表</li></ol><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，<strong>查找结果应该是唯一的</strong>。</p><p>平均查找长度：查找时，关键字比较次数的平均值(在计算机中，查找时基于<strong>比较</strong>进行查找)</p><ul><li>平均(成功)查找长度计算公式：<ul><li>ASL(Average Select Length)：平均查找长度</li><li>Pi：编号为i的数据元素查找到的概率(一般情况下是1/n)</li><li>Ci：编号为i的数据元素查找到的查找长度</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/20210327125623.png" alt="image-20210327125623105"></p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找(线性查找)：主要用于在线性表中进行查找；从头到尾(或从尾向头)遍历查找</p><h3 id="无序线性表的顺序查找"><a href="#无序线性表的顺序查找" class="headerlink" title="无序线性表的顺序查找"></a>无序线性表的顺序查找</h3><p>对无序线性表进行顺序查找，当查找失败时要遍历整个线性表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序线性表的顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ST.elem[0]是哨兵元素，不存放任何元素</span></span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;</span><br><span class="line">    <span class="comment">// 从尾向头遍历查找</span></span><br><span class="line">    <span class="keyword">int</span> index = ST.TableLen;</span><br><span class="line">    <span class="keyword">while</span> (ST.elem[index] != key) &#123;</span><br><span class="line">        <span class="comment">// 当ST.elem[index]==key时跳出循环</span></span><br><span class="line">        <span class="comment">// 1、index位置的元素就是待查找元素</span></span><br><span class="line">        <span class="comment">// 2、index=0，到了哨兵位置，即ST中无待查找元素</span></span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无序线性表：<ul><li>平均(成功)查找长度——(n+1)/2</li><li>平均(失败)查找长度——(n+1)</li></ul></li></ul><h3 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h3><p>对有序线性表进行顺序查找，查找失败时不一定要遍历整个线性表，例如遍历到比待查找元素小的位置即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序线性表的顺序查找</span></span><br><span class="line"><span class="comment">// 有ST.elem[0]作为哨兵；顺序表内元素从小到大排列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ST.elem[0]是哨兵元素，不存放任何元素</span></span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;</span><br><span class="line">    <span class="comment">// 从尾向头遍历查找</span></span><br><span class="line">    <span class="keyword">int</span> index = ST.TableLen;</span><br><span class="line">    <span class="keyword">while</span> (ST.elem[index] != key &amp;&amp; ST.elem[index] &gt;= key) &#123;</span><br><span class="line">        <span class="comment">// 当ST.elem[index]==key时跳出循环</span></span><br><span class="line">        <span class="comment">// 1、index位置的元素就是待查找元素</span></span><br><span class="line">        <span class="comment">// 2、index=0，到了哨兵位置，即ST中无待查找元素</span></span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">// 假设有序线性表是从小到大排序，那么从后往前遍历，查找结束条件之一就是ST.elem[index]&lt;key</span></span><br><span class="line">        <span class="comment">// 因为ST.elem[index]&lt;key时，说明前面的所有元素都＜key，无需继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ST.elem[index] != key) &#123;</span><br><span class="line">        <span class="comment">// 存在ST.elem[0]哨兵的概念，查找失败返回值为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无序线性表：<ul><li>平均(成功)查找长度——(n+1)/2</li><li>平均(失败)查找长度——(n/2)+(n/(n+1))</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/20210327132726.png" alt="结合“判定树”计算“有序线性表”的“平均失败查找长度”"></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找(二分查找)：仅适用于有序的顺序表</p><ul><li>算法思想：首先将给定值key与表中中间位置元素的关键字比较<ul><li>若相等，则返回该元素的位置</li><li>若不等，则在前半部分或者后半部分进行查找<ul><li>假设是升序序列</li><li>若key小于中间元素，则查找前半部分</li><li>若key大于中间元素，则查找后半部分</li></ul></li><li>重复该过程，直到找到查找的元素位置为止；或查找失败</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;         <span class="comment">//动态数组存放数据元素，此处是指针位置</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">//动态顺序表的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125; SeqList;                  <span class="comment">//动态分配的方式定义顺序表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = L.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L.data[mid] == key) &#123;</span><br><span class="line">            <span class="comment">// 查找成功，返回元素位置</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; L.data[mid]) &#123;</span><br><span class="line">            <span class="comment">// key小于中间元素，则查找前半部分</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key大于中间元素，则查找后半部分</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/20210327135339.png" alt="折半查找判定树"></p><ul><li>使用判定树求平均查找长度：<ol><li>画出判定树——包括成功结点和失败结点</li><li>成功ASL：((树的层数*这一层的成功结点个数)累加求和)/成功结点个数</li><li>失败ASL：((树的层数*这一层的失败结点个数)累加求和)/失败结点个数</li></ol></li><li>以上图“折半查找的判定树”为例求平均查找长度：</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/20210327135951.png" alt="image-20210327135951214"></p><p>时间复杂度O(log2(n))(以2为底，n的对数)</p><blockquote><p>顺序查找：适用于顺序存储和<strong>链式存储</strong>，序列有序无序皆可</p><p>折半查找：<strong>仅适用于顺序存储</strong>，且序列一定<strong>有序</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第八章-排序</title>
      <link href="2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/"/>
      <url>2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327104827.png" alt="image-20210327104827739"></p><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><p>排序：重新排列表中的元素，使表中的元素满足按关键字递增或递减</p><p>排序算法的稳定性：若待排序表中有两个元素Ri和Rj，其对应的关键字ki=kj，且在排序前Ri在Rj前面，若使用某排序算法后，Ri仍然在Rj前面，则称这个排序算法是稳定的，否则称排序算法不稳定。</p><blockquote><p>排序算法的稳定性是算法的一个性质，并不能衡量一个算法的优劣。</p><p>比如STL的算法(algorithm)中的sort()排序函数基本是采用”快速排序”的方法实现的，”快速排序”是一种不稳定的算法，却不能说”快速排序”算法不好</p></blockquote><ul><li>内部排序：在排序期间元素全部存放在内存中的排序；性能由<strong>时空复杂度</strong>决定<ol><li>插入排序：<ol><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ol></li><li>交换排序<ol><li>冒泡排序</li><li>快速排序</li></ol></li><li>选择排序<ol><li>简单选择排序</li><li>堆排序</li></ol></li><li>归并排序</li><li>基数排序——除基数排序外，其余8种排序方法都基于”移动和比较”来进行排序</li></ol></li><li>外部排序：在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间进行移动——内存大小有限，当要排序的元素表的大小比内存大时，需要不断将一部分元素放入内存中进行排序，直到排序完成</li></ul><blockquote><p>引入A[0]哨兵概念，即对于一个含有n个数据元素的线性表(一般情况下是一个数组)A，它的实际大小应该是n+1，其中每个数据元素的下标从1开始，即与位序相等的，实际存储是从A[1]到A[n-1]，A[0]仅作为一个辅助元素。</p><p>当然，对于大部分实际应用场景来说，线性表本身是不存在A[0]哨兵概念的，即一般情况下数据元素的存储由下标0开始，这里引入A[0]作为哨兵是为了下述排序算法更容易实现，当然也可以定义一个局部变量作为暂存元素。</p></blockquote><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：每次将一个待排序的序列插入到一个前面已经排好序的子序列当中</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul><li>初始L[1]是一个已经排好序的子序列</li><li>对于元素L(i)(L(2)~L(n))插入到前面已经排好序的子序列当中：<ol><li>查找出L(i)在L[1……i-1]中的插入位置k</li><li>将L[k……i-1]中的所有元素全部后移一个位置</li><li>将L(i)复制到L(k)</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212342.png" alt="image-20210329212342098"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的直接插入排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">// 从A[2]开始——A[0]是哨兵，不存放元素；A[1]看做已经排好序的序列</span></span><br><span class="line">    <span class="comment">// n指的是待排序元素个数而不是数组大小，由于有A[0]作为哨兵，所以A大小为n+1，有效元素A[1]到A[n]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// A[0]作为哨兵，不存放元素</span></span><br><span class="line">        <span class="comment">// 此处是暂存待插入的元素</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        <span class="comment">// j=i-1——从后向前找一个合适的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; j--) &#123;</span><br><span class="line">            <span class="comment">// 找到合适的位置前，所有元素后移</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            <span class="comment">// 循环终止条件——A[0]&lt;A[j]</span></span><br><span class="line">            <span class="comment">// 1、找到了一个A[0]&gt;=A[j]的位置，那么A[0]应该插入到A[j+1]处</span></span><br><span class="line">            <span class="comment">// 2、所有元素都比A[0]大，那么此时j=0，A[0]需插入到A[1]即A[j+1]</span></span><br><span class="line">            <span class="comment">// 总之就是A[j+1]的值应该替换为A[0]的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有A[0]哨兵的直接插入排序</span></span><br><span class="line"><span class="comment">// A[]中所有元素都是待排序元素的直接插入排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ElemType elemTmp;   <span class="comment">// 起哨兵作用，暂存待插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        elemTmp = A[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; elemTmp &lt; A[j] &amp;&amp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 从后向前找插入位置，且下标不等小于0</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同A[0]作为哨兵的情况，无论如何都是替换A[j+1]的值</span></span><br><span class="line">        A[j + <span class="number">1</span>] = elemTmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<ul><li>最好时间复杂度：O(n)</li><li>最坏时间复杂度：O(n^2)</li><li>平均时间复杂度：O(n^2)</li></ul></li></ul><p>直接插入排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>折半插入排序——相较于直接插入排序，查找插入位置时采用<strong>折半查找</strong>的方式，查找效率优于直接插入排序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];    <span class="comment">// 哨兵——A[0]，暂存待插入元素</span></span><br><span class="line">        <span class="comment">// 查找区间——[1, i-1]</span></span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 折半查找</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] &lt; A[mid]) &#123;</span><br><span class="line">                <span class="comment">// A[0]应插入到A[mid]之前</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// A[0]应插入到A[mid]之后</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当low&gt;high时，说明已经找到了位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 待插入位置既可以用A[high+1]表示，也可以用A[low]表示</span></span><br><span class="line">        <span class="comment">// 待插入位置A[high+1]之后的元素后移</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt; high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终插入位置是A[high+1]</span></span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半插入排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；仅适用于顺序存储(数组)。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(缩小增量排序)：先将排序表分割成d个形如[i, i+d, i+2d, ……, i+kd]的“特殊”子表，分别进行直接插入排序，进行多趟(每趟步长d缩减)，当整个表中的元素已成“基本有序时”(步长d缩减到1)，再对全体记录进行一次直接插入排序。</p><p>步长d选取方法——Shell’s idea</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327142055.png" alt="image-20210327142055361"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212428.png" alt="image-20210329212428133"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的根据定义制定的希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dk; i++) &#123;</span><br><span class="line">            <span class="comment">// dk组——每组的起点[1, 2, ……, dk]</span></span><br><span class="line">            <span class="comment">// 对每组分别进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + dk; j &lt;= n; j += dk) &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[j];    <span class="comment">// A[0]是哨兵</span></span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="comment">// 判定条件有k&gt;0是因为k-=dk可能出现k为负数的情况</span></span><br><span class="line">                <span class="keyword">for</span> (k = j - dk; k &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[k]; k -= dk) &#123;</span><br><span class="line">                    A[k + dk] = A[k];</span><br><span class="line">                &#125;</span><br><span class="line">                A[k + dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的“同时对所有组进行直接插入排序”的希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 同时对所有组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">// 判定条件有j&gt;0是因为j-=dk可能出现j为负数的情况</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j -= dk) &#123;</span><br><span class="line">                    A[j + dk] = A[j];</span><br><span class="line">                &#125;</span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序是一个时间复杂度为O(n^2)(大部分情况下是O(n^1.3)，效率较高)、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；仅适用于顺序存储(数组)。</p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序：假设待排序表长为n，从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换他们直到序列比较结束</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329215202.png" alt="image-20210329215202478"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有A[0]哨兵的冒泡排序，共n个元素，有A[0]到A[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前n-1个元素都到其最终位置之后，最后第n个元素也就在其最终位置了，所以i&lt;n-1</span></span><br><span class="line">        <span class="comment">// 一趟下来之后，有一个元素到达最终位置</span></span><br><span class="line">        <span class="comment">// 如此处以增序为例(从小到大排序)，每次剩下序列里最小的就会到最前面</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 如果一趟下来一个都不交换，说明已经排序好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="comment">// 从后往前比较，最后j=i+1，比较A[i]和A[i+1]</span></span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">                <span class="comment">// 相邻两个为逆序，交换位置，并将flag置true，说明没排好序</span></span><br><span class="line">                swap(A[j - <span class="number">1</span>], A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;    <span class="comment">// 一趟下来没发生交换(无逆序)，说明已经排好序了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<ul><li>最好时间复杂度：O(n)</li><li>最坏时间复杂度：O(n^2)</li><li>平均时间复杂度：O(n^2)</li></ul></li></ul><p>冒泡排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序——在待排序表L[1……n]中任取一个元素pivot(一般为第一个元素)作为<strong>基准</strong>，通过一趟排序将待排序表划分为具有如下特点的两部分：使pivot逐渐到中间位置，在pivot之前的元素都小于等于pivot，在pivot之后的元素都大于等于pivot——即一次划分会将一个元素pivot放置到它最终的位置上</p><ul><li>基本思路：初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断地移动两个标记并交换元素：<ol><li>high向前移动找到第一个比pivot小的元素</li><li>low向后移动找到第一个比pivot大的元素</li><li>交换当前两个元素的位置</li><li>继续移动标记，执行1.2.3.过程，直到low大于等于high为止</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于区间 [low, high] 的一次划分</span></span><br><span class="line"><span class="comment">// 返回值是这次划分之后基准元素落在的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    ElemType pivot = A[low];    <span class="comment">// 基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) &#123;</span><br><span class="line">            <span class="comment">// 从后向前找，找到一个比pivot小的元素</span></span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A[low]作为辅助变量，暂存找到的比pivot小的元素</span></span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &gt;= A[low]) &#123;</span><br><span class="line">            <span class="comment">// 从前向后找，找到一个比pivot大的元素</span></span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基准元素pivot最后落在的位置，此时low==high，A[low]与A[high]等价</span></span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">//返回基准元素最后落在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于上述一次划分算法的举例：5, 7, 5, 8, 6, 9, 1, 4, 3</span><br><span class="line">初始low&#x3D;0, high&#x3D;8, pivot&#x3D;A[low]&#x3D;A[0]&#x3D;5</span><br><span class="line"></span><br><span class="line">1. high&#x3D;8, A[low]&#x3D;A[0]&#x3D;A[high]&#x3D;A[8]&#x3D;3</span><br><span class="line">low&#x3D;1, A[high]&#x3D;A[8]&#x3D;A[low]&#x3D;A[1]&#x3D;7</span><br><span class="line">此时：3, 7, 5, 8, 6, 9, 1, 4, 7——low&#x3D;1, high&#x3D;8, pivot&#x3D;5</span><br><span class="line">2. high&#x3D;7, A[low]&#x3D;A[1]&#x3D;A[high]&#x3D;A[7]&#x3D;4</span><br><span class="line">low&#x3D;3, A[high]&#x3D;A[7]&#x3D;A[low]&#x3D;A[3]&#x3D;8</span><br><span class="line">此时：3, 4, 5, 8, 6, 9, 1, 8, 7——low&#x3D;3, high&#x3D;7, pivot&#x3D;5</span><br><span class="line">3. high&#x3D;6, A[low]&#x3D;A[3]&#x3D;A[high]&#x3D;A[6]&#x3D;1</span><br><span class="line">low&#x3D;4, A[high]&#x3D;A[6]&#x3D;A[low]&#x3D;A[4]&#x3D;6</span><br><span class="line">此时：3, 4, 5, 1, 6, 9, 6, 8, 7——low&#x3D;4, high&#x3D;6, pivot&#x3D;5</span><br><span class="line">4. high&#x3D;4, A[low]&#x3D;A[4]&#x3D;A[high]&#x3D;A[4]&#x3D;6</span><br><span class="line">low&#x3D;4, A[high]&#x3D;A[4]&#x3D;A[low]&#x3D;A[4]&#x3D;6</span><br><span class="line">此时：3, 4, 5, 1, 6, 9, 6, 8, 7——low&#x3D;4, high&#x3D;4, pivot&#x3D;5</span><br><span class="line"></span><br><span class="line">low&#x3D;high&#x3D;4，跳出了while循环，更换A[low]的值</span><br><span class="line">low&#x3D;4, A[low]&#x3D;A[4]&#x3D;pivot&#x3D;5</span><br><span class="line">此时：3, 4, 5, 1, 5, 9, 6, 8, 7</span><br><span class="line">返回的基准元素位置是low&#x3D;4：</span><br><span class="line">    即在A[4]&#x3D;5的左部，所有元素都&lt;&#x3D;pivot&#x3D;5</span><br><span class="line">    在A[4]&#x3D;5的右部，所有元素都&gt;&#x3D;pivot&#x3D;5</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用上述的一趟排序函数，再递归调用自身逐层排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获得基准元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotPos = Partition(A, low, high);</span><br><span class="line">        <span class="comment">// 对左半部分进行排序—— [low, pivotPos) 即 [low, pivotPos-1]</span></span><br><span class="line">        QuickSort(A, low, pivotPos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对右半部分进行排序—— (pivotPos, high] 即 (pivotPos+1, high]</span></span><br><span class="line">        QuickSort(A, pivotPos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlog2(n))(n×以2为底n的对数)<ul><li>最坏时间复杂度：O(n^2)——初始基本有序或逆序</li></ul></li><li>空间复杂度：O(log2(n))(以2为底n的对数)<ul><li>最坏空间复杂度：O(n)</li></ul></li></ul><p>快速排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(log2(n))的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)，有时要求链式存储也实现快速排序算法(更改指针初始位置，及一些特殊条件的情况下)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：每次将一个待排序序列中关键字最小的元素放到前面已经排好序的子序列尾部</p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>简单选择排序：每一趟在后面n-i+1(i=1,2,……,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到n-1趟做完，待排序元素只剩下1个；一趟排序结束会将一个元素放置在其最终位置上</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212534.png" alt="image-20210329212534712"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) &#123;</span><br><span class="line">                <span class="comment">// 找到了比A[min]更小的数，更新min(下标)</span></span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="comment">// 找到了比A[i]更小的数，需要交换位置</span></span><br><span class="line">            swap(A[i], A[min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单选择排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆：n个关键字序列L[1……n]称为堆，当且仅当该序列满足：<ul><li>若L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)，则称该堆为<strong>小根堆</strong></li><li>若L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)，则称该堆为<strong>大根堆</strong></li><li>1&lt;=i&lt;=(n/2)</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327162848.png" alt="image-20210327162848352"></p><p>在排序过程中可以将L[1……n]视为一棵完全二叉树的顺序存储结构，小根堆实例如下(大根堆同理)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327163012.png" alt="image-20210327163012487"></p><ul><li>堆的初始化(以大根堆举例)：对所有具有双亲节点含义编号从大到小((n/2)……1)做出如下调整：<ol><li>若孩子节点皆小于双亲结点，则该结点的调整结束</li><li>若存在孩子结点大于双亲结点，则将最大的孩子结点与双亲结点交换，并对该孩子结点进行1.2.过程，直到出现1.或直到叶子结点为止</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327170201.png" alt="堆的初始化实例(大根堆)"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下找子节点调整的过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];    <span class="comment">// 编号由1开始，A[0]作为一个辅助变量，暂存结点值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 2*k是其左孩子结点，每次*2都是到达左孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 找出孩子结点里最大的那一个</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) &#123;</span><br><span class="line">            <span class="comment">// 如果双亲结点&gt;=孩子结点那么就不需要替换了，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 孩子结点&gt;双亲结点，需要替换</span></span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没有发生替换，则A[k]恢复原值</span></span><br><span class="line">    <span class="comment">// 若发生了替换，则被替换过后的结点赋值为原A[k]的值</span></span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定需要判断调整的结点，然后调用调整过程——初始化大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// [n/2, 1] 编号的结点调整</span></span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化堆的时间复杂度——O(n)</li></ul><p>堆排序：不断输出堆顶元素，并向下调整</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212727.png" alt="image-20210329212727352"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212837.png" alt="image-20210329212836942"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不断输出堆顶元素，并向下调整——将堆顶元素放置到末尾，然后将前面的序列调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);   <span class="comment">// 初始化大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 从i=len开始，每次将堆顶元素放到现在这个大根堆的末尾，然后对剩下的无序序列(仅1号元素不符合大根堆)进行调整，使其成为一个大根堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前大根堆的最后的元素与堆顶元素进行交换，这样堆顶元素(最大的元素)就到了最后</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 交换后堆顶元素变为了原最后的值，对现在这个堆进行一次调整，使其称为一个大根堆</span></span><br><span class="line">        <span class="comment">// 因为原堆顶元素被放置到了末尾，所以调整时不可以取末尾，使得i-1即可</span></span><br><span class="line">        AdjustDown(A, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)。</p><p>堆的插入：将新结点放置在末端然后进行向上调整</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大根堆的向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];    <span class="comment">// 暂存A[k]结点值</span></span><br><span class="line">    <span class="keyword">int</span> i = k / <span class="number">2</span>;  <span class="comment">// 找到其双亲结点的下标</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] &lt; A[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 循环结束条件：1、已经是1号结点，不能再向上了；2、双亲结点&gt;=子节点</span></span><br><span class="line">        <span class="comment">// 循环进行时也就代表需要调整</span></span><br><span class="line">        A[k] = A[i];    <span class="comment">// A[k]结点替换为其双亲结点A[i]的值</span></span><br><span class="line">        k = i;          <span class="comment">// 下一次调整：从双亲结点A[i]向上调整</span></span><br><span class="line">        i = k / <span class="number">2</span>;      <span class="comment">// 找到新的双亲结点的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];    <span class="comment">// 赋值为待调整的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的基本思想：首先将a[0……n-1]看成是长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到(n/(k^2))个长度为k^2的有序子表，如此反复进行下去，直到最后得到一个长度为n的有序表。</p><p>可以理解为：将相邻的n个有序子表合并成一个大的有序子表，然后再合并相邻的n个大的有序子表直到将整个序列合并成一个完整的有序序列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二路归并排序实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个相邻的有序线性表</span></span><br><span class="line">ElemType *B = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * (length + <span class="number">1</span>)); <span class="comment">// length是待归并的数组大小</span></span><br><span class="line"><span class="comment">// 对于归并排序合并的两个线性表其实是在数组A[]中的两片相邻空间</span></span><br><span class="line"><span class="comment">// 线性表 A1——[low, mid] A2——(mid, high]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">        <span class="comment">// 先将待处理的两个线性表的所有元素都存储到辅助数组B[]中</span></span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="comment">// i 作为线性表 A1——[low, mid] 的索引</span></span><br><span class="line">    <span class="comment">// j 作为线性表 A2——(mid, high] 的索引</span></span><br><span class="line">    <span class="comment">// k 作为线性表 A 的索引，将符合条件的元素依次根据k放入A中</span></span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="comment">// 先将小的放到A中</span></span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束时，两个线性表中最多只有一个线性表的元素还没放完</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        <span class="comment">// 线性表A1剩余的元素放入A中</span></span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 线性表A2剩余的元素放入A中</span></span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序——递归调用</span></span><br><span class="line"><span class="comment">// 递归出口：当low&gt;=high时，也就是划分到每一个有序序列或为空或仅有一个元素</span></span><br><span class="line"><span class="comment">// 递归体：将当前区间分成两个区间——[low, mid]和(mid, high]，分别进行归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;         <span class="comment">// 将这个区间对半分，分别归并</span></span><br><span class="line">        MergeSort(A, low, mid);             <span class="comment">// 左半部分——[low, mid]</span></span><br><span class="line">        MergeSort(A, mid + <span class="number">1</span>, high);    <span class="comment">// 右半部分——(mid, high]</span></span><br><span class="line">        Merge(A, low, mid, high);           <span class="comment">// 将归并结束之后的两个有序序列合并到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327195913.png" alt="二路归并实例"></p><p>归并排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(n)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序：借助”分配”和”收集”两种操作对单逻辑关键字进行排序，分为最高位有序(MSD)和最低位优先(LSD)。特点：不基于比较</p><p>以r为基数的最低位优先基数排序：假设线性表由结点序列a0, a1, ……, an-1构成，每个结点aj的关键字有d元组(kj^(d-1), kj^(d-2), ……, kj^(1), kj^(0))组成，0&lt;=kj^(i)\&lt;=r-1(0&lt;=j&lt;n, 0&lt;=i&lt;=d-1)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个线性表的每个结点的关键字可以记为如下：</span><br><span class="line">324, 768, 270, 121, 962, 666, 857, 503, 768</span><br><span class="line">那么对于这个线性表，有：</span><br><span class="line">n&#x3D;9：线性表共有9个数据元素——a0到an-1</span><br><span class="line">d&#x3D;3：每个结点的关键字是3元组(上面的关键字都是3位数)</span><br><span class="line">r&#x3D;10：d元组的每个k取值在[0, 10)中，即0~9</span><br></pre></td></tr></table></figure><ul><li>分配和收集：在排序时使用r个队列Q0, Q1, ……, Qr-1<ul><li>分配：开始时，把各个队列置空，然后依次考察每个结点的关键字，若aj的关键字中kj^(i)=k，就把aj放入队列Qk当中</li><li>收集：把各个队列中的结点依次首尾相接，得到一个新的结点序列，组成线性表</li><li>经过d次(按照i由小到大的顺序)分配收集之后，序列会成为一个有序的序列</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327202945.png" alt="基数排序实例"></p><p>时间复杂度：O(d(n+r))；d——d元组；n——线性表元素个数；r——d元组中每个k值的取值范围</p><p>基数排序是一个时间复杂度为O(d(n+r))、空间复杂度为O(r)的<strong>稳定</strong>的排序算法；不基于比较。</p><h2 id="内部排序方法对比"><a href="#内部排序方法对比" class="headerlink" title="内部排序方法对比"></a>内部排序方法对比</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327204641.png" alt="内部排序方法的对比——不带“折半插入排序”是因为其仅是在“直接插入排序”的查找方面进行了优化"></p><ul><li><p>选择内部排序算法时的考虑因素：</p><ul><li>元素数目：<ul><li>n较小时(n&lt;=50)，一般采用直接插入排序或简单选择排序</li><li>n较大时，一般采用快速排序、堆排序或归并排序</li><li>n特别大，记录关键字位数较少且可分解时，采用基数排序</li></ul></li><li>元素大小：数据元素类型的存储空间大小，当占用空间大时，采用“交换元素位置”的排序算法(如“冒泡排序”)时，会因为交换元素而耗用大量时间<ul><li>即尽量避免大量移动的排序算法，尽量采用链式存储</li></ul></li><li>关键字结构及分布：<ul><li>关键字结构：关键字可以分割成某些位时，可以采用基数排序</li><li>分布：初始序列是否有序<ul><li>初始序列有序时：一般不考虑快速排序，而是采用直接插入或冒泡排序</li></ul></li></ul></li><li>稳定性：是否要求稳定排序算法</li><li>存储结构：是否支持链式存储结构，以及实现链式存储结构的排序时是否麻烦</li><li>辅助空间：对于辅助空间大小有无限制要求</li><li>……</li></ul></li><li><p>元素数目n较大时：</p><ul><li>快速排序：初始序列有序时不建议采用；辅助空间有限制</li><li>堆排序：不稳定</li><li>归并排序：稳定</li></ul></li></ul><p>当文件的n个关键字随机分布时，任何借助“比较”的排序，至少需要O(nlog2(n))的时间</p><table><thead><tr><th>内部排序方法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性质</th><th>适用存储结构</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>顺序、链式</td></tr><tr><td>折半插入排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>顺序</td></tr><tr><td>希尔排序</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>顺序</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>顺序、链式</td></tr><tr><td>快速排序</td><td>O(nlog2(n))</td><td>O(log2(n))</td><td>不稳定</td><td>顺序(链式)</td></tr><tr><td>直接选择排序</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>顺序、链式</td></tr><tr><td>堆排序</td><td>O(nlog2(n))</td><td>O(1)</td><td>不稳定</td><td>顺序(链式)</td></tr><tr><td>归并排序</td><td>O(nlog2(n))</td><td>O(n)</td><td>稳定</td><td>顺序、链式</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(r)</td><td>稳定</td><td>不基于比较</td></tr></tbody></table><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><blockquote><p>外部排序方面似乎不常考，但是要知道概念和常用排序方法(大概)，往年考研题我只做到了一道关于外部排序的选择题，涉及的是<strong>最佳归并树</strong>的知识</p></blockquote><h3 id="归并排序算法——基础算法"><a href="#归并排序算法——基础算法" class="headerlink" title="归并排序算法——基础算法"></a>归并排序算法——基础算法</h3><p>外部排序通常采用<strong>归并排序</strong>方法：首先，根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，<strong>依次读入内存</strong>并利用有限的<strong>内部排序算法</strong>对它们进行排序，并将排序后得到的<strong>有序子文件重新写回外存</strong>，通常称这些有序子文件为<strong>归并段</strong>或<strong>顺串</strong>；然后对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件</p><p>一般将内存分为三个缓冲区：输入缓冲区1(从第一段中输入)、输入缓冲区2(从第二段中输入)、输出缓冲区(预计写入到文件中的数据)。</p><p>以两个相邻有序段——归并段1[1, 3, 5, 8]与归并段2[2, 4, 6, 7]为例(归并段1在外存上排在归并段2之前)，不妨以$表示已经读入到内存中的数据(这里只是为了更直观的表示排序过程，并不是真的外存内容被设置为$)，内存可容纳6个数据元素，均分为三段——输入缓冲区1、输入缓冲区2、输出缓冲区：</p><table><thead><tr><th align="center">归并段1</th><th align="center">归并段2</th><th>输入缓冲区1</th><th>输入缓冲区2</th><th>输出缓冲区</th><th align="left">输出文件</th><th>动作</th></tr></thead><tbody><tr><td align="center">1, 3, 5, 8</td><td align="center">2, 4, 6, 7</td><td></td><td></td><td></td><td align="left"></td><td></td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td>1, 3</td><td>2, 4</td><td></td><td align="left"></td><td>读入1,3到输入缓冲区1，读入2,4到输入缓冲区2</td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td>1, 3</td><td>2, 4</td><td>1</td><td align="left"></td><td>1与2进行比较，1进入输出缓冲区</td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td>1, 3</td><td>2, 4</td><td>1, 2</td><td align="left"></td><td>3与2进行比较，2进入输出缓冲区</td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td>1, 3</td><td>2, 4</td><td></td><td align="left">1, 2</td><td>输出缓冲区已满，输出到外存</td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td>1, 3</td><td>2, 4</td><td>3</td><td align="left">1, 2</td><td>3与4进行比较，3进入输出缓冲区</td></tr><tr><td align="center">$, $, 5, 8</td><td align="center">$, $, 6, 7</td><td></td><td>2, 4</td><td>3</td><td align="left">1, 2</td><td>输入缓冲区1已比较完毕，清空输入缓冲区1</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, 6, 7</td><td>5, 8</td><td>2, 4</td><td>3</td><td align="left">1, 2</td><td>读入5,8到输入缓冲区1</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, 6, 7</td><td>5, 8</td><td>2, 4</td><td>3, 4</td><td align="left">1, 2, 3, 4</td><td>5与4进行比较，4进入输出缓冲区</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, 6, 7</td><td>5, 8</td><td>2, 4</td><td></td><td align="left">1, 2, 3, 4</td><td>输出缓冲区已满，输出到外存</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, 6, 7</td><td>5, 8</td><td></td><td></td><td align="left">1, 2, 3, 4</td><td>输入缓冲区2已比较完毕，清空输入缓冲区2</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td>6, 7</td><td></td><td align="left">1, 2, 3, 4</td><td>读入6,7到输入缓冲区2</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td>6, 7</td><td>5</td><td align="left">1, 2, 3, 4</td><td>5与6进行比较，5进入输出缓冲区</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td>6, 7</td><td>5, 6</td><td align="left">1, 2, 3, 4</td><td>6与8进行比较，6进入输出缓冲区</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td>6, 7</td><td></td><td align="left">1, 2, 3, 4, 5, 6</td><td>输出缓冲区已满，输出到外存</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td>6, 7</td><td>7</td><td align="left">1, 2, 3, 4, 5, 6</td><td>7与8进行比较，7进入输出缓冲区</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td></td><td>7</td><td align="left">1, 2, 3, 4, 5, 6</td><td>输出缓冲区2已比较完毕，清空输入缓冲区2</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td></td><td>7, 8</td><td align="left">1, 2, 3, 4, 5, 6</td><td>8进入输出缓冲区</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td>5, 8</td><td></td><td></td><td align="left">1, 2, 3, 4, 5, 6, 7, 8</td><td>输出缓冲区已满，输出到外存</td></tr><tr><td align="center">$, $, $, $</td><td align="center">$, $, $, $</td><td></td><td></td><td></td><td align="left">1, 2, 3, 4, 5, 6, 7, 8</td><td>输入缓冲区1已比较完毕，清空输入缓冲区1</td></tr></tbody></table><p>即对上述两个外存中的两个有序段归并之后输出文件中的数据序列即为有序序列</p><p>使用<strong>归并排序</strong>的方法进行外部排序时，只需不断执行上述过程，便可以得到排好序的外存中的大量数据的文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330095112.png" alt="2路归并"></p><p>外部排序的总时间=内部排序所需时间(单个小归并段使用内部排序方法排序为有序序列)+外存信息读写时间(I/O时间)+内部归并所需时间(两个相邻的归并段进行上述归并操作)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330095424.png" alt="image-20210330095424602"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tES——外部排序的总时间</span><br><span class="line">r——初始把外存中的文件一共划分为r段</span><br><span class="line">tIS——每段进行内部排序所需时间</span><br><span class="line">d——总共进行的I&#x2F;O次数，一次读取记一次，一次写入记一次——(S+1)*(2*r)</span><br><span class="line">tIO——每段读取或者写入所花费的时间</span><br><span class="line">S——归并趟数，如上图所示的归并共进行了2趟(中间的线是趟)</span><br><span class="line">(n-1)——每一趟所需的比较次数</span><br><span class="line">tmg——一次内部归并比较所需时间</span><br><span class="line"></span><br><span class="line">不妨举这么一个例子：初始记录有20000个记录，初始归并段5000个记录</span><br><span class="line">r&#x3D;20000&#x2F;5000&#x3D;4——初始把外存中的文件一共划分为4段，每段5000个记录(如上图所示)</span><br><span class="line">S&#x3D;2——4-&gt;2-&gt;1，中间的-&gt;代表一趟</span><br><span class="line">d&#x3D;(S+1)*(2*r)&#x3D;3*(2*4)——一段读或写需要tIO，划分为r段，则读取r次写入r次，即整个文件一次读写花费2*r次，4-&gt;2-&gt;1可知需要读写3轮，即3*(2*r)</span><br><span class="line">n&#x3D;20000——20000个数据</span><br><span class="line">S(n-1)&#x3D;2*(20000-1)&#x3D;2*20000——20000&gt;&gt;1，1可忽略</span><br><span class="line">即tES&#x3D;4*tIS+3*(2*4)tIO+2*20000tmg</span><br></pre></td></tr></table></figure><p>从2路归并变为4路归并之后，读写时间会发生改变，如下图所示，归并趟数由2变为了1，外存信息读写时间由3*(2*4)tIO变为了2*(2*4)tIO，即增大归并路数减少归并段数可以有效减少外存信息读写时间，减少外部排序的总时间。</p><p>归并趟数=logm(r)向上取整(以m为底r的对数向上取整，其中m是归并路数，r是划分的段数)，比如上述例子的2路归并中，m=2，r=4，log2(4)向上取整为2，即2趟归并。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330153143.png" alt="4路归并"></p><h3 id="败者树——优化m"><a href="#败者树——优化m" class="headerlink" title="败者树——优化m"></a>败者树——优化m</h3><ul><li>S趟归并总共需要比较的次数——S(n-1)(m-1)<ul><li>S：归并趟数</li><li>n：关键字个数</li><li>m-1：求得最小的关键字比较所需的时间，m路归并，一次比较需要比较m-1次才可以求出最小的关键字</li></ul></li></ul><p>败者树：树形选择排序的一种变体，可视为一棵完全二叉树。每个叶子结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，胜利者向上记录进行比较，直到根结点</p><p>如图所示是一棵败者树的实例的前两轮，依次按照败者树的比较方法向下进行即可。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330161030.png" alt="败者树的前两轮比较示例"></p><p>败者树可以减少比较次数，按照归并路数计算来说，5路归并，每次确定一个最小值需要比较5-1=4次，但是从第二轮开始，仅需与双亲结点记录的位置进行比较，比如如图所示的第二轮仅比较了3次就确定了当前最小值——9，倘若继续进行下去，可知第三轮需要比较b1(18)与b2(20)得到b1(18)上移，然后b1(18)与b0(10)得到b0(10)上移，1号结点记录由bo(10)-&gt;b1(18)，即第三轮仅比较了两次就确定了当前的最小值——10。</p><p>每次确定最小值所需的比较次数变为了树的高度，而树的高度就是log2(m)向上取整(以2为底m的对数向上取整)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330161906.png" alt="image-20210330161906846"></p><h3 id="置换-选择排序——优化r"><a href="#置换-选择排序——优化r" class="headerlink" title="置换-选择排序——优化r"></a>置换-选择排序——优化r</h3><ul><li>置换-选择排序：设初始待排序文件为FI，初始归并段文件为FO，内存工作区为WA，内存工作区可容纳w个记录<ol><li>从待排序文件FI输入w个记录到工作区WA中</li><li>从内存工作区WA中选出其中关键字取最小值的记录，记为MINIMAX</li><li>将MINIMAX记录输出到FO中</li><li>若FI未读完，则从FI输入下一个记录到WA中</li><li>从WA中所有关键字比MINMAX记录的关键字大的记录中选出最小的关键字记录，作为新的MINIMAX</li><li>重复3.~5.直到WA中选不出新的MINIMAX记录位置，由此得到一个初始归并段，输出一个归并段的结束标志到FO中</li><li>重复2.~6.直到WA为空，由此得到全部初始归并段</li></ol></li><li>排序结束之后，得到了若干个大小不等的初始归并段</li></ul><table><thead><tr><th align="right">输入文件FI</th><th>内存工作区WA</th><th>MINIMAX</th><th align="left">输出文件FO</th><th>动作</th></tr></thead><tbody><tr><td align="right">17, 21, 05, 44, 10, 12, 56, 32, 29</td><td></td><td></td><td align="left"></td><td></td></tr><tr><td align="right">44, 10, 12, 56, 32, 29</td><td>17, 21, 05</td><td></td><td align="left"></td><td>读入17, 21, 05到工作区WA中</td></tr><tr><td align="right">10, 12, 56, 32, 29</td><td>17, 21, 44</td><td>05</td><td align="left">05</td><td>输出05到FO中，读入44到WA中</td></tr><tr><td align="right">12, 56, 32, 29</td><td>10, 21, 44</td><td>05-&gt;17</td><td align="left">05, 17</td><td>输出17到FO中，读入10到WA中</td></tr><tr><td align="right">56, 32, 29</td><td>10, 12, 44</td><td>17-&gt;21</td><td align="left">05, 17, 21</td><td>输出21到FO中，读入12到WA中</td></tr><tr><td align="right">32, 29</td><td>10, 12, 56</td><td>21-&gt;44</td><td align="left">05, 17, 21, 44</td><td>输出44到FO中，读入56到WA中</td></tr><tr><td align="right">29</td><td>10, 12, 32</td><td>44-&gt;56</td><td align="left">05, 17, 21, 44, 56</td><td>输出56到FO中，读入32到WA中</td></tr><tr><td align="right">29</td><td>10, 12, 32</td><td></td><td align="left">05, 17, 21, 44, 56, #</td><td>没有比56大的关键字，输出归并段结束标志#到FO中，MNIMAX置空</td></tr><tr><td align="right"></td><td>29, 12, 32</td><td>10</td><td align="left">10</td><td>输出10到FO中，读入29到WA中</td></tr><tr><td align="right"></td><td>29, $, 32</td><td>10-&gt;12</td><td align="left">10, 12</td><td>输出12到FO中</td></tr><tr><td align="right"></td><td>$, $, 32</td><td>12-&gt;29</td><td align="left">10, 12, 29</td><td>输出29到FO中</td></tr><tr><td align="right"></td><td></td><td>29-&gt;32</td><td align="left">10, 12, 29, 32</td><td>输出32到FO中</td></tr><tr><td align="right"></td><td></td><td></td><td align="left">10, 12, 29, 32, #</td><td>FI为空、WA为空，置换-选择排序结束，输出归并段结束标志#到FO中</td></tr></tbody></table><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>归并树：用来描述m归并，并只有度为0和度为m的结点的严格m叉树(m路归并可以用一棵m叉树描述)。</p><p>设由置换-选择排序得到了9个初始归并段，他们的记录长度依次为：9, 30, 12, 18, 3, 17, 2, 6, 24</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330170636.png" alt="普通归并树"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330171100.png" alt="最佳归并树——哈夫曼树"></p><p>当叶子结点数不够时，需要增加权值为0的结点用来构造哈夫曼树</p><p>设由置换-选择排序得到了8个初始归并段，其记录的长度依次为9, 12, 18, 3, 17, 2, 6, 24</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330171619.png" alt="image-20210330171619424"></p><ul><li>需要补充的虚段个数：设度为0的结点有n0个，度为m的结点由Nm个，则对严格的m叉树有n0=(m-1)Nm+1，即得Nm=(n0-1)/(m-1)——可以被整除<ul><li>若(n0-1)%(m-1)==0，则说明对于这个n0个叶子结点(初始归并段)可以构造m叉树归并树</li><li>若(n0-1)%(m-1)=u≠0，则说明对于这个n0个叶子结点(初始归并段)，其中有u个多余结点——多出u个结点时，需要补充m-u-1个结点</li></ul></li></ul><p>例如有10个叶子结点时，做3路归并排序：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330172918.png" alt="image-20210330172918028"></p><p>m-u-1：将某个叶子结点新补充为一个m叉树，“-1”减去原叶子结点，“-u”减去多余的叶子结点，m-u-1则为这棵新补充的m叉树还需要的虚段结点个数。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构实例</title>
      <link href="2021/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/"/>
      <url>2021/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="SqList-静态分配的顺序表"><a href="#SqList-静态分配的顺序表" class="headerlink" title="SqList-静态分配的顺序表"></a>SqList-静态分配的顺序表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">//暂且宏定义为int类型，防止报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125; SqList;                   <span class="comment">//静态分配的方式定义顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“静态分配顺序表”的基本操作函数</span></span><br><span class="line"><span class="comment"> *  不做特殊说明，第i个位置都是指的位序(从1开始)，而不是下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的元素的值</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他常用操作：</span></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(SqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  下面是对上述定义的函数的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化长度为0</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//赋默认值部分可以省略，因为规范使用的时候不会访问到没初始化的部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;  <span class="comment">//根据ElemType的类型赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//静态分配的数组是不能手动回收的</span></span><br><span class="line">    <span class="comment">//静态分配的顺序表中的数据域是静态分配的数组，需要等到程序结束后自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//i取值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L.length &gt;= MaxSize) &#123;</span><br><span class="line">        <span class="comment">//顺序表已满，无法插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        <span class="comment">//第i个位置及之后的所有元素都后移一位</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//结束条件是j&gt;=i</span></span><br><span class="line">        <span class="comment">//所以最后执行的时候是 L.data[i]=L.data[i-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;  <span class="comment">//第i个位置，下标为[i-1]，替换为e</span></span><br><span class="line">    L.length++;         <span class="comment">//增加成功，长度++</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];  <span class="comment">//引用型变量e得到删除位置的元素的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        <span class="comment">//第i个位置以后的元素都统一前移一个位置</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">        <span class="comment">//开始条件是j=i</span></span><br><span class="line">        <span class="comment">//开始的时候[i-1]=[i]，所以后面的往前</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;     <span class="comment">//删除成功，长度--</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历顺序表，返回遇到的第一个值匹配的位序</span></span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//位序=下标+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当没找到的时候，返回0；位序从1开始取值，不会是0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的元素的值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="comment">//i值不合法，无法返回相应位置的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//此处需视具体情况而定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; L.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SeqList-动态分配的顺序表"><a href="#SeqList-动态分配的顺序表" class="headerlink" title="SeqList-动态分配的顺序表"></a>SeqList-动态分配的顺序表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10     <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">//暂且宏定义为int类型，防止报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;         <span class="comment">//动态数组存放数据元素，此处是指针位置</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;            <span class="comment">//动态顺序表的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125; SeqList;                  <span class="comment">//动态分配的方式定义顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“动态分配顺序表”的基本操作函数</span></span><br><span class="line"><span class="comment"> *  不做特殊说明，第i个位置指的都是位序(从1开始)，而不是下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SeqList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增长动态数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IncreaseList</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的元素的值</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他常用操作：</span></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SeqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SeqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(SeqList L)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  下面是对上述定义的函数的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);</span><br><span class="line">    <span class="keyword">if</span> (L.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//删除动态分配的顺序表时，需要free掉动态分配的data数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(L.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增长动态数组的长度</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)，因为要把原来的所有数据转移到新的存储空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IncreaseList</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ElemType *p = L.data;</span><br><span class="line">    L.data = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * (L.MaxSize + length));</span><br><span class="line">    <span class="keyword">if</span> (L.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];   <span class="comment">//转移原本的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize++;</span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//删除原来的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L.length &gt;= L.MaxSize) &#123;</span><br><span class="line">        <span class="comment">//当达到存储空间上界的时候，扩大存储空间</span></span><br><span class="line">        <span class="keyword">if</span> (IncreaseList(L, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的元素的值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//视ElemType数据类型的具体情况而定，越界行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; L.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkList-带头结点的单链表"><a href="#LinkList-带头结点的单链表" class="headerlink" title="LinkList-带头结点的单链表"></a>LinkList-带头结点的单链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">//宏定义为int以免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span>  <span class="comment">//定义单链表结点类型——结点</span></span><br><span class="line">    ElemType data;      <span class="comment">//每个结点存放一个数据元素——数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个结点——指针域</span></span><br><span class="line">&#125; LNode, *LinkList;     <span class="comment">//LinkList指向单链表的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“带头结点的单链表”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表，从vector容器中依次添加对应值的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateList</span><span class="params">(LinkList &amp;L, <span class="built_in">vector</span>&lt;ElemType&gt; elems)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定结点的后插操作</span></span><br><span class="line"><span class="comment">// 后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的结点</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetNode</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转单链表——递归反转，若是带头结点的单链表，使用时需要用head-&gt;next</span></span><br><span class="line"><span class="function">LNode *<span class="title">ListReverseRecursion</span><span class="params">(LNode *head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转单链表——调用 “递归反转”</span></span><br><span class="line"><span class="function">LNode *<span class="title">ListReverse</span><span class="params">(LNode *head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现上述所定义对于“带头结点的单链表”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表，从vector容器中依次添加对应值的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateList</span><span class="params">(LinkList &amp;L, <span class="built_in">vector</span>&lt;ElemType&gt; elems)</span> </span>&#123;</span><br><span class="line">    InitList(L);    <span class="comment">//初始化单链表</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elems.size(); i++) &#123;</span><br><span class="line">        LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;data = elems[i]; <span class="comment">//新结点赋值</span></span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//新结点指向NULL</span></span><br><span class="line">        p-&gt;next = s;        <span class="comment">//表尾指向新结点</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指向新表尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//L本身就是空，没法销毁</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    LNode *pre = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pre);      <span class="comment">//删除pre所指向的结点</span></span><br><span class="line">        pre = p;        <span class="comment">//pre指向pre下一个结点</span></span><br><span class="line">        p = p-&gt;next;    <span class="comment">//p指向p下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除到最后时，pre-&gt;next=NULL，但是pre!=NULL</span></span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定结点的后插操作</span></span><br><span class="line"><span class="comment">// 后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把当前结点看做新插入的结点，然后新建一个结点，交换值</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位查找操作。获取表L中第i个位置的结点</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetNode</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果此时count=i，那么这就是第i个位置的结点</span></span><br><span class="line">    <span class="comment">//如果此时p==NULL，那么返回的就是NULL</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作。在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定位到第i-1个位置</span></span><br><span class="line">    LNode *p = GetNode(L, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在第i-1个位置后面插入，则新插入的是第i个位置</span></span><br><span class="line">    InsertNextNode(p, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p = GetNode(L, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//第i个位置为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时p是第i-1个位置的结点</span></span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">//q是第i个位置的结点</span></span><br><span class="line">    e = q-&gt;data;        <span class="comment">//e储存此结点的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//第i-1个结点指向后一个结点</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">//删除第i个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == e) &#123;</span><br><span class="line">        <span class="comment">//是找到了所以离开了循环，返回位置</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最后也没找到匹配的结点，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转单链表——递归反转，若是带头结点的单链表，使用时需要用head-&gt;next</span></span><br><span class="line"><span class="function">LNode *<span class="title">ListReverseRecursion</span><span class="params">(LNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *node = ListReverseRecursion(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转单链表——调用 “递归反转”</span></span><br><span class="line"><span class="function">LNode *<span class="title">ListReverse</span><span class="params">(LNode *head)</span> </span>&#123;</span><br><span class="line">    ListReverseRecursion(head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求表长。返回线性表L的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空操作，若L为空表，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="SqStack——顺序栈"><a href="#SqStack——顺序栈" class="headerlink" title="SqStack——顺序栈"></a>SqStack——顺序栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;                <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“顺序栈”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序栈”的基本操作函数(1)</span></span><br><span class="line"><span class="comment"> *  初始化栈时使用 S.top=-1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时栈为空，若top指向0，则会访问到脏内存</span></span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序栈使用静态数组，自动销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据还留存在数组(栈的数据域)内，只是逻辑上被删除了(无法被访问到)</span></span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///**</span></span><br><span class="line"><span class="comment">// *  实现对于“顺序栈”的基本操作函数(2)</span></span><br><span class="line"><span class="comment">// *  初始化栈时使用 S.top=0;</span></span><br><span class="line"><span class="comment">// */</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="comment">//void InitStack(SqStack &amp;S) &#123;</span></span><br><span class="line"><span class="comment">//    // 初始时栈为空，使用S.top=0，则其他函数也需要做出一定修改</span></span><br><span class="line"><span class="comment">//    S.top = 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="comment">//void DestroyStack(SqStack &amp;S) &#123;</span></span><br><span class="line"><span class="comment">//    // 顺序栈使用静态数组，自动销毁</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="comment">//bool Push(SqStack &amp;S, ElemType x) &#123;</span></span><br><span class="line"><span class="comment">//    if (S.top == MaxSize) &#123;</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    S.data[S.top] = x;</span></span><br><span class="line"><span class="comment">//    S.top++;</span></span><br><span class="line"><span class="comment">//    return true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="comment">//bool Pop(SqStack &amp;S, ElemType &amp;x) &#123;</span></span><br><span class="line"><span class="comment">//    if (StackEmpty(S)) &#123;</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // 数据还留存在数组(栈的数据域)内，只是逻辑上被删除了(无法被访问到)</span></span><br><span class="line"><span class="comment">//    S.top--;</span></span><br><span class="line"><span class="comment">//    x = S.data[S.top];</span></span><br><span class="line"><span class="comment">//    return true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="comment">//bool GetTop(SqStack S, ElemType &amp;x) &#123;</span></span><br><span class="line"><span class="comment">//    if (StackEmpty(S)) &#123;</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    x = S.data[S.top - 1];</span></span><br><span class="line"><span class="comment">//    return true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="comment">//bool StackEmpty(SqStack S) &#123;</span></span><br><span class="line"><span class="comment">//    if (S.top == 0) &#123;</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ShStack——共享栈"><a href="#ShStack——共享栈" class="headerlink" title="ShStack——共享栈"></a>ShStack——共享栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top0;               <span class="comment">// 栈0的栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top1;               <span class="comment">// 栈1的栈顶指针</span></span><br><span class="line">&#125; ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“共享栈”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(ShStack &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="comment">//bool Push(ShStack &amp;S, ElemType x);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="comment">//bool Pop(ShStack &amp;S, ElemType &amp;x);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="comment">//bool GetTop(ShStack S, ElemType &amp;x);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(ShStack S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为满。若S已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“共享栈”的基本操作函数(1)</span></span><br><span class="line"><span class="comment"> *  初始化栈时使用 S.top0=-1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时栈为空，若top指向0，则会访问到脏内存</span></span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(ShStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序栈使用静态数组，自动销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(ShStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top0 == <span class="number">-1</span> &amp;&amp; S.top1 == MaxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为满。若S已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top0 + <span class="number">1</span> == S.top1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkStack——链栈"><a href="#LinkStack——链栈" class="headerlink" title="LinkStack——链栈"></a>LinkStack——链栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">//宏定义为int以免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;          <span class="comment">// 用静态数组存放栈中元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“链栈(不带头结点)”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(LinkStack &amp;head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStack &amp;head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack &amp;head, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;head, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(LinkStack &amp;head, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“链栈(不带头结点)”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈。构造一个空栈S，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;head)</span> </span>&#123;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈。销毁并释放栈S所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(LinkStack &amp;head)</span> </span>&#123;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(head)) &#123;</span><br><span class="line">        Pop(head, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个栈S是否为空。若S为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStack &amp;head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈。若栈S未满，则将x加入使之成为新栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack &amp;head, ElemType x)</span> </span>&#123;</span><br><span class="line">    LinkNode *node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = x;</span><br><span class="line">    node-&gt;next = head;</span><br><span class="line">    head = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈。若栈S非空，则弹出栈顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;head, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = head-&gt;data;</span><br><span class="line">    LinkNode *p = head;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素。若栈S非空，则用x返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(LinkStack &amp;head, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = head-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="SqQueue——顺序队列"><a href="#SqQueue——顺序队列" class="headerlink" title="SqQueue——顺序队列"></a>SqQueue——顺序队列</h3><h4 id="牺牲一个存储单元"><a href="#牺牲一个存储单元" class="headerlink" title="牺牲一个存储单元"></a>牺牲一个存储单元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10      <span class="comment">// 定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front;              <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;               <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> *  使用Q.front=0;Q.rear=0初始化队列</span></span><br><span class="line"><span class="comment"> *  使用Q.front==Q.rear;判断队列是否为空</span></span><br><span class="line"><span class="comment"> *  这种操作使得顺序队列的实际存储空间为MaxSize-1，即牺牲了一个存储单元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时，队头队尾指针都指向0</span></span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear + MaxSize - Q.front) % MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用size解决牺牲问题"><a href="#使用size解决牺牲问题" class="headerlink" title="使用size解决牺牲问题"></a>使用size解决牺牲问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10      <span class="comment">// 定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front;              <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;               <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">int</span> size;   <span class="comment">// 记录队列元素个数，解决了牺牲一个存储单元的问题(一)</span></span><br><span class="line">    <span class="comment">// 队空时size==0; 队满时size==MaxSize;</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> *  在SqQueue中增加了size记录元素个数，解决了牺牲存储单元的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    Q.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.size == MaxSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用tag解决牺牲问题"><a href="#使用tag解决牺牲问题" class="headerlink" title="使用tag解决牺牲问题"></a>使用tag解决牺牲问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10      <span class="comment">// 定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front;              <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;               <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="comment">// 队空时size==0; 队满时size==MaxSize;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">        del = <span class="number">0</span>, ins = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Tag tag;    <span class="comment">// 最近进行的是删除(0)还是插入操作(1)，解决牺牲存储单元的问题(二)</span></span><br><span class="line">    <span class="comment">// 队空时 front==rear &amp;&amp; tag==del;</span></span><br><span class="line">    <span class="comment">// 队满时 front==rear &amp;&amp; tag==ins;</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> *  在SqQueue中增加了tag记录最近的操作类型，解决了牺牲存储单元的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    Q.tag = SqQueue::del;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.tag = SqQueue::ins;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.tag = SqQueue::del;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear &amp;&amp; Q.tag == SqQueue::del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否已满。若Q已满，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueFull</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear &amp;&amp; Q.tag == SqQueue::ins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列Q中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElemNum</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear + MaxSize - Q.front) % MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkQueue——链式队列"><a href="#LinkQueue——链式队列" class="headerlink" title="LinkQueue——链式队列"></a>LinkQueue——链式队列</h3><p>不带头结点的链式队列</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by LeoK77 on 2021/4/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int    <span class="comment">// ElemType定义为int避免报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front;    <span class="comment">// 队头指针，删除操作</span></span><br><span class="line">    LinkNode *rear;     <span class="comment">// 队尾指针，插入操作</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“链式队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q, ElemType &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“链式队列”的基本操作函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列。构造一个空队列Q，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列。销毁并释放队列Q所占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">        ElemType e;</span><br><span class="line">        DeQueue(Q, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列。若队列Q未满，则将x加入使之成为新队列顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    LinkNode *node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = x;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        Q.rear = node;</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = node;</span><br><span class="line">        Q.rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列。若队列Q非空，则弹出队列顶元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        Q.front = <span class="literal">nullptr</span>;</span><br><span class="line">        Q.rear = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LinkNode *p = Q.front;</span><br><span class="line">        Q.front = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列顶元素。若队列Q非空，则用x返回队列顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个队列Q是否为空。若Q为空，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">nullptr</span> &amp;&amp; Q.rear == <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        EnQueue(Q, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElemType e;</span><br><span class="line">    GetHead(Q, e);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">        ElemType e;</span><br><span class="line">        DeQueue(Q, e);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="SqString——顺序串-静态分配"><a href="#SqString——顺序串-静态分配" class="headerlink" title="SqString——顺序串(静态分配)"></a>SqString——顺序串(静态分配)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255  <span class="comment">// 预定义最大串长为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];    <span class="comment">// 每个分量存储一个字符</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125; SqString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“顺序串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(SqString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrCopy</span><span class="params">(SqString &amp;T, SqString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(SqString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(SqString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(SqString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(SqString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(SqString &amp;T, SqString S1, SqString S2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SqString S, SqString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SqString S, SqString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“顺序串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(SqString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; MAXLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        T.ch[i] = chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrCopy</span><span class="params">(SqString &amp;T, SqString S)</span> </span>&#123;</span><br><span class="line">    T.length = S.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        T.ch[i] = S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(SqString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(SqString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(SqString &amp;S)</span> </span>&#123;</span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(SqString &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态数组，自动回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(SqString &amp;T, SqString S1, SqString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S1.length + S2.length &gt; MAXLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = S1.length + S2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.length; i++) &#123;</span><br><span class="line">        T.ch[i] = S1.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S2.length; i++) &#123;</span><br><span class="line">        T.ch[i + S1.length] = S2.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SqString S, SqString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length - T.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> equalFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.ch[i + j] != T.ch[j]) &#123;</span><br><span class="line">                equalFlag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (equalFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SqString S, SqString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length &amp;&amp; i &lt; T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印操作。将串的内容打印到屏幕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">(SqString S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.length &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch_1[] = &#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch_2[] = &#123;<span class="string">&quot; World&quot;</span>&#125;;</span><br><span class="line">    SqString S_1;</span><br><span class="line">    StrAssign(S_1, ch_1, <span class="number">5</span>);</span><br><span class="line">    printStr(S_1);</span><br><span class="line">    SqString S_2;</span><br><span class="line">    StrAssign(S_2, ch_2, <span class="number">6</span>);</span><br><span class="line">    printStr(S_2);</span><br><span class="line">    SqString T;</span><br><span class="line">    StrCopy(T, S_1);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Concat(T, T, S_2);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Index(T, S_2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SqDyString——顺序串-动态分配"><a href="#SqDyString——顺序串-动态分配" class="headerlink" title="SqDyString——顺序串(动态分配)"></a>SqDyString——顺序串(动态分配)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 255    <span class="comment">// 串的初始长度预分配为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqDyString</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch&#123;&#125;;             <span class="comment">// 每个分量存储一个字符</span></span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">0</span>;        <span class="comment">// 串的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;         <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125; SqDyString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“动态分配的顺序串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作。给串分配存储空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStr</span><span class="params">(SqDyString &amp;T, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新分配大小。若length&gt;maxSize则重新分配，否则不分配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrResizeOrNot</span><span class="params">(SqDyString &amp;T, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(SqDyString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrCopy</span><span class="params">(SqDyString &amp;T, SqDyString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(SqDyString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(SqDyString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(SqDyString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(SqDyString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(SqDyString &amp;T, SqDyString S1, SqDyString S2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SqDyString S, SqDyString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SqDyString S, SqDyString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“动态分配的顺序串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作。给串分配存储空间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStr</span><span class="params">(SqDyString &amp;T, <span class="keyword">int</span> length = INITSIZE)</span> </span>&#123;</span><br><span class="line">    T.maxSize = length;</span><br><span class="line">    T.length = <span class="number">0</span>;</span><br><span class="line">    T.ch = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * T.maxSize);</span><br><span class="line">    <span class="keyword">if</span> (T.ch == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新分配大小。若length&gt;maxSize则重新分配，否则不分配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrResizeOrNot</span><span class="params">(SqDyString &amp;T, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; T.maxSize) &#123;</span><br><span class="line">        <span class="built_in">free</span>(T.ch);</span><br><span class="line">        <span class="keyword">return</span> InitStr(T, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(SqDyString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StrResizeOrNot(T, length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        T.ch[i] = chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrCopy</span><span class="params">(SqDyString &amp;T, SqDyString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StrResizeOrNot(T, S.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = S.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        T.ch[i] = S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(SqDyString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(SqDyString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(SqDyString &amp;S)</span> </span>&#123;</span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(SqDyString &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态数组，free释放</span></span><br><span class="line">    <span class="built_in">free</span>(S.ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(SqDyString &amp;T, SqDyString S1, SqDyString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StrResizeOrNot(T, S1.length + S2.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = S1.length + S2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.length; i++) &#123;</span><br><span class="line">        T.ch[i] = S1.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S2.length; i++) &#123;</span><br><span class="line">        T.ch[i + S1.length] = S2.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SqDyString S, SqDyString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length - T.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> equalFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.ch[i + j] != T.ch[j]) &#123;</span><br><span class="line">                equalFlag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (equalFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SqDyString S, SqDyString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length &amp;&amp; i &lt; T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印操作。将串的内容打印到屏幕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">(SqDyString S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.length &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch_1[] = &#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch_2[] = &#123;<span class="string">&quot; World&quot;</span>&#125;;</span><br><span class="line">    SqDyString S_1;</span><br><span class="line">    InitStr(S_1);</span><br><span class="line">    StrAssign(S_1, ch_1, <span class="number">5</span>);</span><br><span class="line">    printStr(S_1);</span><br><span class="line">    SqDyString S_2;</span><br><span class="line">    InitStr(S_2);</span><br><span class="line">    StrAssign(S_2, ch_2, <span class="number">6</span>);</span><br><span class="line">    printStr(S_2);</span><br><span class="line">    SqDyString T;</span><br><span class="line">    InitStr(T);</span><br><span class="line">    StrCopy(T, S_1);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Concat(T, T, S_2);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Index(T, S_2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkString——链式串"><a href="#LinkString——链式串" class="headerlink" title="LinkString——链式串"></a>LinkString——链式串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> val;               <span class="comment">// 字符值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个结点</span></span><br><span class="line">&#125; *LinkString;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义对于“带头结点的链式串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作。初始化头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStr</span><span class="params">(LinkString &amp;T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(LinkString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrCopy</span><span class="params">(LinkString &amp;T, LinkString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(LinkString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(LinkString S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(LinkString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(LinkString &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(LinkString &amp;T, LinkString S1, LinkString S2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(LinkString S, LinkString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(LinkString S, LinkString T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实现对于“带头结点的链式串”的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作。初始化头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStr</span><span class="params">(LinkString &amp;T)</span> </span>&#123;</span><br><span class="line">    T = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;val = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    T-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrAssign</span><span class="params">(LinkString &amp;T, <span class="keyword">char</span> chars[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptr = T;</span><br><span class="line">    LinkNode *node;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;val = chars[i];</span><br><span class="line">        ptr-&gt;next = node;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。把串S复制得到串T</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrCopy</span><span class="params">(LinkString &amp;T, LinkString S)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptrT = T;</span><br><span class="line">    LinkNode *ptrS = S-&gt;next;</span><br><span class="line">    LinkNode *node;</span><br><span class="line">    <span class="keyword">while</span> (ptrS) &#123;</span><br><span class="line">        node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;val = ptrS-&gt;val;</span><br><span class="line">        ptrT-&gt;next = node;</span><br><span class="line">        ptrT = ptrT-&gt;next;</span><br><span class="line">        ptrS = ptrS-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StrEmpty</span><span class="params">(LinkString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;next == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(LinkString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StrEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    LinkNode *ptr = S-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearString</span><span class="params">(LinkString &amp;S)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptr = S;</span><br><span class="line">    LinkNode *node;</span><br><span class="line">    <span class="keyword">while</span> (ptr-&gt;next) &#123;</span><br><span class="line">        node = ptr-&gt;next;</span><br><span class="line">        ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁(回收存储空间)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString</span><span class="params">(LinkString &amp;S)</span> </span>&#123;</span><br><span class="line">    ClearString(S);</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串连接。用T返回由S1和S2连接形成的新串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(LinkString &amp;T, LinkString S1, LinkString S2)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptrT = T;</span><br><span class="line">    LinkNode *ptrS = S1-&gt;next;</span><br><span class="line">    LinkNode *node;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptrS) &#123;</span><br><span class="line">        node = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;val = ptrS-&gt;val;</span><br><span class="line">        ptrT-&gt;next = node;</span><br><span class="line">        ptrT = ptrT-&gt;next;</span><br><span class="line">        ptrS = ptrS-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (ptrS == <span class="literal">nullptr</span> &amp;&amp; !flag) &#123;</span><br><span class="line">            ptrS = S2-&gt;next;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(LinkString S, LinkString T)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptrS = S-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptrS) &#123;</span><br><span class="line">        LinkNode *ptrT = T-&gt;next;</span><br><span class="line">        LinkNode *ptrStmp = ptrS;</span><br><span class="line">        <span class="keyword">bool</span> findFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptrT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptrStmp-&gt;val != ptrT-&gt;val) &#123;</span><br><span class="line">                findFlag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptrStmp = ptrStmp-&gt;next;</span><br><span class="line">            ptrT = ptrT-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (ptrT != <span class="literal">nullptr</span> &amp;&amp; ptrStmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        ptrS = ptrS-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(LinkString S, LinkString T)</span> </span>&#123;</span><br><span class="line">    LinkNode *ptrS = S-&gt;next;</span><br><span class="line">    LinkNode *ptrT = T-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptrS &amp;&amp; ptrT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrS-&gt;val != ptrT-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> ptrS-&gt;val - ptrT-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ptrS = ptrS-&gt;next;</span><br><span class="line">        ptrT = ptrT-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptrS == <span class="literal">nullptr</span> &amp;&amp; ptrT == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptrS == <span class="literal">nullptr</span> &amp;&amp; ptrT != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印操作。将串的内容打印到屏幕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">(LinkString S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrLength(S) &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">    LinkNode *ptrS = S-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptrS) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ptrS-&gt;val;</span><br><span class="line">        ptrS = ptrS-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch_1[] = &#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch_2[] = &#123;<span class="string">&quot; World&quot;</span>&#125;;</span><br><span class="line">    LinkString S_1;</span><br><span class="line">    InitStr(S_1);</span><br><span class="line">    StrAssign(S_1, ch_1, <span class="number">5</span>);</span><br><span class="line">    printStr(S_1);</span><br><span class="line">    LinkString S_2;</span><br><span class="line">    InitStr(S_2);</span><br><span class="line">    StrAssign(S_2, ch_2, <span class="number">6</span>);</span><br><span class="line">    printStr(S_2);</span><br><span class="line">    LinkString T;</span><br><span class="line">    InitStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCopy(T, S_1);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Concat(T, T, S_2);</span><br><span class="line">    printStr(T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrCompare(S_1, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Index(T, S_2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第二章-线性表</title>
      <link href="2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><h2 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表：具有<strong>相同的数据类型</strong>的n(n&gt;=0)个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为L=(a1, a2, ……, ai, ai+1, ……, an)</p><ul><li>线性表的特性：<ul><li>相同的数据类型：每个数据元素所占空间一样大，便于查找</li><li>序列：有次序</li><li>有限：数据元素的数量有限，不能无限</li></ul></li></ul><ol><li>位序：ai是线性表中”第i个”个元素线性表中的位序；位序从1开始，数组下标从0开始</li><li>表头元素：a1</li><li>表尾元素：an</li><li>除了第一个元素以外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继</li></ol><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitList(&amp;L): 初始化表。构造一个空的线性表L，分配内存空间</span><br><span class="line">DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span><br><span class="line"></span><br><span class="line">ListInsert(&amp;L, i, e): 插入操作。在表L中的第i个位置上插入指定元素e</span><br><span class="line">ListDelete(&amp;L, i, &amp;e): 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</span><br><span class="line"></span><br><span class="line">LocateElem(L, e): 按值查找操作。在表L中查找具有给定关键字值的元素</span><br><span class="line">GetElem(L, i): 按位查找操作。获取表L中第i个位置的元素的值</span><br><span class="line"></span><br><span class="line">其他常用操作：</span><br><span class="line">Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数</span><br><span class="line">PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值</span><br><span class="line">Empty(L): 判空操作，若L为空表，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p>Tips:</p><ol><li>对数据的操作(记忆思路)——创销、增删改查</li><li>C语言函数的定义——&lt;返回值类型&gt; 函数名(&lt;参数1类型&gt; 参数1, &lt;参数2类型&gt; 参数2)</li><li>实际开发中，可根据自己的实际需求定义其他的基本操作</li><li>函数名和参数的形式、命名都可改名，但是命名要有可读性</li><li>什么时候要传入引用”&amp;”——对参数的修改结果需要”带回来”</li></ol></li><li><p>为什么要实现对数据结构的基本操作</p><ol><li>团队合作编程，你定义的数据结构要让别人能够很方便的使用(封装)</li><li>将常用的操作/运算封装成函数，避免重复工作，降低出错风险</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324164457.png" alt="image-20210324164457399"></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><blockquote><p>顺序表的优点：可随机存取，存储密度高<br>缺点：要求大片连续空间，改变容量不方便</p></blockquote><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>顺序表——用顺序存储的方式实现线性表</p><ul><li>顺序表存储的内容在内存中的存放位置：<ul><li>不妨设线性表的第一个元素的存放位置是”LOC(L)”(LOC时location的缩写)</li><li>那么第二个元素的存放位置就是”LOC(L)+数据元素的大小”<ul><li>数据元素的大小：C语言中可以使用sizeof(ElemType)，ElemType是元素类型</li></ul></li><li>第n个元素的存放位置就是”LOC(L)+(n-1)*数据元素的大小”</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配的方式实现顺序表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10          <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SqList;                   <span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br><span class="line"><span class="comment">//Sq：sequence——顺序，序列</span></span><br><span class="line"><span class="comment">//这种方式给各个数据元素分配连续的存储空间，大小为 MaxSize*sizeof(ElemType)</span></span><br></pre></td></tr></table></figure><p>如果静态分配的顺序表存满了怎么办：放弃治疗。顺序表的表长刚开始确定后就无法更改(存储空间是静态的，不可改变大小)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配顺序表的实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10          <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];      <span class="comment">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SqList;                   <span class="comment">//顺序表的类型定义(惊呆分配方式)</span></span><br><span class="line"><span class="comment">//Sq：sequence——顺序，序列</span></span><br><span class="line"><span class="comment">//这种方式给各个数据元素分配连续的存储空间，大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有数据元素设置为默认值——可省略</span></span><br><span class="line">    <span class="comment">//如果不设置数据元素的默认值，会因为内存中遗留的&quot;脏数据&quot;而无法确定访问结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;       <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;           <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);    <span class="comment">//初始化顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态分配的方式实现顺序表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10     <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//指针指向顺序表的第一个元素</span></span><br><span class="line">    ElemType *data;     <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;        <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SeqList;              <span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态申请和释放内存空间</span></span><br><span class="line"><span class="comment">//malloc动态申请内存空间——返回指针，需要强制转换类型为数据元素类型指针</span></span><br><span class="line">L.data = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);</span><br><span class="line"><span class="comment">//free释放内存空间——释放存储空间</span></span><br><span class="line"><span class="built_in">free</span>(L.data)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态分配顺序表的实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10     <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;        <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SeqList;              <span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化动态分配的顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * InitSize);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (L.MaxSize + len));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];   <span class="comment">//将数据复制到新区域——时间开销大</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;    <span class="comment">//顺序表的最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqList L;                  <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);                <span class="comment">//初始化顺序表</span></span><br><span class="line">    IncreaseSize(L, <span class="number">5</span>);     <span class="comment">//增长顺序表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顺序表的特点：<ol><li>随机访问，即可以在O(1)时间内找到第i个元素(以数组的形式存储元素)</li><li>存储密度高，每个节点只存储数据元素</li><li>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</li><li>插入、删除操作不方便，需要移动大量元素</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324172931.png" alt="image-20210324172931333"></p><h3 id="顺序表的插入删除"><a href="#顺序表的插入删除" class="headerlink" title="顺序表的插入删除"></a>顺序表的插入删除</h3><p>ListInsert(&amp;L, i, e): 插入操作。在表L中的第i个位置上插入指定元素e</p><p>ListDelete(&amp;L, i, &amp;e): 删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配的插入操作</span></span><br><span class="line"><span class="comment">//在第i个位置(i是位序)插入元素e</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L.length &gt;= MaxSize) &#123;</span><br><span class="line">        <span class="comment">//当前存储空间已满，无法插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将第i个元素及以后的元素后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;  <span class="comment">//在位置i处放下e</span></span><br><span class="line">    L.length++;         <span class="comment">//长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态分配的删除操作</span></span><br><span class="line"><span class="comment">//删除第i个位置(i是位序)的元素</span></span><br><span class="line"><span class="comment">//时间复杂度是O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];      <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--; <span class="comment">//线性表长度减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324182548.png" alt="image-20210324182548034"></p><h3 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h3><p>GetElem(L, i)：按位查找操作。获取表L中的第i个位置的元素的值</p><p>LocateElem(L, e): 按值查找操作。在表L中查找具有给定关键字值的元素</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配的查找操作</span></span><br><span class="line"><span class="comment">//查找第i个位置(i是位序)的元素</span></span><br><span class="line"><span class="comment">//时间复杂度O(1)</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="comment">//实际处理时此处不可以无脑用false，因为false有可能会对应ElemType中的一个取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配的查找操作</span></span><br><span class="line"><span class="comment">//查找第i个位置(i是位序)的元素</span></span><br><span class="line"><span class="comment">//时间复杂度O(1)</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="comment">//实际处理时此处不可以无脑用false，因为false有可能会对应ElemType中的一个取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第i个元素——“随机存取”特性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态分配的查找操作</span></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素等于e的元素，并返回其位序</span></span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;   <span class="comment">//在C语言中，结构体的比较不能直接用==</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;   <span class="comment">//数据下标i的元素值为e，对应位序为i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//退出循环，查找失败，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324184747.png" alt="image-20210324184747319"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><p>单链表的优点：不要求大片连续空间，改变容量方便<br>缺点：不可随机存取，要耗费一定空间存放指针</p></blockquote><h4 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><p>单链表——用链式存储的方式实现线性表；除了存放数据元素外，还要存储指向下一个节点的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span>  <span class="comment">//定义单链表结点类型——结点</span></span><br><span class="line">    ElemType data;      <span class="comment">//每个结点存放一个数据元素——数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个结点——指针域</span></span><br><span class="line">&#125; LNode, *LinkList;     <span class="comment">//LinkList指向单链表的指针</span></span><br><span class="line"><span class="comment">//要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span></span><br><span class="line"><span class="comment">//下面两种声明指针的方式等价</span></span><br><span class="line">LNode *L;   <span class="comment">//声明一个指向单链表第一个结点的指针</span></span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表第一个结点的指针</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表(不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;       <span class="comment">//空链表，无任何结点，定义为NULL防止脏数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空(不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个单链表(带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;    <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空(带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324190748.png" alt="image-20210324190748764"></p><h4 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h4><p>ListInsert(&amp;L, i, e): 插入操作。在表L中的第i个位置上插入指定元素e</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位序插入(带头结点</span></span><br><span class="line"><span class="comment">//方法：找到第i-1个结点，将e插入其中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//判断i是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">//L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;    <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建结点s</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;        <span class="comment">//s结点的值赋值为e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//s结点指向第i个结点</span></span><br><span class="line">    p-&gt;next = s;        <span class="comment">//第i-1个结点指向s结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位序插入(不带头结点</span></span><br><span class="line"><span class="comment">//方法：找到第i-1个结点，将e插入其中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//插入第1个结点</span></span><br><span class="line">        LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;    <span class="comment">//s结点的值赋值为e</span></span><br><span class="line">        s-&gt;next = L;    <span class="comment">//s结点指向原来的第1个结点</span></span><br><span class="line">        L = s;          <span class="comment">//单链表第1个结点变为s</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">//当前p指向的是第几个结点——不带头结点，从1开始</span></span><br><span class="line">    p = L;      <span class="comment">//p指向第1个结点(不是头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;    <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建结点s</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;        <span class="comment">//s结点的值赋值为e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//s结点指向第i个结点</span></span><br><span class="line">    p-&gt;next = s;        <span class="comment">//第i-1个结点指向s结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InsertNextNode(LNode *p, ElemType e)：后插操作。在p结点之后插入元素e</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定结点的后插操作</span></span><br><span class="line"><span class="comment">//后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//p结点为空，不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;        <span class="comment">//s结点的值赋值为e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//s结点指向原本p指向的结点</span></span><br><span class="line">    p-&gt;next = s;        <span class="comment">//p结点指向s结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现后插操作之后，&quot;按位序插入操作&quot;方法的后半部分可以替换为&quot;后插操作&quot;</span></span><br><span class="line"><span class="comment">//按位序插入(带头结点</span></span><br><span class="line"><span class="comment">//方法：找到第i-1个结点，将e插入其中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//判断i是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">//L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> InsertNextNode(p, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InsertPriorNode(LNode *p, ElemType e)：前插操作。在p结点之前插入元素e</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//s结点指向p结点原本指向的结点</span></span><br><span class="line">    p-&gt;next = s;        <span class="comment">//p结点指向s结点</span></span><br><span class="line">    s-&gt;data = p-&gt;data;  <span class="comment">//s结点的值赋值为p结点的值</span></span><br><span class="line">    p-&gt;data = e;        <span class="comment">//p结点的值赋值为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListDelete(&amp;L, i, &amp;e): 按位序删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除单链表L的第i个结点(带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;   <span class="comment">//指针p指向第i个结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">//当前p指向第几个阶段</span></span><br><span class="line">    p = L;      <span class="comment">//L指向头结点，头结点是第0个结点(不存数据</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//第i-1个结点后面无其他结点，第i个结点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">//新建q结点指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;        <span class="comment">//e赋值为被删除结点的元素</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//p结点指向要被删除结点原本指向的阶段</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">//释放要被删除结点的内存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeleteNode(LNode *p)：指定结点的删除。删除指定结点p</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定结点的删除</span></span><br><span class="line"><span class="comment">//此种方法无法处理p是最后一个结点的情况</span></span><br><span class="line"><span class="comment">//遇到p是最后一个结点的情况，只能采用从头遍历的方式</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">//q结点指向p结点的后继结点</span></span><br><span class="line">    <span class="comment">//当p结点是最后一个结点时，下面会保存，因为q==NULL</span></span><br><span class="line">    p-&gt;data = q-&gt;data;  <span class="comment">//q结点的值和next指向都赋值给p结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//即将p结点的后继结点的所有属性都赋值给p结点</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">//释放p结点原本的后继结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324201742.png" alt="image-20210324201742762"></p><h4 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h4><p>GetElem(L, i): 按位查找操作。获取表L中第i个位置的元素的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素(带头结点</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">//L指向头结点，头结点是第0个结点(不存数据</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocateElem(L, e): 按值查找操作。在表L中查找具有给定关键字值的元素</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，返回数据域为e的结点</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到后返回该结点指针，找不到的话返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求表的长度(带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;    <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210324201655.png" alt="image-20210324201655439"></p><h4 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法建立单链表(带头结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;     <span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="keyword">int</span> x;                                  <span class="comment">//假设数据域是int类型</span></span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//建立头结点，初始化空表</span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;                           <span class="comment">//初始化为空链表</span></span><br><span class="line">    LNode *s, *r = L;                       <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;                     <span class="comment">//输入9999时结束</span></span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;    <span class="comment">//s结点的值赋值为输入的x</span></span><br><span class="line">        r-&gt;next = s;    <span class="comment">//r结点指向s结点</span></span><br><span class="line">        r = s;          <span class="comment">//r指向新的表尾结点——下一个新建结点或者最后添加的NULL</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//表尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法建立单链表(带头结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;        <span class="comment">//s结点的值赋值为输入的x</span></span><br><span class="line">        s-&gt;next = L-&gt;next;  <span class="comment">//s结点指向头结点指向的结点</span></span><br><span class="line">        L-&gt;next = s;        <span class="comment">//头结点指向s结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插法、尾插法：核心是<strong>初始化</strong>操作、<strong>指定结点的后插</strong>操作；尾插法需要设置一个指向表尾结点的指针</p><p>头插法的重要应用：单链表的逆置</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span>          <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span> <span class="comment">//指针域，一个指向前驱，一个指向后继</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//p结点没有后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//p结点的后继结点不是尾指针</span></span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//销毁所有后继结点</span></span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);    <span class="comment">//销毁头结点</span></span><br><span class="line">    L = <span class="literal">NULL</span>;   <span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210325153945.png" alt="image-20210325153945748"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环单链表与单链表的区别：</span></span><br><span class="line"><span class="comment">//单链表的尾结点指向NULL</span></span><br><span class="line"><span class="comment">//循环单链表的尾结点指向头结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L;    <span class="comment">//头结点的next指针指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头结点的next指针指向头结点的时候为空</span></span><br><span class="line">    <span class="keyword">return</span> L-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否是循环单链表L的尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next == L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表与循环双链表的区别</span></span><br><span class="line"><span class="comment">//双链表：头结点prior指向NULL，尾结点next指向NULL</span></span><br><span class="line"><span class="comment">//循环双链表：头结点prior指向尾结点，尾结点next指向头结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span>          <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span> <span class="comment">//指针域，一个指向前驱，一个指向后继</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;   <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;    <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当头结点的prior和next都指向头结点时为空</span></span><br><span class="line">    <span class="keyword">return</span> L-&gt;prior == L &amp;&amp; L-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否是循环双链表L的表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L, DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextNode</span><span class="params">(DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210325161059.png" alt="image-20210325161059205"></p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><blockquote><p>静态链表的优点：增删操作不需要大量移动元素<br>缺点：不能随机存取，只能从头结点开始一次往后查找；容量固定不可变</p></blockquote><ul><li>单链表：各个结点在内存中星罗棋布、散落天涯</li><li>静态链表：分配一整片连续的内存空间，各个结点集中安置<ul><li>下标充当”指针”<ul><li>0号结点充当”头结点”</li><li>尾结点的下标为”-1”</li></ul></li></ul></li></ul><p>适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态链表——用数组的方法实现的链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>   <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> next;           <span class="comment">//&quot;指针域&quot;——实际是数组下标</span></span><br><span class="line">&#125; Node, SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两种方法定义出来的&quot;静态链表类型一致&quot;</span></span><br><span class="line">Node a[MaxSize];</span><br><span class="line">SLinkList b;    <span class="comment">//SLinkList定义出来的是一个大小为MaxSize的Node结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitSLinkList</span><span class="params">(SLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头结点的&quot;指针域&quot;设置为-1，因为初始化只有一个结点，既是头结点也是尾结点</span></span><br><span class="line">    L[<span class="number">0</span>].next = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化时最好赋初值，可以赋一个使用过程中不可能遇到的值，不然在查找空结点时无法查找</span></span><br><span class="line">    <span class="comment">//可以给&quot;指针域&quot;赋值为-2或-3之类的，因为负数除了-1代表尾结点，其余都无意义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找：从头结点出发挨个往后遍历结点</span></span><br><span class="line"><span class="comment">//遍历时根据next指向的下标遍历，而不是对容器单纯下标递增遍历</span></span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入位序为i的结点</span></span><br><span class="line"><span class="comment">//①找到一个空的结点，存入数据元素</span></span><br><span class="line"><span class="comment">//②找到第i-1个结点</span></span><br><span class="line"><span class="comment">//③新结点指向原第i个结点</span></span><br><span class="line"><span class="comment">//④第i-1个结点指向新结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个结点</span></span><br><span class="line"><span class="comment">//①从头结点出发找其前驱结点</span></span><br><span class="line"><span class="comment">//②修改前驱结点的next，指向被删除结点的next</span></span><br><span class="line"><span class="comment">//③被删除结点的next设置为不可能的值，如-2</span></span><br></pre></td></tr></table></figure><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><ul><li>逻辑结构：都属于线性表，都是线性结构</li><li>存储结构：<ul><li>顺序表：顺序存储<ul><li>优点：支持随机存取、存储密度高</li><li>缺点：大片连续空间分配不方便，改变容量不方便</li></ul></li><li>链表：链式存储<ul><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ul></li></ul></li></ul><p>基本操作：</p><ol><li>创建线性表：存储空间的灵活性<ul><li>顺序表：需要预分配大片连续空间<ul><li>若分配空间过小，则之后不方便拓展容量</li><li>若分配空间过大，则浪费内存资源</li></ul></li><li>链表：只需要分配一个头结点(或仅声明一个头指针)，方便拓展</li></ul></li><li>销毁线性表：<ul><li>顺序表：<ul><li>修改L.length=0</li><li>静态分配时：系统自动回收空间</li><li>动态分配时：手动free(L.data)</li></ul></li><li>链表：依次删除各个结点(free)</li></ul></li><li>插入/删除数据元素：<ul><li>顺序表：插入/删除元素要将后续元素都后移/前移<ul><li>时间复杂度O(n)：时间开销主要来自移动元素</li><li>若数据元素很大，则移动的时间代价高</li></ul></li><li>链表：插入/删除元素只需修改指针即可<ul><li>时间复杂度O(n)：时间开销主要来自查找目标元素</li><li>查找元素的时间代价低，虽然都是O(n)，但是实际往往效率高</li></ul></li></ul></li><li>查找操作：<ul><li>顺序表：<ul><li>按位查找：O(1)</li><li>按值查找：无序时O(n)，有序时O(log2n)</li></ul></li><li>链表：<ul><li>按位查找：O(1)</li><li>按值查找：O(n)</li></ul></li></ul></li></ol><ul><li>顺序表：随机存取，查询操作效率高</li><li>链表：存储空间弹性(可扩容)，且插入/删除效率高</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/20210325165334.png" alt="image-20210325165334155"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-第一章-绪论</title>
      <link href="2021/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p></blockquote><ul><li>学数据结构的目的：<ol><li>如何用程序代码把现实世界的问题<strong>信息化</strong></li><li>如何用计算机高效地处理这些信息从而创造价值</li></ol></li></ul><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p><strong>数据</strong>：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合；是计算机程序加工的原料</p><p><strong>数据元素</strong>：数据的<strong>基本单位</strong>，通常作为一个整体进行考虑和处理</p><p><strong>数据项</strong>：构成数据元素的不可分割的<strong>最小单位</strong>，一个数据元素可由若干个数据项组成</p><p><strong>结构</strong>：各个组成元素之间的关系</p><p><strong>数据结构</strong>：相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素的集合</strong></p><p><strong>数据对象</strong>：具有<strong>相同性质</strong>的数据元素的集合，是数据的一个子集</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322182601.png" alt="image-20210322182601914"></p><p>数据结构的三要素：逻辑结构；存储结构；数据的运算</p><ul><li>逻辑结构——数据元素之间的逻辑关系<ol><li>集合——各个元素同属一个集合，无其他关系</li><li>线性结构——数据元素之间是一对一的关系；除了第一个元素之外，所有元素都有唯一的前驱；除了最后一个元素之外，所有元素都有唯一的后继</li><li>树形结构——数据元素之间是一对多的关系</li><li>图状结构(网状结构)——数据元素之间是多对多的关系</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322173335.png" alt="image-20210322173335843"></p><ul><li>物理结构(存储结构)——用计算机表示数据元素的逻辑关系<ol><li>顺序存储<ul><li>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li><li>需要分配一片连续的存储空间</li></ul></li><li>链式存储<ul><li>把逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储位置地址的指针来表示元素之间的逻辑关系</li><li>存储空间不需要连续，用指针表示下一个数据元素的存储地址</li></ul></li><li>索引存储<ul><li>在存储元素信息的同时，建立附加的索引表。索引表中的每项称为索引项，索引项的一般式是(关键字，地址)</li><li>存储空间不需要连续，用额外的索引表表示存储位置</li></ul></li><li>散列存储<ul><li>根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储</li></ul></li></ol></li></ul><ol><li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用<strong>非顺序存储</strong>(链式存储、索引存储、散列存储)，则各个数据元素在物理上可以是离散的</li><li>数据的存储结构会影响存储空间分配的方便程度</li><li>数据的存储结构会影响对数据运算的速度</li></ol><blockquote><p>确定一种存储结构，就意味着在计算机中表示出数据的逻辑结构。存储结构不同，也会导致运算的具体实现不同。<br>确定了存储结构，才能<strong>实现</strong>数据结构。</p></blockquote><ul><li><p>数据的运算——施加在数据上的运算包括运算的定义和实现</p><ul><li>运算的定义：针对逻辑结构，指出运算的功能</li><li>运算的实现：针对存储结构，指出运算的具体操作步骤</li></ul></li><li><p>数据类型：一个值的集合和定义在此集合上的一组操作的总称</p><ol><li>原子类型：其值不可再分的数据类型</li><li>结构类型：其值可以再分解为若干成分(分量)的数据类型</li></ol></li><li><p>抽象数据类型(ADT)：抽象数据组织及与之相关的操作</p><ul><li>ADT(Abstract Data Type)用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关(不关心存储结构)。</li><li>定义了一个ADT，就是定义了数据的逻辑结构、数据的运算，也就是<strong>定义</strong>了一个数据结构</li></ul></li><li><p>探讨数据结构时：</p><ol><li>定义逻辑结构(数据元素之间的关系)</li><li>定义数据的运算(针对现实需求，应该对这种逻辑结构进行什么样的运算)</li><li>确定某种存储结构，实现数据结构，并实现一些数据结构的基本运算</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322183245.png" alt="image-20210322183245517"></p><h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><ul><li><p>程序=数据结构+算法</p><ul><li>数据结构：如何把现实世界的问题信息化，将信息存进计算机。同时还要实现对数据结构的基本操作</li><li>算法：如何处理这些信息，以解决实际问题</li></ul></li><li><p>算法的特性：</p><ol><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可以在有穷时间内完成。(算法必须是有穷的，但程序可以是无穷的)</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li><li>输入：一个算法可以有零个或多个输入，这些输入取自于某个特定的对象的集合</li><li>输出：一个算法可以有一个或多个输出，这些输出是与输入有着某种特定关系的量</li></ol></li><li><p>“好算法”的特质：</p><ol><li>正确性：算法应能够正确地解决求解问题</li><li>可读性：算法应具有良好的可读性，以帮助人们理解。<ul><li>算法可以用伪代码描述，甚至用文字描述，重要的是要”无歧义”地描述出解决问题的步骤</li></ul></li><li>健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果</li><li>高效率(执行速度快，时间复杂度低)与低存储量需求(不浪费内存，空间复杂度低)</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322190951.png" alt="image-20210322190951924"></p><h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><blockquote><p>事后统计存在的问题：</p><ol><li>和机器性能有关；如：超级计算机 VS 单片机</li><li>和编程语言有关，越高级的语言执行效率越低</li><li>和编译程序产生的机器指令质量有关</li><li>有些算法不能事后统计；如：导弹控制算法</li></ol></blockquote><p>算法的时间复杂度：事前预估算法时间开销T(n)与问题规模n的关系</p><p>时间复杂度的考量——O(大O符号)：</p><p>f(n)=O(g(n))(读作：f(n)是g(n)的大O)，当且仅当存在正常量c和n0，使得n&gt;=n0时，f(n)&lt;=cg(n)，即g(n)为f(n)的上界。</p><p>大O符号用来描述增长率的上界，表示f(n)的增长最多像g(n)增长的那样快，输入规模为n时，算法消耗时间的最大值。这个上界的阶越低，结果越有价值。即对于10n^2+4n+2来说，O(n^2)比O(n^4)有价值。</p><p>一个算法的时间用大O符号表示时，总是采用最有价值的g(n)表示，称之为“紧凑上界”或“紧确上界”。</p><ul><li>加法规则： T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n), g(n))<ul><li>多项相加，只保留最高阶的项，且系数变为1</li></ul></li><li>乘法规则： T(n)=T1(n)×T2(n)=O(f(n))×O(g(n))=O(f(n)×g(n))<ul><li>多项相乘，都保留</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322193349.png" alt="image-20210322193349145"></p><ol><li>顺序执行的代码只会影响常数项，可以忽略</li><li>只需挑选循环中的一个<strong>基本操作</strong>分析它的执行次数与n的关系即可</li><li>如果有多层嵌套循环，只需关注最深层的循环循环了几次</li></ol><ul><li><strong>最坏时间复杂度</strong>：最坏情况下算法的时间复杂度——算法的性能问题只有在n很大时才会暴露出来，所以需要着重考虑”最坏时间复杂度”</li><li><strong>平均时间复杂度</strong>：所有输入示例等概率出现的情况下，算法的期望运行时间</li><li>最好时间复杂度(一般不着重考虑)：最好情况下算法的时间复杂度</li></ul><p>算法-&gt;分析问题规模n，找出基本语句，求出其运行次数f(n)-&gt;用O表示其阶</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322194457.png" alt="常对幂指阶"></p><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>一个算法的存储量包括形参所占空间和临时变量所占空间；在对算法进行存储空间分析时，只考虑<strong>临时变量</strong>所占空间</p><p>算法<strong>原地工作</strong>：算法所需内存空间为常量，仅使用常数个临时变量</p><p>对于<strong>函数递归调用</strong>，往往<strong>空间复杂度=递归调用的深度</strong>，但并不绝对</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/20210322200448.png" alt="image-20210322200448149"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lex实验环境的搭建</title>
      <link href="2021/03/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>2021/03/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章记录的是《编译原理》这门课要求的词法分析器Lex的实验环境的搭建和使用，平台是<strong>Win10</strong>，涉及的软件有Flex(Lex翻译器)、TDM-GCC(提供gcc环境)、CygWin(PPT和Word里建议的都是这个，我实际使用的是Windows Terminal)</p></blockquote><blockquote><p>如果是Linux环境下只需要一条命令，以Ubuntu为例：</p><ul><li>sudo apt-get install bison flex gcc make</li></ul></blockquote><ul><li>实验环境本文讲述的有两套选择：<ul><li>图省事可以选择Cygwin并在安装时选择其中的对应包</li><li>第二种选择是单独下载配置Flex、C/C++环境、命令行工具</li><li>(隐藏选择：装Linux，比如使用<a href="https://leok77.github.io/2021/03/13/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/">WSL2虚拟机</a>)</li></ul></li></ul><h2 id="安装Cygwin"><a href="#安装Cygwin" class="headerlink" title="安装Cygwin"></a>安装Cygwin</h2><blockquote><p>因为我使用的Windows Terminal是支持一些Linux命令的，所以对于我来说Cygwin是可选项(但我还是装了试试)，我只能说它的这个cd命令不是让我很舒服……当然主要原因还是因为我是个颜狗，cygwin那个默认的窗口太丑了</p><p>但是如果使用Cygwin的话就可以不单独装flex、bison、gcc等等了，可以直接在cygwin中装</p></blockquote><p>下载安装Cygwin没啥可说的，进入<a href="https://www.cygwin.com/">Cygwin官网</a>找到下载链接(在官网如图所示的位置，不要点击这个图片啊喂)点击即可下载。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320200351.png" alt="跟你说了别点图片，这只是个示例"></p><p>安装过程的注意事项除了<strong>选择好安装组件</strong>外也没啥好说的，也就是选择”Install form Internet”(另外那俩是要搭配在一起使用的，一个下载一个安装，这一个是直接下载并安装)，以及下载的时候选国内镜像，我选的阿里云镜像。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320200717.png" alt="Install form Internet"></p><p>这三个镜像是我一眼看到的，后面应该还有，我感觉这仨里面随便选一个就行了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320200839.png" alt="image-20210320200839004"></p><p>下一步就是选择<strong>需要安装的组件</strong>了，实验环境需要用的有 <strong>bison、flex、gcc-core、gcc-g++、make</strong> 这几个，这里以flex作为示例，其余四个包按照如图所示方法找到就行：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210321171205.png" alt="image-20210321171205236"></p><p>安装完之后桌面上应该会有一个Cygwin的图标，双击打开就可以使用了；如果安装的时候没选择创建桌面图标，那么就打开搜索(“Win+Q”)然后搜索Cygwin，名字叫”Cygwin64 Terminal”的就是了，如果搜不到的话，好好反思一下自己是不是选了下载没安装。</p><h2 id="配置Flex环境"><a href="#配置Flex环境" class="headerlink" title="配置Flex环境"></a>配置Flex环境</h2><blockquote><p>如果安装了Cygwin，并安装配置了相应的那几个包，这一部分就可以跳过了，毕竟不会有多少人像我一样闲的没事都试了一遍</p></blockquote><h3 id="安装Flex"><a href="#安装Flex" class="headerlink" title="安装Flex"></a>安装Flex</h3><h4 id="下载并解压Flex"><a href="#下载并解压Flex" class="headerlink" title="下载并解压Flex"></a>下载并解压Flex</h4><p>下载并安装Win-Flex-Bison，此<a href="https://sourceforge.net/projects/winflexbison/">链接</a>是SourceForge的链接，SF并不是类似于国内某些”下载站”之流的网站，而是一个<strong>开源软件开发者进行开发管理的集中式场所</strong>，有相当一部分开源软件是托管在SF上的，比如MinGW64、旧版的DevC++等。</p><p>除了在SourceForge上下载之外，还可以在<a href="https://github.com/westes/flex/releases/tag/v2.6.4">GitHub</a>上下载单独的Flex，我这里以SF上的Win-Flex-Bison为例，两者的Flex版本都是2.6.4。</p><blockquote><p>Win-Flex-Bison SourceForge：<a href="https://sourceforge.net/projects/winflexbison/">https://sourceforge.net/projects/winflexbison/</a></p><p>Flex GitHub：<a href="https://github.com/westes/flex/releases/tag/v2.6.4">https://github.com/westes/flex/releases/tag/v2.6.4</a></p></blockquote><p>点击页面醒目的<strong>Download</strong>之后，等待5秒之后就可以开始下载了。下载下来是一个只有691kb的压缩包，将其解压到想保存的位置，比如我的工具类软件安装目录是”C:/ToolBox”，我便将其解压到了”C:/ToolBox/Win_Flex_Bison”下。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320192815.png" alt="我的Win_Flex_Bison文件夹"></p><p>可以在<strong>此文件夹</strong>中打开cmd/PowerShell/Windows Terminal(我这里以Windows Terminal为例，下文我直接说Windows Terminal了)，输入如下指令，检测win_flex是否可用：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">win_flex.exe -<span class="literal">-version</span>    <span class="comment">#cmd</span></span><br><span class="line">.\win_flex.exe -<span class="literal">-version</span>  <span class="comment">#Windows Terminal</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320193724.png" alt=".\Win_flex.exe --version"></p><h4 id="添加Flex到环境变量"><a href="#添加Flex到环境变量" class="headerlink" title="添加Flex到环境变量"></a>添加Flex到环境变量</h4><blockquote><p>仅仅是解压到某个目录下无法很好的使用Flex，因为此时如果想使用的话只能在其文件目录下使用或使用时带绝对路径，所以需要将flex添加到系统环境变量中。</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320194258.png" alt="image-20210320194258384"></p><p>使用”Win+Q”键开启搜索，输入”环境变量”，打开如图所示的”编辑系统环境变量”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320194558.png" alt="image-20210320194558378"></p><p>在环境变量中根据如图所示提示添加环境变量：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320195003.png" alt="image-20210320195003792"></p><p>添加完之后依次点击各个”确定”，然后在Windows Terminal中输入”win_flex.exe –version”(别在Win-Flex-Bison文件夹下)，出现如图所示正常显示版本便说明添加成功了。如果无反应，检查自己是否已经点击完上面那几个”确定”了，或者直接重启电脑。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320195432.png" alt="不在Win-Flex-Bison文件夹下照样使用win_flex，说明添加成功"></p><h3 id="安装TDM-GCC"><a href="#安装TDM-GCC" class="headerlink" title="安装TDM-GCC"></a>安装TDM-GCC</h3><blockquote><p>并不一定要使用TDM-GCC，只需要有个Win下的C语言编译器就行了，我这里说TDM-GCC是因为我习惯用这个了</p><p>另外如果不打算在命令行下编译的话，用VS等IDE就可以完全胜任，不用单独配置GCC环境</p></blockquote><p>下载TDM-GCC直接去他的官网，点击官网首页的发行版，例如现在最新的发行版是“TDM-GCC 9.2.0 release”，点击之后可以看到下载按钮，选择“tdm64-gcc-9.2.0.exe”进行下载。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320195901.png" alt="20210207122915"></p><blockquote><p>TDM-GCC官网：<a href="https://jmeubank.github.io/tdm-gcc/">https://jmeubank.github.io/tdm-gcc/</a></p></blockquote><p>下载下来的“tdm64-gcc-9.2.0.exe”本质上是一个管理器，你可以使用它管理电脑中的TDM-GCC。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320195909.png" alt="20210207123052"></p><p>而且TDM-GCC会自动配置环境变量，在cmd下输入”gcc –version”，有如图所示内容就说明安装成功了。(如果gcc –version没反应，按照前面说的添加环境变量的方法把gcc添加到环境变量中即可，路径是”安装目录\TDM-GCC\bin”)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320195748.png" alt="image-20210316204757626"></p><h2 id="测试Flex"><a href="#测试Flex" class="headerlink" title="测试Flex"></a>测试Flex</h2><blockquote><p>测试文件来自课程群，群文件里有，就是那个叫<strong>example.rar</strong>的压缩包</p></blockquote><p>先一路cd到实验目录下，我在这个文件夹下只放了两个文件：exam1.l和test1.p(来自example.rar)。</p><h3 id="Cygwin注意事项"><a href="#Cygwin注意事项" class="headerlink" title="Cygwin注意事项"></a>Cygwin注意事项</h3><p>在Cygwin下使用cd命令并不能直接cd盘符，磁盘被挂载到了”/cygdrive/“目录下，比如我要cd到”C:/ToolBox/Win_Flex_Bison”，那么我在Cygwin下的指令应该是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /cygwin/c/ToolBox/Win_Flex_Bsion</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320203241.png" alt="image-20210320203241220"></p><h3 id="以Windows-Terminal为例"><a href="#以Windows-Terminal为例" class="headerlink" title="以Windows Terminal为例"></a>以Windows Terminal为例</h3><p>先cd到实验目录下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\Study\<span class="number">2021</span><span class="literal">-Spring</span>\编译原理\Experiment\Test</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320203342.png" alt="image-20210320203342924"></p><p>可以先使用”ls”指令查看当前目录下都有哪些文件(不适用于cmd)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320201928.png" alt="ls指令查看文件目录下的内容(不适用于cmd)"></p><p>执行如下语句，没有输出才可能是正确的，有输出的话只能是报错。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">win_flex .\exam1.l  <span class="comment">#Windows Terminal</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320202231.png" alt="比之前多了一个文件：lex.yy.c"></p><p>使用gcc编译lex.yy.c文件：(PPT里有个 -lfl 指令，我使用之后会报错，索性就去掉了，可以编译， 对应的是链接flex的库函数，也不知道会不会出问题，但是我把lex.yy.c放到CLion的项目里没报错，问题应该不大)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">gcc .\lex.yy.c <span class="literal">-lfl</span> <span class="comment">#编译</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320202456.png" alt="image-20210320202456455"></p><p>使用test1.p测试这个可执行文件a.exe对不对：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\a.exe .\test1.p <span class="comment">#输出到屏幕</span></span><br><span class="line">.\a.exe .\test1.p &gt; output.txt  <span class="comment">#输出到output.txt文件</span></span><br><span class="line"><span class="built_in">cat</span> output.txt    <span class="comment">#查看output.txt文件的内容</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Lex%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/20210320202701.png" alt="image-20210320202701902"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">(WHILE, &quot;while&quot;) (ID, &quot;a&quot;) (RELOP, &quot;&gt;&#x3D;&quot;) (ERRORCHAR, &quot;-&quot;) (NUM, &quot;1.2E-2&quot;)</span><br><span class="line">(DO, &quot;do&quot;) (ID, &quot;b&quot;) (RELOP, &quot;&lt;&#x3D;&quot;) (NUM, &quot;2&quot;)</span><br></pre></td></tr></table></figure><h3 id="测试使用的文件内容"><a href="#测试使用的文件内容" class="headerlink" title="测试使用的文件内容"></a>测试使用的文件内容</h3><p>文件名：exam1.l</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 这是注释的形式，与C中的&#x2F;*...* &#x2F;注释相同。 *&#x2F;</span><br><span class="line">&#x2F;* 第一部分是定义、声明部分。这部分内容可以为空。*&#x2F;</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* 写在 %&#123;...%&#125;这对特殊括号内的内容会被直接拷贝到C文件中。</span><br><span class="line"> *</span><br><span class="line"> * 这部分通常进行一些头文件声明，变量（全局，外部）、常量的定义，用C语法。</span><br><span class="line"> *</span><br><span class="line"> * %&#123;和%&#125;两个符号都必须位于行首 </span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 下面定义了需要识别的记号名，如果和yacc联合使用，这些记号名都应该在yacc中定义 *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define LT          1  &#x2F;&#x2F; 小于</span><br><span class="line">#define LE          2  &#x2F;&#x2F; 小于等于</span><br><span class="line">#define GT          3  &#x2F;&#x2F; 大于</span><br><span class="line">#define GE          4  &#x2F;&#x2F; 大于等于</span><br><span class="line">#define EQ          5  &#x2F;&#x2F; 等于</span><br><span class="line">#define NE          6  &#x2F;&#x2F; 不等于</span><br><span class="line"></span><br><span class="line">#define WHILE       18 &#x2F;&#x2F; WHILE</span><br><span class="line">#define DO          19 &#x2F;&#x2F; DO</span><br><span class="line">#define ID          20 &#x2F;&#x2F; 标识符</span><br><span class="line">#define NUMBER      21 &#x2F;&#x2F; 数(科学计数法)</span><br><span class="line">#define RELOP       22 &#x2F;&#x2F; 比较运算符</span><br><span class="line"></span><br><span class="line">#define NEWLINE     23 &#x2F;&#x2F; 新一行</span><br><span class="line">#define ERRORCHAR   24 &#x2F;&#x2F; 错的字符</span><br><span class="line"></span><br><span class="line">int yylval;</span><br><span class="line">&#x2F;* yylval 是yacc中定义的变量，用来保存记号的属性值，默认是int类型。 </span><br><span class="line"> * 在用lex实现的词法分析器中可以使用这个变量将记号的属性传递给用</span><br><span class="line"> * yacc实现的语法分析器。</span><br><span class="line"> *</span><br><span class="line"> * 注意：该变量只有在联合使用lex和yacc编写词法和语法分析器时才可在lex</span><br><span class="line"> *       中使用，此时该变量不需要定义即可使用。</span><br><span class="line"> *       单独使用lex时，编译器找不到这个变量。这里定义该变量为了“欺骗”编译器。</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">int installID();</span><br><span class="line">int installNum(); </span><br><span class="line">&#x2F;* 声明翻译规则中使用到的辅助函数。</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 这里进行正规定义和状态定义。</span><br><span class="line"> * 下面就是正规定义，注意，正规定义和状态定义都要顶着行首写。</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* 空格，制表符，换行符 *&#x2F;</span><br><span class="line">delim         [ \t\n]</span><br><span class="line">&#x2F;* \用来表示转义，例如\t表示制表符，\n表示换行符。*&#x2F;</span><br><span class="line">&#x2F;* 空白符，上述三种符号派生 *&#x2F;</span><br><span class="line">ws            &#123;delim&#125;+</span><br><span class="line">&#x2F;* 所有字母，包括大写字母和小写字母 *&#x2F;</span><br><span class="line">letter        [A-Za-z]</span><br><span class="line">&#x2F;* 0~9这十个基本数字 *&#x2F;</span><br><span class="line">digit         [0-9]</span><br><span class="line">&#x2F;* id以字母开头，后面可以是任意的字母或数字的组合 *&#x2F;</span><br><span class="line">id            &#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">&#x2F;* 注意：上面正规定义中出现的小括号表示分组，而不是被匹配的字符。</span><br><span class="line"> *       而大括号括起的部分表示正规定义名。</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* 数，科学计数法表示 *&#x2F;</span><br><span class="line">number        &#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* %%作为lex文件三个部分的分割符，必须位于行首 *&#x2F;</span><br><span class="line">&#x2F;* 下面这个%%不能省略 *&#x2F;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">    &#x2F;* 第二部分是翻译规则部分。 *&#x2F;</span><br><span class="line">    &#x2F;* 写在这一部分的注释要有前导空格，否则lex编译出错。*&#x2F;</span><br><span class="line">    &#x2F;* 翻译规则的形式是：正规式  &#123;动作&#125;</span><br><span class="line">     * 其中，正规式要顶行首写，动作要以C语法写（动作会被拷贝到yylex()函数中，），\</span><br><span class="line">     * 正规式和动作之间要用空白分割。</span><br><span class="line">     *&#x2F;</span><br><span class="line">  </span><br><span class="line">&#123;ws&#125;          &#123;;&#x2F;* 此时词法分析器没有动作，也不返回，而是继续分析。 *&#x2F;&#125;</span><br><span class="line">    &#x2F;* 正规式部分用大括号扩住的表示正规定义名，例如&#123;ws&#125;。</span><br><span class="line">     * 没有扩住的直接表示正规式本身。</span><br><span class="line">     * 一些元字符没办法表示它本身，此时可以用转义字符或</span><br><span class="line">     * 用双引号括起来，例如&quot;&lt;&quot;</span><br><span class="line">     *&#x2F;</span><br><span class="line">while         &#123;return (WHILE);&#125;</span><br><span class="line">do            &#123;return (DO);&#125;</span><br><span class="line">&#123;id&#125;          &#123;yylval &#x3D; installID (); return (ID);&#125;</span><br><span class="line">&#123;number&#125;      &#123;yylval &#x3D; installNum (); return (NUMBER);&#125;</span><br><span class="line">&quot;&lt;&quot;           &#123;yylval &#x3D; LT; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;&#x3D;&quot;          &#123;yylval &#x3D; LE; return (RELOP);&#125;</span><br><span class="line">&quot;&#x3D;&quot;           &#123;yylval &#x3D; EQ; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;&gt;&quot;          &#123;yylval &#x3D; NE; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;&quot;           &#123;yylval &#x3D; GT; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;&#x3D;&quot;          &#123;yylval &#x3D; GE; return (RELOP);&#125;</span><br><span class="line"></span><br><span class="line">.             &#123;yylval &#x3D; ERRORCHAR; return ERRORCHAR;&#125;</span><br><span class="line">    &#x2F;* .匹配除换行之外的任何字符，一般可作为最后一条翻译规则。 *&#x2F;</span><br><span class="line"> </span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&#x2F;* 第三部分是辅助函数部分，这部分内容以及前面的%%都可以省略 *&#x2F;</span><br><span class="line">&#x2F;* 辅助函数可以定义“动作”中使用的一些函数。这些函数</span><br><span class="line"> * 使用C语言编写，并会直接被拷贝到lex.yy.c中。</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">int installID() &#123;</span><br><span class="line">    &#x2F;* 把词法单元装入符号表并返回指针。*&#x2F;</span><br><span class="line">    return ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int installNum() &#123;</span><br><span class="line">    &#x2F;* 类似上面的过程，但词法单元不是标识符而是数 *&#x2F;</span><br><span class="line">    return NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* yywrap这个辅助函数是词法分析器遇到输入文件结尾时会调用的，用来决定下一步怎么做：</span><br><span class="line"> * 若yywrap返回0，则继续扫描；返回1，则词法分析器返回报告文件已结束的0。</span><br><span class="line"> * lex库中的标准yywrap程序就是返回1，你也可以定义自己的yywrap。</span><br><span class="line"> *&#x2F;</span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeout(int c) &#123;</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case ERRORCHAR:</span><br><span class="line">            fprintf(yyout, &quot;(ERRORCHAR, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case RELOP:</span><br><span class="line">            fprintf(yyout, &quot;(RELOP, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case WHILE:</span><br><span class="line">            fprintf(yyout, &quot;(WHILE, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case DO:</span><br><span class="line">            fprintf(yyout, &quot;(DO, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case NUMBER:</span><br><span class="line">            fprintf(yyout, &quot;(NUM, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case ID:</span><br><span class="line">            fprintf(yyout, &quot;(ID, \&quot;%s\&quot;) &quot;, yytext);</span><br><span class="line">            break;</span><br><span class="line">        case NEWLINE:</span><br><span class="line">            fprintf(yyout, &quot;\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 辅助函数里可以使用yytext和yyleng这些外部定义的变量。</span><br><span class="line"> * yytext指向输入缓冲区当前词法单元(lexeme)的第一个字符，</span><br><span class="line"> * yyleng给出该词法单元的长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 如果你的词法分析器并不是作为语法分析器的子程序，</span><br><span class="line"> * 而是有自己的输入输出，你可以在这里定义你的词法</span><br><span class="line"> * 分析器的main函数，main函数里可以调用yylex()</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int c, j &#x3D; 0;</span><br><span class="line">    if (argc &gt;&#x3D; 2) &#123;</span><br><span class="line">        if ((yyin &#x3D; fopen(argv[1], &quot;r&quot;)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            printf(&quot;Can&#39;t open file %s\n&quot;, argv[1]);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (argc &gt;&#x3D; 3) &#123;</span><br><span class="line">            yyout &#x3D; fopen(argv[2], &quot;w&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* yyin和yyout是lex中定义的输入输出文件指针，它们指明了</span><br><span class="line">     * lex生成的词法分析器从哪里获得输入和输出到哪里。</span><br><span class="line">     * 默认：键盘输入，屏幕输出。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    while (c &#x3D; yylex()) &#123;</span><br><span class="line">        writeout(c);</span><br><span class="line">        j++;</span><br><span class="line">        if (j % 5 &#x3D;&#x3D; 0) writeout(NEWLINE);</span><br><span class="line">    &#125;</span><br><span class="line">    if (argc &gt;&#x3D; 2) &#123;</span><br><span class="line">        fclose(yyin);</span><br><span class="line">        if (argc &gt;&#x3D; 3) fclose(yyout);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名：test1.p</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while a &gt;&#x3D; -1.2E-2</span><br><span class="line">do b&lt;&#x3D;2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Ubuntu Pastebin分享文本</title>
      <link href="2021/03/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/"/>
      <url>2021/03/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<ul><li>适用场景：<ul><li>接收方与发送方都可以联网；</li><li>单个文本内容较多且不想通过QQ、微信等方式发送文件<ul><li>至少我很不喜欢别人把一大串文本复制到聊天框再发送过来的情况</li><li>再比如Linux系统下，虽然有QQ、微信的民间移植版但不稳定</li></ul></li></ul></li></ul><blockquote><p>Ubuntu Pastebin网址：<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></p></blockquote><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p>This site is intended for use as a short-term exchange of pasted information between parties. All submitted data is considered public information. Submitted data is not guaranteed to be permanent, and may be removed at any time. Please do not set up programs to send data to this site in an automated fashion; it is intended to be used directly by humans.</p><blockquote><p>本网站旨在作为双方之间粘贴信息的短期交流。所有提交的数据都被视为公开信息。提交的数据不保证是永久性的，可以随时删除。请不要设置程序以自动方式将数据发送到此站点；它是供人类直接使用的。</p></blockquote><ul><li>优点：<ul><li>工具本身免费，使用这个网站分享再多内容都无需付费</li><li>操作方式简单，无任何反人类要求</li></ul></li><li>缺点：<ul><li>必须联网(但其他文本分享方式也基本都需要联网)，无法访问外网(相对于局域网)时无法使用</li><li>分享的文本内容所有人只要拥有这个链接就可以访问，即”公开信息”(但一般用这个网站也不会分享啥重要/隐私内容，个人建议仅临时分享代码)</li><li>一次只可以分享一个文件的内容，如果想分享一整个项目，还是老老实实把项目压缩成一个压缩包，然后用蓝奏云或者坚果云吧</li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>进入<a href="https://paste.ubuntu.com/">Ubuntu Pastebin</a>网站，依次填写或选择需要添加的内容：</p><ul><li>Poster：发送者的名字，此处不可为空，可以随意取个名字</li><li>Syntax：文本的格式，一般使用的时候都是代码文本，选择对应的代码名字即可，比如这里以**C++**为例</li><li>Expiration：有效期，这里的这个有效期是近似的有效期，并不是确定的时间，一般给别人发链接都是即发即用，为了不占用过多资源，选择最少的<strong>a day</strong>即可。</li><li>Content：文本内容，将需要发送的文本内容复制粘贴到此处即可。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/20210314212900.png" alt="填写信息"></p><p>发送完毕之后会自动进入如图所示页面，现在需要做的就是把网址拷贝下来发送给你想分享的人，这样他打开这个网址时看到的和你现在看到的是完全一致的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/20210314213131.png" alt="发送之后的页面"></p><p>文本内容可以直接复制，也可以将其下载下来(选择下载的话需要登录Ubuntu)，我一般选择复制粘贴内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Ubuntu Pastebin是一个良心网站，适合轻量使用分享一个或几个文本文件；</li><li>如果有多文件需求可以考虑打包压缩之后使用蓝奏云；</li><li>如果有重度文件分享需求可以考虑使用坚果云等付费应用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装并使用WSL(Windows-Subsystem-Linux)</title>
      <link href="2021/03/13/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/"/>
      <url>2021/03/13/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>WSL官方文档：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></p></blockquote><h2 id="什么是WSL"><a href="#什么是WSL" class="headerlink" title="什么是WSL"></a>什么是WSL</h2><p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</p><ul><li>在 Microsoft Store 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 grep、sed、awk）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：<ul><li>工具：vim、emacs、tmux</li><li>语言：NodeJS、Javascript、Python、Ruby、C/ C++、C# 与 F#、Rust、Go 等。</li><li>服务：SSHD、MySQL、Apache、lighttpd、MongoDB、PostgreSQL。</li></ul></li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li></ul><p>按照我的理解，WSL本质上就是一个虚拟机(这样描述不准确)，但是相较于VMWare Workstation或者VirtualBox创建的虚拟机来说，它更兼容Windows，性能更好(特指WSL2)，但是不提供GUI界面，所以如果想使用带图形界面的Linux，还是老老实实双系统或者装一个正经的虚拟机吧。</p><blockquote><p>WSL和WSL2在本质上不是一个东西，但是鄙人才疏学浅，不是很明白其中的区别，所以本文中所有两者比较的观点都有很强的主观性，本人目前使用的是WSL2</p></blockquote><h2 id="启用WSL和虚拟机平台功能"><a href="#启用WSL和虚拟机平台功能" class="headerlink" title="启用WSL和虚拟机平台功能"></a>启用WSL和虚拟机平台功能</h2><ul><li>适用于Linux的Windows子系统：此功能必须开启</li><li>虚拟机平台：如果要使用WSL2的话，需开启此功能</li></ul><h3 id="方法一：在控制面板开启相应功能"><a href="#方法一：在控制面板开启相应功能" class="headerlink" title="方法一：在控制面板开启相应功能"></a>方法一：在控制面板开启相应功能</h3><p>Win+Q打开搜索框，输入”控制面板”以打开控制面板；在控制面板窗口点击”程序”，之后点击”启用或关闭Windows功能”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313202627.png" alt="控制面板"></p><p>在Windows功能页下拉到最下面，点击”适用于Linux的Windows子系统”和”虚拟机平台”后点击确定。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313202745.png" alt="开启相应功能"></p><p>在cmd下执行如下语句，若输出开端为如图所示，则说明WSL启用成功：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313203347.png" alt="wsl --help"></p><h3 id="方法二：在Powershell中开启相应功能"><a href="#方法二：在Powershell中开启相应功能" class="headerlink" title="方法二：在Powershell中开启相应功能"></a>方法二：在Powershell中开启相应功能</h3><p>以管理员身份打开Powershell并执行下述命令：(第一条是开启WSL，第二条是开启WSL2需要的虚拟机平台功能)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><blockquote><p>功能成功开启之后需要重启计算机！！！</p></blockquote><h2 id="升级到WSL2"><a href="#升级到WSL2" class="headerlink" title="升级到WSL2"></a>升级到WSL2</h2><p>WSL与WSL2的功能比较表如图所示，可以看出除了<strong>跨操作系统文件系统的性能</strong>外，WSL2体系结构在多个方面比WSL1更具优势，学习和使用Linux的情况下，<strong>如果没有必须在Linux中访问Windows文件系统的需求</strong>，使用WSL2都是更好的选择，且WSL2的性能更好并提供100%的系统调用兼容性。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313205148.png" alt="image-20210313205148537"></p><p>下载并安装<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于x64计算机的WSL2Linux内核更新包</a>，安装时会提示你提供提升的权限，选择”是”以批准此安装。</p><p>安装完成之后，在cmd执行如下语句，将WSL2设置为默认版本：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="安装Linux发行版"><a href="#安装Linux发行版" class="headerlink" title="安装Linux发行版"></a>安装Linux发行版</h2><p>打开<a href="https://aka.ms/wslstore">Microsoft Store</a>，选择偏好的Linux发行版。这里列出的并不是所有的可用的Linux发行版，不满足于这几个发行版可以前去查看WSL官方文档，此处我使用的是<a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Ubuntu 20.04 LTS</a>。</p><p>首次启动新安装的Linux发行版时，将打开一个控制台窗口，系统会要求等待一段时间，以便文件解压缩并存储到电脑上，未来的启动时间会很快。</p><p>新安装的Linux发行版会要求创建用户账户(非root)和密码，此用户名和密码拥有以下属性：</p><ul><li>此用户名和密码特定于安装的每个单独的 Linux 分发版，与 Windows 用户名无关。</li><li>创建用户名和密码后，该帐户将是分发版的默认用户，并将在启动时自动登录。</li><li>此帐户将被视为 Linux 管理员，能够运行 sudo (Super User Do) 管理命令。</li><li>在适用于 Linux 的 Windows 子系统上运行的每个 Linux 分发版都有其自身的 Linux 用户帐户和密码。 每当添加分发版、重新安装或重置时，都必须配置一个 Linux 用户帐户。</li></ul><p>安装结束后的Ubuntu 20.04 LTS窗口如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313205035.png" alt="image-20210313205035743"></p><p>在此窗口下使用”exit”可以退出窗口，但是WSL会在后台运行，彻底关闭的方式是在Powershell下使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>查询wsl运行状态需使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --list -verbose # 完整命令</span><br><span class="line">wsl -l -v           # 简写</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210213.png" alt="image-20210313210213095"></p><h2 id="通过其他方式登录到WSL"><a href="#通过其他方式登录到WSL" class="headerlink" title="通过其他方式登录到WSL"></a>通过其他方式登录到WSL</h2><p>如果觉着Ubuntu的默认终端窗口有些丑的话，可以使用其他方式登录到WSL(其实就是我自己习惯下面这俩工具了)。</p><h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p>在Windows Terminal窗口点击如图所示位置可以直接进入WSL(需等待其启动)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210406.png" alt="image-20210313210406062"></p><p>在Windows Terminal窗口下输入wsl也可直接进入：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210810.png" alt="image-20210313210810636"></p><p>需要注意的是，这两种方式进入WSL的默认路径都不是**/home/username<strong>，而是Windows系统的用户文件夹的挂载位置</strong>/mnt/c/Users/username**，执行操作时需注意。</p><h3 id="VS-Code-Remote-WSL"><a href="#VS-Code-Remote-WSL" class="headerlink" title="VS Code - Remote WSL"></a>VS Code - Remote WSL</h3><p>安装Remote WSL插件，在插件栏搜索即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313211202.png" alt="image-20210313211201935"></p><p>安装好之后侧边栏会多出一个”远程资源管理器图标”，点击之后选择”WSL Targets”，在点击如图所示位置(会自动搜寻本机中拥有的WSL主机)，就可以在VS Code中访问WSL了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313211259.png" alt="image-20210313211259502"></p><h2 id="配置Ubuntu"><a href="#配置Ubuntu" class="headerlink" title="配置Ubuntu"></a>配置Ubuntu</h2><h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><p>初始镜像源是官方源，在国内访问会比较慢，我之前用的是清华源，结果install gcc的时候提示有个包找不到，所以就换成华为源了。</p><p>如果之前没有换过镜像源，那么可以直接使用下列命令进行换源(第一条是备份，第二条是换源)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i <span class="string">&quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">&quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>如果之前换过源了，可以将下列内容保存为”/etc/apt/sources.list”(以免被说夹带私货，sources.list里的内容我一点都没删，完全是上述指令使用之后的结果)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># See http:&#x2F;&#x2F;help.ubuntu.com&#x2F;community&#x2F;UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal universe</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to use the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide useful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#39;s</span><br><span class="line">## &#39;partner&#39; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu users.</span><br><span class="line"># deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu focal partner</span><br><span class="line"># deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu focal partner</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security multiverse</span><br></pre></td></tr></table></figure><p>换好源之后update、upgrade一下，舒服多了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell是否更换视自己习惯而定，我主要是喜欢zsh的补全功能，然后习惯用ohmyzsh的主题了(我知道ohmyzsh在资源占用方面好像有诟病，但日常使用区别并不大)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh -y   <span class="comment">#安装zsh</span></span><br><span class="line">chsh -s /bin/zsh username <span class="comment">#修改用户的默认终端为zsh</span></span><br><span class="line"><span class="comment">#下载并安装 oh-my-zsh</span></span><br><span class="line">wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><p>修改”/home/username/.zshrc”中的ZSH_THEME为”duellj”：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;duellj&quot;</span><br></pre></td></tr></table></figure><p>在.zshrc文件末尾追加如下内容，这样就不会出现末尾的空行显示成%的情况了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 去除末尾的百分号</span><br><span class="line">setopt PROMPT_CR</span><br><span class="line">setopt PROMPT_SP</span><br><span class="line">export PROMPT_EOL_MARK&#x3D;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数记录</title>
      <link href="2021/02/21/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/21/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用来记录使用Python的过程中遇到的一些函数用法，以免以后再次遇到的时候又忘掉需要现找</p></blockquote><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h4 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h4><p>返回表示当前工作目录的字符串</p><h4 id="os-listdir-path-’-’"><a href="#os-listdir-path-’-’" class="headerlink" title="os.listdir(path=’.’)"></a>os.listdir(path=’.’)</h4><p>返回一个列表，包含path中所有文件与目录的名称，按任意顺序排列</p><h4 id="os-mkdir-path"><a href="#os-mkdir-path" class="headerlink" title="os.mkdir(path)"></a>os.mkdir(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(path, mode=<span class="number">0o777</span>, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>创建一个名为path的目录，如果目录已经存在则会抛出FileExistsError异常</p><h4 id="os-makedirs-path"><a href="#os-makedirs-path" class="headerlink" title="os.makedirs(path)"></a>os.makedirs(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(path, mode=<span class="number">0o777</span>, exist_ok=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>递归目录创建函数，自动创建到达最后一级目录所需要的中间目录</p><h4 id="os-remove-path"><a href="#os-remove-path" class="headerlink" title="os.remove(path)"></a>os.remove(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(path, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>移除(删除)文件path。如果path是目录，则抛出IsADirectoryError异常</p><h4 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path)"></a>os.rmdir(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir(path, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>移除(删除)目录path。如果目录不存在则抛出FileNotFoundError异常，若目录不为空则抛出OSError异常。</p><blockquote><p>删除非空目录需要使用shutil.rmtree(src)函数</p></blockquote><h4 id="os-rename-src-dst"><a href="#os-rename-src-dst" class="headerlink" title="os.rename(src, dst)"></a>os.rename(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(src, dst, *, src_dir_fd=<span class="literal">None</span>, dst_dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将文件或目录src重命名为dst，如果dst已存在，则操作失败并抛出OSError子类异常(Windows下抛出FileExistsError异常)。</p><h4 id="os-replace-src-dst"><a href="#os-replace-src-dst" class="headerlink" title="os.replace(src, dst)"></a>os.replace(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.replace(src, dst, *, src_dir_fd=<span class="literal">None</span>, dst_dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将文件或目录src重命名为dst。如果dst是目录，将抛出OSError异常。如果dst已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。</p><h4 id="os-walk-top"><a href="#os-walk-top" class="headerlink" title="os.walk(top)"></a>os.walk(top)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># os.walk的经典用法：对以root_path为根的每个目录进行遍历</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(root_path):</span><br><span class="line">    <span class="keyword">for</span> dir_name <span class="keyword">in</span> dirs:</span><br><span class="line">        dir_path = os.path.join(root, dir_name)</span><br><span class="line">        <span class="comment"># 只将空文件夹填入all_path，非空文件夹会由内部文件路径填入all_path</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.listdir(dir_path):</span><br><span class="line">            all_path.append(dir_path)</span><br><span class="line">    <span class="keyword">for</span> basename <span class="keyword">in</span> files:</span><br><span class="line">        all_path.append(os.path.join(root, basename))</span><br></pre></td></tr></table></figure><p>生成目录树中的文件名，方式是自上而下或自下而上浏览目录树。对于以top为根的目录树中的每个目录(包括top本身)，都会生成一个三元组(dirpath, dirnames, filenames)</p><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><h4 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path)"></a>os.path.abspath(path)</h4><p>返回路径path的绝对路径(标准化的)</p><h4 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h4><p>返回路径path的基本名称(文件名)</p><p>例如“C:/dir1/dir2/filename”返回“filename”</p><h4 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h4><p>返回路径path的目录名称(路径名称)</p><p>例如“C:/dir1/dir2/filename”返回“C:/dir1/dir2”</p><h4 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path)"></a>os.path.exists(path)</h4><p>如果路径path指向一个已存在的路径或已打开的文件描述符，返回True；对于失效的符号链接，返回False。</p><p>基本上可以理解为路径path若存在则返回True，否则返回False</p><h4 id="os-path-isabs-path"><a href="#os-path-isabs-path" class="headerlink" title="os.path.isabs(path)"></a>os.path.isabs(path)</h4><p>如果路径path是一个绝对路径，则返回True</p><h4 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path)"></a>os.path.isfile(path)</h4><p>如果路径path是一个现有的常规文件，则返回True</p><h4 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path)"></a>os.path.isdir(path)</h4><p>如果路径path是一个现有的目录(文件夹)，则返回True</p><h4 id="os-path-join-path-paths"><a href="#os-path-join-path-paths" class="headerlink" title="os.path.join(path, *paths)"></a>os.path.join(path, *paths)</h4><p>合理地拼接一个或多个路径部分，拼接部分使用os.sep(目录分隔符)连接。</p><p>例如拼接目录和文件名：os.path.join(“C:/dir1”, “filename”)的结果是”C:/dir1/dilename”</p><h4 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path)"></a>os.path.split(path)</h4><p>将路径path拆分为一对，即(head, tail)，可以理解为head=os.path.dirname(path) tail=os.path.basename(path)；os.path.join(head, tail)=path</p><p>os.path.split(path)的返回值是tuple(元组)类型</p><h4 id="os-path-splitext-path"><a href="#os-path-splitext-path" class="headerlink" title="os.path.splitext(path)"></a>os.path.splitext(path)</h4><p>将路径path拆分为一对，即(root, ext)，使root+ext==path，其中ext为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如splitext(‘.cshrc’)返回(‘.cshrc’, ‘’)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root, ext = os.path.splitext(path)</span><br></pre></td></tr></table></figure><h2 id="Zipfile"><a href="#Zipfile" class="headerlink" title="Zipfile"></a>Zipfile</h2><h3 id="zipfile-ZipFile"><a href="#zipfile-ZipFile" class="headerlink" title="zipfile.ZipFile"></a>zipfile.ZipFile</h3><h4 id="zipfile-ZipFile-file-mode-’r’"><a href="#zipfile-ZipFile-file-mode-’r’" class="headerlink" title="zipfile.ZipFile(file, mode=’r’)"></a>zipfile.ZipFile(file, mode=’r’)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zipfile.ZipFile(file, mode=<span class="string">&#x27;r&#x27;</span>, compression=ZIP_STORED, allowZip64=<span class="literal">True</span>, compresslevel=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>打开一个ZIP文件，file是指向文件的路径(字符串)，“r”是读取这个ZIP文件，“w”是写入这个ZIP文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(filepath, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="keyword">as</span> zipfile_example:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="zipfile-ZipFile-write"><a href="#zipfile-ZipFile-write" class="headerlink" title="zipfile.ZipFile.write"></a>zipfile.ZipFile.write</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zipfile.ZipFile.write(filename, arcname=<span class="literal">None</span>, compress_type=<span class="literal">None</span>, compresslevel=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将名为filename的文件写入归档，给予的归档名为arcname。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dirname = os.path.dirname(filename)</span><br><span class="line">zipfile.ZipFile.write(filename, filename.replace(dirname, <span class="string">&#x27;&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="OpenCC"><a href="#OpenCC" class="headerlink" title="OpenCC"></a>OpenCC</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install OpenCC</span><br></pre></td></tr></table></figure><h3 id="基础用法-opencc"><a href="#基础用法-opencc" class="headerlink" title="基础用法 - opencc"></a>基础用法 - opencc</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line">converter = opencc.OpenCC(<span class="string">&#x27;t2s.json&#x27;</span>)</span><br><span class="line">converter.convert(<span class="string">&#x27;漢字&#x27;</span>) <span class="comment"># 汉字</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-opencc"><a href="#配置文件-opencc" class="headerlink" title="配置文件 - opencc"></a>配置文件 - opencc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s2t.json - Simplified Chinese to Traditional Chinese - 简-&gt;繁</span><br><span class="line">t2s.json - Traditional Chinese to Simplified Chinese - 繁-&gt;简</span><br><span class="line">s2tw.json - Simplified Chinese to Traditional Chinese (Taiwan Standard) - 简-&gt;繁(台湾)</span><br><span class="line">tw2s.json - Traditional Chinese (Taiwan Standard) to Simplified Chinese - 繁(台湾)-&gt;简</span><br><span class="line">s2hk.json -  Simplified Chinese to Traditional Chinese (Hong Kong variant) - 简-&gt;繁(香港)</span><br><span class="line">hk2s.json - Traditional Chinese (Hong Kong variant) to Simplified Chinese - 繁(香港)-&gt;简</span><br></pre></td></tr></table></figure><h2 id="Hashlib"><a href="#Hashlib" class="headerlink" title="Hashlib"></a>Hashlib</h2><h3 id="基础用法-hashlib"><a href="#基础用法-hashlib" class="headerlink" title="基础用法 - hashlib"></a>基础用法 - hashlib</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">m = hashlib.sha256()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(src_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src:</span><br><span class="line">  src_data = src.read(<span class="number">2048</span>)</span><br><span class="line">  <span class="keyword">while</span> src_data:</span><br><span class="line">    m.update(src_data)</span><br><span class="line">    src_data = src.read(<span class="number">2048</span>)</span><br><span class="line">hash_result = m.hexdigest() </span><br></pre></td></tr></table></figure><h3 id="函数说明-hashlib"><a href="#函数说明-hashlib" class="headerlink" title="函数说明 - hashlib"></a>函数说明 - hashlib</h3><h4 id="hashlib-sha256"><a href="#hashlib-sha256" class="headerlink" title="hashlib.sha256()"></a>hashlib.sha256()</h4><p>选取hash校验类型，常用的有hashlib.md5()、hashlib.sha256()、hashlib.sha512()等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = hashlib.sha256()  <span class="comment"># m是一个实例</span></span><br></pre></td></tr></table></figure><h4 id="m-update-data"><a href="#m-update-data" class="headerlink" title="m.update(data)"></a>m.update(data)</h4><p>使用data更新hash校验，data需要是二进制字节，不支持字符串对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m.update(<span class="string">b&#x27;Hello World!&#x27;</span>) <span class="comment"># 字符串转化为二进制字节</span></span><br></pre></td></tr></table></figure><p>重复调用相当于单词调用并传入所有参数的拼接结果，即：<br>m.update(a);m.update(b)等价于m.update(a+b)</p><h4 id="m-hexdigest"><a href="#m-hexdigest" class="headerlink" title="m.hexdigest()"></a>m.hexdigest()</h4><p>返回当前已传给update()方法的数据摘要，以两倍长度字符串对象的形式返回，仅包含十六进制数码。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h3><table><thead><tr><th>mode</th><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>读取模式</td><td>打开的文件不存在则抛出FileNotFoundError异常</td></tr><tr><td>w</td><td>写入模式</td><td>打开的文件不存在则自动新建；存在则先清空</td></tr><tr><td>x</td><td>新建模式</td><td>打开的文件存在则抛出FileExistsError异常</td></tr><tr><td>a</td><td>追加模式</td><td>打开的文件不存在则自动新建；在文件尾部追加内容</td></tr><tr><td>+</td><td>读写模式</td><td>在模式中附带’+’将允许同时读取和写入</td></tr><tr><td>b</td><td>二进制模式</td><td>在模式中附带’b’代表此次的读/写以二进制形式进行</td></tr></tbody></table><h3 id="基础用法-io"><a href="#基础用法-io" class="headerlink" title="基础用法 - io"></a>基础用法 - io</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(src_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> src:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="io-open"><a href="#io-open" class="headerlink" title="io.open()"></a>io.open()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.<span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li>file - 文件名</li><li>mode - 读写模式</li><li>encoding - 编码类型<ul><li>encoding = ‘utf-8’</li><li>encoding = ‘gbk’</li><li>encoding = ‘unicode’</li></ul></li></ul><blockquote><p>下面的<strong>file</strong>前缀指open()出来的对象</p></blockquote><h4 id="file-read-size-1"><a href="#file-read-size-1" class="headerlink" title="file.read(size=-1)"></a>file.read(size=-1)</h4><p>从流中读取并返回最多size个字节，若未指定size则将读取到EOF</p><h4 id="file-readline-size-1"><a href="#file-readline-size-1" class="headerlink" title="file.readline(size=-1)"></a>file.readline(size=-1)</h4><p>从流中读取并返回一行，如果指定了size，将至多读取size个字节</p><h4 id="file-readlines-hint-1"><a href="#file-readlines-hint-1" class="headerlink" title="file.readlines(hint=-1)"></a>file.readlines(hint=-1)</h4><p>从流中读取并返回多行的列表，如果指定了hint，将至多读取hint行</p><h4 id="file-write-str"><a href="#file-write-str" class="headerlink" title="file.write(str)"></a>file.write(str)</h4><p>将str字符串写入到file中</p><h4 id="file-writelines-list"><a href="#file-writelines-list" class="headerlink" title="file.writelines(list)"></a>file.writelines(list)</h4><p>将list列表逐个写入到file中</p><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><h3 id="基础用法-urllib-parse"><a href="#基础用法-urllib-parse" class="headerlink" title="基础用法 - urllib.parse"></a>基础用法 - urllib.parse</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> parse</span><br><span class="line">target_str = parse.quote(src_str) <span class="comment"># 字符串中的特殊字符转义</span></span><br><span class="line">src_str = parse.unquote(target_str) <span class="comment"># 转义回特殊字符</span></span><br></pre></td></tr></table></figure><h3 id="urllib-parse"><a href="#urllib-parse" class="headerlink" title="urllib.parse"></a>urllib.parse</h3><h4 id="urllib-parse-quote-string"><a href="#urllib-parse-quote-string" class="headerlink" title="urllib.parse.quote(string)"></a>urllib.parse.quote(string)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.parse.quote(string, safe=<span class="string">&#x27;/&#x27;</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>把字符串string进行转义，除了A-Z、a-z、0-1、’/‘等都需要转义</p><h4 id="urllib-parse-unquote-string"><a href="#urllib-parse-unquote-string" class="headerlink" title="urllib.parse.unquote(string)"></a>urllib.parse.unquote(string)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.parse.unquote(string, encoding=<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;replace&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Replace %xx escapes by their single-character equivalent.</p><p>把转义过的字符转义回原来的字符</p><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><h3 id="基础用法-shutil"><a href="#基础用法-shutil" class="headerlink" title="基础用法 - shutil"></a>基础用法 - shutil</h3><h4 id="shutil-copy-src-dst"><a href="#shutil-copy-src-dst" class="headerlink" title="shutil.copy(src, dst)"></a>shutil.copy(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst, *, follow_symlinks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>将文件src拷贝到文件或目录dst。src和dst应为字符串。如果dst指定了一个目录，文件将使用src中的基准文件名拷贝到dst。返回新创建文件所对应的路径。</p><p>copy()会拷贝文件数据和文件的权限模式(参见os.chmod())。其他元数据，例如文件的创建和修改时间不会被保留。要保留所有原有的元数据，改用copy2()。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如 - 将path_src保存到path_dst，重命名为_config.yml</span></span><br><span class="line">path_src = <span class="string">r&#x27;_config.butterfly.yml&#x27;</span></span><br><span class="line">path_dst = <span class="string">r&#x27;C:/Users/LeoK77/Desktop/_config.yml&#x27;</span></span><br><span class="line">shutil.copy(path_src, path_dst)</span><br><span class="line"><span class="comment"># 例如 - 将path_src保存到path_dst目录下，保存为path_dst/_config.butterfly.yml</span></span><br><span class="line">path_src = <span class="string">r&#x27;_config.butterfly.yml&#x27;</span></span><br><span class="line">path_dst = <span class="string">r&#x27;C:/Users/LeoK77/Desktop&#x27;</span></span><br><span class="line">shutil.copy(path_src, path_dst)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/20210305100958.png" alt="image-20210305100957939"></p><h4 id="shutil-copy2-src-dst"><a href="#shutil-copy2-src-dst" class="headerlink" title="shutil.copy2(src, dst)"></a>shutil.copy2(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copy2(src, dst, *, follow_symlinks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>类似于shutil.copy()，但是会尝试尽量保留所有元数据</p><h4 id="shutil-copytree-src-dst"><a href="#shutil-copytree-src-dst" class="headerlink" title="shutil.copytree(src, dst)"></a>shutil.copytree(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2, ignore_dangling_symlinks=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>递归拷贝以src为根路径的整个目录树，返回目标目录。名为dst的目标目录不必已存在；它本身和还不存在的父目录都将被自动创建。</p><p>目录的权限和时间信息将通过copystat()来拷贝，单独的文件将使用shutil.copy2()来拷贝。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exception shutil.Error</span><br><span class="line"><span class="comment"># copytree引发的异常是一个三元组 —— (srcname, dstname, exception)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个ignore示例(建议用ignore_patterns()函数，见下一项)</span></span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span>(<span class="params">path, names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&#x27;Working in %s&#x27;</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h4 id="shutil-ignore-patterns-patterns"><a href="#shutil-ignore-patterns-patterns" class="headerlink" title="shutil.ignore_patterns(*patterns)"></a>shutil.ignore_patterns(*patterns)</h4><p>这是一个工厂函数，被用作copytree()的ignore可调用对象参数，以忽略那些所提供的glob风格的patterns之一的文件和目录。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">&#x27;*.pyc&#x27;</span>, <span class="string">&#x27;tmp*&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="shutil-rmtree-path"><a href="#shutil-rmtree-path" class="headerlink" title="shutil.rmtree(path)"></a>shutil.rmtree(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>删除一个完整的目录树；path必须指向一个目录（但不能是一个目录的符号链接）。 如果ignore_errors为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由onerror所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p><blockquote><p>删除单个文件需要使用os.remove(path)，删除空目录可以使用os.rmdir(path)</p></blockquote><h4 id="shutil-move-src-dst-copy-function-copy2"><a href="#shutil-move-src-dst-copy-function-copy2" class="headerlink" title="shutil.move(src, dst, copy_function=copy2)"></a>shutil.move(src, dst, copy_function=copy2)</h4><p>递归地将一个文件或目录(src)移动到另一个位置(dst)并返回目标位置</p><p>如果目标是已存在的目录，则src会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于os.rename()的语义。</p>]]></content>
      
      
      <categories>
          
          <category> Python学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+GitHubPages搭建个人博客</title>
      <link href="2021/02/09/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/02/09/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown(或其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。搭配GitHub Pages服务可以获得专属的个人博客。</p><p>以下内容以Win10系统为例：</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>安装Node.js可以直接安装本体，也可以使用nvs、nvm等工具进行多版本管理，这里我使用的是Hexo推荐的nvs进行版本管理。</p><p>nvs的安装请参照其官网教程，这里只给出使用方法。</p><blockquote><p>nvs官网：<a href="https://github.com/jasongin/nvs">https://GitHub.com/jasongin/nvs</a></p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nvs       #如果有输出则说明已经可用，按ESC退出</span><br><span class="line">#如果裸连node的官方库速度不慢，那么就不添加华为镜像源源</span><br><span class="line">nvs remote node-huawei https://repo.huaweicloud.com/nodejs/ #添加华为云镜像源到nvs中</span><br><span class="line">nvs       #运行nvs，选择“Download another version”，找到你刚才添加的“node-huawei”，然后选择版本</span><br><span class="line">#推荐安装Node12的最新版，因为使用Node14的时候可能搭配一些主题会报Warning，虽然影响不大，但是看着心里不舒服</span><br><span class="line">nvs ls    #列出安装的版本</span><br><span class="line">#找到你刚才安装的node12版本，复制完整名字(我这里以在华为源下载的Node12为例)</span><br><span class="line">nvs link node-huawei/<span class="number">12</span>.<span class="number">20</span>.<span class="number">1</span>/x64  #将Node12设置为默认版本</span><br><span class="line">nvs use node-huawei/<span class="number">12</span>.<span class="number">20</span>.<span class="number">1</span>/x64   #启用Node12</span><br></pre></td></tr></table></figure><p>设置Node.js12为默认环境：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105626.png" alt="image-20210209102532992"></p><p>“node/14.15.4/x64 (Fermium)”运行Hexo(使用主题Butterfly)时报的warning如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105629.png" alt="image-20210209100524704"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/  #设置为华为云仓库镜像源</span><br><span class="line">npm config list     #查看设置是否成功</span><br><span class="line">npm i hexo-cli -g   #全局安装hexo</span><br></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><blockquote><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105632.png" alt="image-20210209104714570"></p><p>如果访问官网的下载速度过慢，可以从各大镜像网站下载，比如华为开源镜像站：</p><blockquote><p>华为开源镜像站 Git for Windows ：<a href="https://repo.huaweicloud.com/git-for-windows/">https://repo.huaweicloud.com/git-for-windows/</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105635.png" alt="image-20210209105002268"></p><p>安装步骤不做演示。</p><h2 id="本地搭建Hexo博客"><a href="#本地搭建Hexo博客" class="headerlink" title="本地搭建Hexo博客"></a>本地搭建Hexo博客</h2><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>新建一个文件夹来作为你的本地Hexo博客，你的所有Hexo博客内容都应该存放在这个文件夹中。</p><p>比如我新建了一个名为“Hexo-Test”的文件夹，那么我的所有博客内容都在这个文件夹里。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110110.png" alt="image-20210209110110769"></p><p>打开Windows终端，通过“cd”指令到达这个文件夹；或者在这个文件夹中摁着SHIFT再右键，选择“在此处打开PowerShell窗口”。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init   #初始化Hexo博客，这个文件夹需要是空文件夹</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110643.png" alt="image-20210209110643678"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install  # 安装依赖</span><br><span class="line">hexo s       #本地运行hexo博客</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110809.png" alt="image-20210209110809527"></p><p>如图所示，本地访问端口是<a href="http://localhost:4000/">http://localhost:4000</a>，运行时在浏览器打开这个网址，就可以查看Hexo博客了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110928.png" alt="image-20210209110927913"></p><h3 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h3><p>以下仅列出几个我认为有必要改的_config.yml文件中的内容：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>       <span class="comment">#博客标题</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#博客作者，改成自己名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span>      <span class="comment">#博客语言，中文是 zh-CN</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://leok77.github.io</span>   <span class="comment">#你要发布到哪儿，比如我用GitHubPages，就是这个网址，把“leok77”修改为你的用户名即可</span></span><br><span class="line"><span class="comment"># THEME</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>  <span class="comment">#这个是默认主题，可以自己换个好看/高效的主题</span></span><br></pre></td></tr></table></figure><h3 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h3><h4 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h4><blockquote><p>GitHub：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a><br>主题首页：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p></blockquote><p>美化效果很好的一个主题，功能集成也比较完善，我现在使用的就是这个主题(然而我追求简洁又懒，所以把绚丽的动画效果都关了)，主题首页有相应的配置教程，真的是“手把手”教你怎么把这个主题配置好，总之就是非常棒。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112138.png" alt="image-20210209112137677"></p><p>我在使用的时候是将配置文件另存到了博客根目录，这样在升级主题的时候就不需要担心自己的配置文件被默认文件覆盖了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210321101154.png" alt="image-20210321101153977"></p><h5 id="适用于Butterfly的繁体转换脚本"><a href="#适用于Butterfly的繁体转换脚本" class="headerlink" title="适用于Butterfly的繁体转换脚本"></a>适用于Butterfly的繁体转换脚本</h5><p>因为Butterfly的配置文件默认是繁体字，而我使用简体字，所以我需要将其转换为简体字之后才可以更好的阅读和使用，这里用的是开源的openCC库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> opencc <span class="keyword">import</span> OpenCC  <span class="comment"># opencc开源简繁转换</span></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> path_analysis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tradition_to_simple</span>(<span class="params">filename=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># 转换为绝对路径</span></span><br><span class="line">    abspath_src = os.path.abspath(filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! FILE ** &#x27;</span> + abspath_src + <span class="string">&#x27; ** NOT EXIST&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    abspath_dst = path_analysis.get_abspath_dst(abspath_src)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式是繁体转化为简体</span></span><br><span class="line">    converter = OpenCC(<span class="string">&#x27;t2s.json&#x27;</span>)</span><br><span class="line">    <span class="comment"># 逐行转化并写入到目标文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(abspath_dst, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> dst:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath_src, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> src:</span><br><span class="line">            <span class="keyword">for</span> sentence <span class="keyword">in</span> src:</span><br><span class="line">                dst.write(converter.convert(sentence))</span><br><span class="line"></span><br><span class="line">    path_analysis.replace_or_not(abspath_src, abspath_dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Hexo主题Butterfly配置文件简体化</span></span><br><span class="line">    <span class="comment"># 主题本身默认配置文件路径：&quot;博客文件夹/node_mpdules/hexo-theme-butterfly/_config.yml&quot;</span></span><br><span class="line">    filename =  <span class="string">r&#x27;C:\Users\LeoK77\Documents\WorkSpace\Blog-Hexo-LeoK77\node_modules\hexo-theme-butterfly\_config.yml&#x27;</span></span><br><span class="line">    tradition_to_simple(filename)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Matery"><a href="#Matery" class="headerlink" title="Matery"></a>Matery</h4><blockquote><p>GitHub：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a><br>主题首页：<a href="https://blinkfox.github.io/">https://blinkfox.github.io/</a></p></blockquote><p>美化效果好，有较为详细的教程，但是我没弄明白那个头部的“彩虹换色”怎么关，导致我放的壁纸在动态换色下显得特别呆，所以就没继续用这个主题。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112507.png" alt="image-20210209112507105"></p><h4 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h4><blockquote><p>GitHub：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a><br>主题旧版首页：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a><br>主题首页：<a href="https://theme-next.org/">https://theme-next.org/</a></p></blockquote><p>如果你去搜Hexo的教程或者视频，那么他们推荐的主题很可能就是NexT，这是一个十分简约的主题，但是提供极多的插件，这也就意味着高度定制性，你只需要安装你想要的功能，无论是简约还是绚丽美化，NexT都可以做到。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112730.png" alt="image-20210209112730265"></p><h2 id="推送Hexo博客到GitHub"><a href="#推送Hexo博客到GitHub" class="headerlink" title="推送Hexo博客到GitHub"></a>推送Hexo博客到GitHub</h2><h3 id="新建GitHub库"><a href="#新建GitHub库" class="headerlink" title="新建GitHub库"></a>新建GitHub库</h3><p>需要在自己的GitHub中新建一个“username.github.io”的public仓库，比如我的用户名是leok77，那么我的仓库是“leok77.github.io”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209113852.png" alt="image-20210209113852130"></p><h3 id="推送到GitHub"><a href="#推送到GitHub" class="headerlink" title="推送到GitHub"></a>推送到GitHub</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git --save    #安装hexo-deployer-git插件</span><br></pre></td></tr></table></figure><p>配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span>     <span class="comment">#方式</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#分支 - 都呼吁分支名改为 main</span></span><br><span class="line">  <span class="comment">#同时推送到多个仓库</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://gitee.com/username/username.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>推送到GitHub：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean    #清除旧内容</span><br><span class="line">hexo g        #创建新网页</span><br><span class="line">hexo d        #推送到GitHub</span><br></pre></td></tr></table></figure><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h3><p>在Hexo博客文件夹下打开命令行，执行”hexo new title”命令，其中title是你想起的博客名字。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210321092626.png" alt="image-20210321092626437"></p><p>然后根据输出提示的博文地址前去打开编辑即可，我使用的Markdown编辑器是<strong>VSCode</strong>和<strong>Typora</strong>；至于Markdown语法我就不赘述了，一搜一大把。</p><h3 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h3><p>如果你希望自己的博文文件在生成时就带着自己自定义的内容，那么可以通过修改默认模板文件来解决。</p><p>进入”博客文件夹/scaffolds”目录，先将”post.md”文件备份一下，比如我这里将它另存为了”post_default”，以后想退回到默认post文件时可以直接替换。</p><p>下面是我的模板文件，相比源模板增加的内容并不多，但是较为实用：</p><ul><li>title：我在创建文章的时候<strong>title</strong>其实是<strong>categories/title</strong></li><li>author：作者名字</li><li>categories：分类 - 设置为default是为了这一栏不会因为是空的而被放到最后</li><li>tags：标签 - 设置为default同理</li><li>description：描述，这里我设置为 categories/title ，与我gitee的图床仓库地址对应</li><li>cover：这个是Butterfly主题带的封面图片</li><li>date：创建日期</li><li>updated：更新日期，如果不设置更新日期的话，那么之后更换设备的时候，文章更新日期就会全变成最新日期了</li></ul><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">author: LeoK77</span><br><span class="line">categories: default</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    -</span> default</span><br><span class="line">description: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br></pre></td></tr></table></figure><p>设置后再使用hexo new的时候，就不用自己手动添加这些内容了，依次修改对应项即可。</p><h3 id="草稿文件夹"><a href="#草稿文件夹" class="headerlink" title="草稿文件夹"></a>草稿文件夹</h3><blockquote><p>是否存在有的博文先写好而有的博文还没写完的情况？而又不想等到最后一起发布？那么这时候就需要草稿文件夹了。</p></blockquote><p>在”博客文件夹/source/“目录下新建”_drafts”文件夹，将还不想发布的放到这个文件夹内即可，这样在推送博文的时候只需要控制好哪些在”_posts”(要发布)和哪些在”_drafts”(草稿文件夹，不发布)即可。</p><p>如果想使用命令进行控制的话，可以参见<a href="https://hexo.io/zh-cn/docs/writing#%E8%8D%89%E7%A8%BF">hexo文档</a>，但我习惯自己手动换了(之前用hexo-admin插件替换控制草稿的时候，我的博文文件总是会第一行被它干掉，搞的我很不爽，就不用命令了，还是自己手动换不会出错)。</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><blockquote><p>插入图片我有写一篇博文单独讲述如何使用Gitee作为图床，这里我就不做赘述了，想看的话可以去看那篇文章。</p></blockquote><p>博文链接：<a href="https://leok77.github.io/2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/">使用Gitee+PicGo搭建图床</a></p><p>如果想使用资源文件夹(相对路径，图片存储在GitHub上)的话，可以参加<a href="https://hexo.io/zh-cn/docs/asset-folders">Hexo文档</a>，我这里也不赘述了。但是需要注意的是图片存储在GitHub的情况下可能会导致访问速度慢，我就是因为图片加载特别慢才使用Gitee当免费图床，有预算的话可以考虑下七牛云、阿里云、腾讯云等的对象云存储，可惜我知道的时候已经不能白嫖了，所以我选择白嫖Gitee(暴论)。</p>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行基础</title>
      <link href="2021/02/08/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/"/>
      <url>2021/02/08/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux命令基础知识"><a href="#Linux命令基础知识" class="headerlink" title="Linux命令基础知识"></a>Linux命令基础知识</h2><p>GUI：Graphical User Interface - 图形用户界面<br>CUI：Command Line Interface - 命令行界面</p><h3 id="Linux命令语法格式"><a href="#Linux命令语法格式" class="headerlink" title="Linux命令语法格式"></a>Linux命令语法格式</h3><p>命令格式：命令 [-选项] [参数]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line">ls -a /etc  <span class="comment">#列出“/etc”文件夹下的所有文件</span></span><br><span class="line"><span class="comment">#“选项”分为“简化选项&#x27;-&#x27;”和“完整选项&#x27;--&#x27;”，如“-a”等价与“--all”</span></span><br></pre></td></tr></table></figure><h3 id="Linux命令行操作技巧"><a href="#Linux命令行操作技巧" class="headerlink" title="Linux命令行操作技巧"></a>Linux命令行操作技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#光标</span><br><span class="line">Home      #移动光标到本行开头</span><br><span class="line">Ctrl + A  #移动光标到行首</span><br><span class="line">Ctrl + E  #移动光标到行尾</span><br><span class="line">Ctrl + C  #终止当前程序</span><br><span class="line">Ctrl + L  #清理屏幕显示</span><br></pre></td></tr></table></figure><h3 id="Linux命令分类"><a href="#Linux命令分类" class="headerlink" title="Linux命令分类"></a>Linux命令分类</h3><table><thead><tr><th>分类</th><th>命令</th></tr></thead><tbody><tr><td>登录和电源管理</td><td>login、shutdown、halt、reboot、install、exit、last等</td></tr><tr><td>文件处理</td><td>file、mkdir、grep、dd、find、mv、ls、diff、cat、ln等</td></tr><tr><td>系统管理</td><td>df、top、free、quote、at、ip、kill、crontab等</td></tr><tr><td>网络操作</td><td>ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup等</td></tr><tr><td>系统安全</td><td>passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who等</td></tr><tr><td>其他</td><td>tar、unzip、gunzip、unarj、motools、man等</td></tr></tbody></table><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="登录命令"><a href="#登录命令" class="headerlink" title="登录命令"></a>登录命令</h3><h4 id="login"><a href="#login" class="headerlink" title="login"></a>login</h4><p>作用：登录系统。<br>权限：所有用户。</p><p>Linux是多用户操作系统，可以同时接受多个用户登录，允许一个用户多次登录。每个虚拟控制台可以看作一个独立工作站，工作台之间可以切换。虚拟控制台的切换可以通过按下“Alt”键及功能键(通常是F1~F6)来实现。</p><p>虚拟控制台的好处：一个程序出错造成系统死锁时，可以切换到其他虚拟控制台工作，关闭这个程序。</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>作用：显示近期用户或终端的登录情况。管理员可以通过last查看该程序的log，获知谁曾经或企图连接系统。<br>权限：所有用户。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>作用：退出系统，没有参数，运行后退出系统进入登录界面。<br>权限：所有用户。</p><h3 id="电源管理命令"><a href="#电源管理命令" class="headerlink" title="电源管理命令"></a>电源管理命令</h3><h4 id="shutdow"><a href="#shutdow" class="headerlink" title="shutdow"></a>shutdow</h4><p>作用：关闭计算机。<br>权限：超级用户。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown [-t seconds] [option] time [message]</span><br><span class="line">-t seconds   <span class="comment">#在改变到其他运行级别之前，告诉init程序多久后关机</span></span><br><span class="line">-r           <span class="comment">#关机后打开电源(重启)</span></span><br><span class="line">-h           <span class="comment">#关机后关闭电源</span></span><br><span class="line">-F           <span class="comment">#在重启计算机时强迫fsck</span></span><br><span class="line"><span class="comment">#fsck(File System Check)命令用于检查与修复Linux档案系统，可以同时检查一个或多个Linux档案系统。</span></span><br><span class="line">time          <span class="comment">#设定关机前的时间</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">message       <span class="comment">#传送给使用者的警告讯息</span></span><br></pre></td></tr></table></figure><p>系统关机前使用shutdown命令，系统管理员会通知所有登录的用户系统将要关闭，并且login指令会被冻结，即新的用户不能再登录</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>作用：关闭系统。<br>权限：超级用户。</p><p>halt执行时，杀死应用进程，执行sync(将存于buffer中的资料强制写入硬盘中)系统调用，文件系统读写操作完成后停止内核。若系统运行级别为0或6，则关闭系统；否则以shutdown指令(shutdown -h)取代。</p><p>sync命令：强制将内存缓冲区中的数据立即写入磁盘<br>fsck命令：检查并试图修复文件系统中的错误<br>超级块位于块组最前面，描述文件系统整体信息的数据结构<br>/var/log/wtmp是一个二进制文件，记录每个用户的登录次数和持续时间等信息</p><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>作用：重新启动计算机。<br>权限：系统管理者。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-n  <span class="comment">#保存数据后重启</span></span><br><span class="line">-w  <span class="comment">#不重启，仅记录写入到/var/log/wtmp文件中</span></span><br><span class="line">-d  <span class="comment">#不把记录写入到/var/log/wtmp文件中</span></span><br><span class="line">-i  <span class="comment">#关闭网络设置后再重启</span></span><br></pre></td></tr></table></figure><h3 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h3><h4 id="Linux文件目录结构"><a href="#Linux文件目录结构" class="headerlink" title="Linux文件目录结构"></a>Linux文件目录结构</h4><p>Linux系统中一切皆文件，其文件目录结构是树形， “/” 是根目录</p><table><thead><tr><th>文件目录</th><th>解释</th></tr></thead><tbody><tr><td>/bin</td><td>bin是Binary的缩写，存放最常用的命令</td></tr><tr><td>/boot</td><td>启动Linux时的一些核心文件，包括连接文件和镜像文件</td></tr><tr><td>/dev</td><td>Device的缩写，存放外部设备。</td></tr><tr><td>/etc</td><td>存放所有系统管理所需要的配置文件和子目录</td></tr><tr><td>/home</td><td>用户主目录</td></tr><tr><td>/lib</td><td>存放系统最基本的动态连接共享库</td></tr><tr><td>/media</td><td>Linux系统自动识别设备之后，挂载到这个目录下</td></tr><tr><td>/mnt</td><td>让用户临时挂载别的文件系统</td></tr><tr><td>/opt</td><td>给主机额外安装软件的目录</td></tr><tr><td>/proc</td><td>系统内存映射的虚拟目录，获取系统信息</td></tr><tr><td>/root</td><td>系统管理员/超级权限者的用户主目录</td></tr><tr><td>/run</td><td>临时文件系统，存储系统启动以来的信息。若有/var/run目录，则指向/run</td></tr><tr><td>/sbin</td><td>存放系统管理员的系统管理程序</td></tr><tr><td>/srv</td><td>存放一些服务启动后需要提取的数据</td></tr><tr><td>/sys</td><td>Linux2.6内核后，新出现文件系统sysfs</td></tr><tr><td>/tmp</td><td>用来存放一些临时文件</td></tr><tr><td>/usr</td><td>用户的应用程序和文件</td></tr><tr><td>/var</td><td>将经常被修改的目录存在这个目录下，包括各种日志文件</td></tr></tbody></table><h4 id="Linux文件路径"><a href="#Linux文件路径" class="headerlink" title="Linux文件路径"></a>Linux文件路径</h4><p>绝对路径：从/(根目录)开始的<br>相对路径：相对当前所在目录来说的路径</p><h4 id="Linux文件命令"><a href="#Linux文件命令" class="headerlink" title="Linux文件命令"></a>Linux文件命令</h4><h5 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h5><p>作用：打印当前的工作目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> -L  <span class="comment">#目录连接链接时，输出连接路径</span></span><br><span class="line"><span class="built_in">pwd</span> -P  <span class="comment">#输出物理路径</span></span><br></pre></td></tr></table></figure><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><p>作用：改变当前工作目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..   <span class="comment">#进入上一层目录</span></span><br><span class="line"><span class="built_in">cd</span> .    <span class="comment">#进入当前目录</span></span><br><span class="line"><span class="built_in">cd</span>      <span class="comment">#回到家目录</span></span><br><span class="line"><span class="built_in">cd</span> ~    <span class="comment">#回到家目录</span></span><br><span class="line"><span class="built_in">cd</span> -    <span class="comment">#进入前一个目录，两个目录之间快速切换</span></span><br></pre></td></tr></table></figure><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>作用：列出目录的内容或者文件的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls              <span class="comment">#列出当前目录下所有文件和目录(隐藏文件除外)</span></span><br><span class="line">ls -l           <span class="comment">#显示详细信息</span></span><br><span class="line">ls -l /         <span class="comment">#列出指定目录内容</span></span><br><span class="line">ls -l /bin/bash <span class="comment">#列出指定文件信息</span></span><br><span class="line">ls -l f1 f2     <span class="comment">#同时列出多个文件信息</span></span><br><span class="line">ls -ld /        <span class="comment">#列出指定目录信息</span></span><br><span class="line">ls -lh          <span class="comment">#-h用人类易读的格式显示大小信息</span></span><br><span class="line">ls -a           <span class="comment">#显示隐藏的文件和目录——包括.和..</span></span><br><span class="line">ls -t           <span class="comment">#按时间排序</span></span><br><span class="line">ls -S           <span class="comment">#按大小排序</span></span><br><span class="line">ls -X           <span class="comment">#按拓展名排序</span></span><br><span class="line">ls -1           <span class="comment">#一行显示一个文件</span></span><br></pre></td></tr></table></figure><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>作用：创建目录，若目录已存在则报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p dir1/dir2/dir3 <span class="comment">#若dir1、dir2不存在则一并创建</span></span><br><span class="line">mkdir -pv dir1/dir2     <span class="comment">#显示创建的过程</span></span><br></pre></td></tr></table></figure><h5 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h5><p>作用：创建空文件、修改文件时间戳</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch file      <span class="comment">#把file的时间戳改为当前时间</span></span><br><span class="line">touch -d <span class="string">&quot;2021-02-08 19:14:10&quot;</span> file <span class="comment">#把file的时间戳改为指定时间</span></span><br></pre></td></tr></table></figure><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>作用：复制文件或者目录  —— 高危命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp f1 f2      <span class="comment">#把文件f1复制一份，命名为f2</span></span><br><span class="line">cp f1 d1/     <span class="comment">#把文件f1复制到目录d1下</span></span><br><span class="line">cp f1 f2 d1/  <span class="comment">#把文件f1、f2复制到目录d1下</span></span><br><span class="line">cp -a f1 f2   <span class="comment">#-a保留源文件属性</span></span><br><span class="line">cp -i f1 f2   <span class="comment">#覆盖f2之前需要用户确认</span></span><br><span class="line">cp -r d1 d2   <span class="comment">#把目录d1复制一份，命名为d2</span></span><br><span class="line">cp -rv d1 d2  <span class="comment">#-v显示过程</span></span><br><span class="line">cp -rf d1 d2  <span class="comment">#无法打开已经存在的目标文件时删除目标文件然后重试</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把一个目录下众多子目录中的html文件全部复制出来，放到目录/data/html中</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">exec</span> cp &#123;&#125; /date/html/ \;    <span class="comment">#方法一，分号不能去掉</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> | xargs cp -t /data/html/     <span class="comment">#方法二，xargs及-t减少cp进程数</span></span><br></pre></td></tr></table></figure><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><p>作用：移动文件或者目录  —— 高危命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv f1 f2      <span class="comment">#将f1重命名为f2</span></span><br><span class="line">mv -b f1 f2   <span class="comment">#若f2已存在，则先备份文件</span></span><br><span class="line">mv -f f1 f2   <span class="comment">#若f2已存在，则直接覆盖</span></span><br><span class="line">mv -i f1 f2   <span class="comment">#若f2已存在，则询问是否覆盖</span></span><br></pre></td></tr></table></figure><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>作用：删除文件或者目录  —— 高危命令</p><p>注意：<strong>没有撤销删除操作</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f dir     <span class="comment">#忽略不存在的文件，不给出提示</span></span><br><span class="line">rm -r dir     <span class="comment">#递归删除dir下所有文件和目录</span></span><br><span class="line">rm -i dir     <span class="comment">#删除前询问</span></span><br><span class="line">rm -v dir     <span class="comment">#显示删除步骤</span></span><br><span class="line">rm -rf dir    <span class="comment">#递归删除且无需确认</span></span><br></pre></td></tr></table></figure><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><p>作用：读取文件的全部内容、将几个文件合并为一个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat file        <span class="comment">#读取file全部内容</span></span><br><span class="line">cat -A file     <span class="comment">#显示不可打印字符</span></span><br><span class="line">cat f1 f2 &gt; f2  <span class="comment">#将f1和f2的内容合并到f3</span></span><br></pre></td></tr></table></figure><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><p>作用：显示文件的开头内容，默认显示开头10行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head file       <span class="comment">#显示file开头内容</span></span><br><span class="line">head -n 3 file  <span class="comment">#显示file前3行</span></span><br><span class="line">head -c 3 file  <span class="comment">#显示file前3字节</span></span><br><span class="line">head -n -3 file <span class="comment">#显示file除了最后3行的所有内容</span></span><br></pre></td></tr></table></figure><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><p>作用：读取文件的尾部内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -n 3 file  <span class="comment">#显示file最后三行</span></span><br><span class="line">tail -n +3 file <span class="comment">#显示第三行到最后的所有内容</span></span><br><span class="line">tail -f file    <span class="comment">#跟踪file尾部变化显示</span></span><br><span class="line"><span class="comment">#后台ping，通过tail显示实时的ping信息</span></span><br><span class="line">ping cn.bing.com &gt; ping.log &amp;</span><br><span class="line">tail -f ping.log</span><br></pre></td></tr></table></figure><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>作用：以一页一页的方式逐页阅读文件内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter - 向下n行，默认是1行</span><br><span class="line">Ctrl+F - 向下滚动一屏</span><br><span class="line">SPACE - 向下滚动一屏</span><br><span class="line">Ctrl+B - 向上滚动一屏</span><br><span class="line">&#x3D; - 输出当前行的行号</span><br><span class="line">V - 调用vi编辑器</span><br><span class="line">!命令 - 调用shell命令并执行</span><br><span class="line">q - 退出more</span><br></pre></td></tr></table></figure><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><p>作用：读取内容，分屏显示，可以随意浏览文件，查看之前不加载整文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;string - 向下搜索string</span><br><span class="line">?string - 向上搜索string</span><br><span class="line">Q - 退出less</span><br><span class="line">SPACE - 滚动一页</span><br><span class="line">Enter - 滚动一行</span><br><span class="line">h - 显示帮助界面</span><br></pre></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>作用：在指定目录下查找文件</p><p>find [path…] [expression]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -name <span class="string">&quot;*book*&quot;</span>       <span class="comment">#查找名字包含book的文件</span></span><br><span class="line">find -user openEuler      <span class="comment">#查找所属用户是openEuler的文件</span></span><br><span class="line">find -empty               <span class="comment">#查找空文件及目录</span></span><br><span class="line">find -empty -delete       <span class="comment">#查找空文件并删除</span></span><br><span class="line">find -size 0              <span class="comment">#查找大小为0的文件</span></span><br><span class="line">find /etc -name <span class="string">&quot;*.html&quot;</span>  <span class="comment">#在/etc目录下查找.html类型的文件</span></span><br><span class="line">find -mtime +7            <span class="comment">#查找更改时间是7日以前的文件</span></span><br><span class="line">find -mtime -7            <span class="comment">#查找更改时间是7日之内的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">type</span> d    <span class="comment">#查找文件类型是目录的文件</span></span><br><span class="line">find -<span class="built_in">type</span> c    <span class="comment">#查找文件类型是字型装置文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> b    <span class="comment">#查找文件类型是区块装置文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> p    <span class="comment">#查找文件类型是具名贮存的文件</span></span><br><span class="line">find -<span class="built_in">type</span> f    <span class="comment">#查找文件类型是一般文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> l    <span class="comment">#查找文件类型是符号连结的文件</span></span><br></pre></td></tr></table></figure><h5 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h5><p>作用：快速的查找文件系统内是否有指定的文件<br>原理：先建立一个文件名及路径的数据库，查找时去这个数据库内查询<br>使用：使用之前要先updatedb一下来生成数据库，一般定时执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate openEuler    <span class="comment">#查找文件名中包含openEuler的文件</span></span><br><span class="line">locate /etc/sh      <span class="comment">#查找/etc目录下以sh开头的文件</span></span><br></pre></td></tr></table></figure><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p>作用：在PATH所指定的目录中查找可执行文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">cd</span>        <span class="comment">#查找cd命令文件</span></span><br><span class="line"><span class="built_in">which</span> -a <span class="built_in">cd</span>     <span class="comment">#列出所有cd文件</span></span><br><span class="line"><span class="built_in">which</span> cp mv rm  <span class="comment">#查找多个文件</span></span><br></pre></td></tr></table></figure><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p>作用：对单个文件或目录进行压缩或解压缩的命令，执行之后只有源文件或压缩后的文件，是对文件在原本位置压缩，压缩一个目录后是目录下的所有文件都变成了filename.gz。</p><p>gzip [option] [filename]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -d file      <span class="comment">#压缩file为file.gz</span></span><br><span class="line">gzip -f file      <span class="comment">#强行压缩file</span></span><br><span class="line">gzip -l file.gz   <span class="comment">#列出file.zip中的文件相关信息</span></span><br><span class="line">gzip -r dir       <span class="comment">#递归压缩dir</span></span><br><span class="line">gzip -rv dir      <span class="comment">#-v显示指令执行过程</span></span><br></pre></td></tr></table></figure><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><p>作用：打包文件，把多个文件打到一个包里，方便数据移动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cf dir.tar dir      <span class="comment">#把dir目录及其所有内容打包</span></span><br><span class="line">tar tf dir.tar          <span class="comment">#列出dir.tar下所有内容</span></span><br><span class="line">tar xf dir.tar          <span class="comment">#解包dir.tar到当前目录</span></span><br><span class="line">tar xf dir.tar -C /tmp  <span class="comment">#解包dir.tar到当前目录的/tmp目录下</span></span><br><span class="line">tar czf dir.tar.gz dir  <span class="comment">#打包dir并使用gzip压缩</span></span><br></pre></td></tr></table></figure><h5 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h5><p>作用：创建链接文件</p><p>软链接(symbolic link)：以路径形式存在(快捷方式)；删除源文件后链接失效；可以对目录进行链接；可以跨文件系统<br>硬链接(hard link)：以文件副本形式存在，不占用实际空间；删除源文件后影响；不可以对目录链接；不可以跨文件系统</p><p>ln适用场景：多个不同目录需要同一文件的场景，只需要某一固定目录放置该文件，其他目录ln命令设置link该文件，不必重复占用磁盘空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不带参数情况下默认创建硬链接</span></span><br><span class="line">ln sourcefile targetfile    <span class="comment">#创建硬链接</span></span><br><span class="line">ln -s sourcefile targetfile <span class="comment">#创建软链接</span></span><br></pre></td></tr></table></figure><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><table><thead><tr><th>序号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>使用者在shell中可以操作的指令或程序</td></tr><tr><td>2</td><td>系统核心可调用的函数与工具等</td></tr><tr><td>3</td><td>常用的函数(function)和函数库(library)</td></tr><tr><td>4</td><td>设备文档的说明，通常是/dev下的文件</td></tr><tr><td>5</td><td>文件格式和约定</td></tr><tr><td>6</td><td>游戏(games)</td></tr><tr><td>7</td><td>杂项(包括宏和惯例)</td></tr><tr><td>8</td><td>系统管理命令(通常仅适用于root用户)</td></tr><tr><td>9</td><td>内核例程(非标准)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man sleep       <span class="comment">#查看sleep命令手册</span></span><br><span class="line">man 3 sleep     <span class="comment">#查看sleep命令库函数</span></span><br><span class="line"><span class="comment">#查找名字包含keyword的man文档</span></span><br><span class="line">man -k keyword</span><br><span class="line">find /usr/share/man -iname <span class="string">&quot;*keyword*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">pwd</span>      <span class="comment">#pwd命令的详细讲解</span></span><br><span class="line"><span class="built_in">help</span> -d <span class="built_in">pwd</span>   <span class="comment">#pwd命令简短主题描述</span></span><br><span class="line"><span class="built_in">help</span> -s <span class="built_in">pwd</span>   <span class="comment">#pwd命令简短语法描述</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Gitee+PicGo搭建图床</title>
      <link href="2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然Hexo可以设置相对路径引用存储图片，但是这样会把图片存储到Github上，而碍于国内对于Github的访问速度，博客中的图片加载起来十分的慢，而穷孩子用不起对象云存储，小型图床又怕跑路，所以把主意打到了Gitee身上</p></blockquote><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><p>如果没有Gitee账号的话自行注册一个，这里就不演示账号注册了。</p><blockquote><p>Gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p></blockquote><h3 id="新建图床仓库"><a href="#新建图床仓库" class="headerlink" title="新建图床仓库"></a>新建图床仓库</h3><h4 id="新建Public仓库"><a href="#新建Public仓库" class="headerlink" title="新建Public仓库"></a>新建Public仓库</h4><p>在Gitee主页左下角可以找到新建仓库按钮，点击之后即可新建一个开源(public)仓库，因为要制作的Hexo博客图床是希望所有人访问你的博客的时候都可以看到图片，如果设置为私有仓库别人就无法访问图片了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151233.png" alt="image-20210207152744099"></p><p>建议勾选“使用Readme文件初始化这个仓库”，因为PicGo在上传图片的时候需要Gitee中已经有相应的分支了，如果不初始化仓库，那么默认的“master”分支是不存在的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151242.png" alt="image-20210207152652438"></p><h4 id="修改分支名-可选项"><a href="#修改分支名-可选项" class="headerlink" title="修改分支名(可选项)"></a>修改分支名(可选项)</h4><p>如果你没有把仓库分支名更改为“main”的习惯，那么“新建图床仓库”这一部分就已经做完了，如果你希望你的仓库分支名是“main”，那么请继续操作。</p><p>仓库新建完毕之后会自动转到仓库页面，在这里点击如图所示位置的“分支”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151303.png" alt="image-20210207153332398"></p><p>在新弹出的分支设置窗口点击右侧的“新建分支”，分支名填“main”，然后将“main”分支设置为默认分支并删除“master”分支。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151305.png" alt="image-20210207153707974"></p><h3 id="设置私人令牌"><a href="#设置私人令牌" class="headerlink" title="设置私人令牌"></a>设置私人令牌</h3><p>点击网页右上角的头像，然后点击弹出的“设置”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151308.png" alt="image-20210207153737996"></p><p>下滑找到左侧的安全设置，并选择“私人令牌”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151311.png" alt="image-20210207153854720"></p><p>点击网页右上角的“新建私人令牌”，然后设置私人令牌的描述及权限，权限只给如图所示的这两个就可以了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151314.png" alt="image-20210207154031460"></p><p>如图所示区域就是你的私人令牌，使用PicGo上传图片到Gitee仓库中需要使用，<strong>此页面关闭后，Gitee就不会再显示私人令牌，自己复制下来保存好</strong>。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151317.png" alt="image-20210207154238116"></p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>PicGo需要Node.js，使用Hexo的都安装了Node.js了吧</p><blockquote><p>Node.js官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a><br>NVS(Node Version Switcher)：<a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a><br>PicGo官网：<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a><br>PicGo Github：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p></blockquote><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>无论是从官网下载PicGo还是从Github主页进去下载，最后都是要在Github上下载PicGo的Release，我此处下载的是“2.2.2”版本，并不是因为我2，而是因为这个是最新的稳定版，首页的“2.3.0-beta.4”是beta版，虽然功能更强大，但是beta不稳定啊，万一出了问题挂了不就不好了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151321.png" alt="image-20210207154920720"></p><p>下载下来之后安装win10程序的安装过程走的就行了，不做演示。</p><h3 id="安装picgo-plugin-github-plus插件"><a href="#安装picgo-plugin-github-plus插件" class="headerlink" title="安装picgo-plugin-github-plus插件"></a>安装picgo-plugin-github-plus插件</h3><p>打开PicGo主面板，按照如图所示顺序安装“github-plus”插件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151325.png" alt="image-20210207155559207"></p><p>安装成功之后重启应用。在系统托盘区域，右键PicGo的图标，然后点击重启应用，重启后他是默认在托盘区域的，需要手动点一下，然后就出来了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151328.png" alt="image-20210207155713915"></p><p>设置GithubPlus图床：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo &#x3D; username&#x2F;repository_name #用户名&#x2F;仓库名</span><br><span class="line">branch &#x3D; main                   #分支名字，如果前面没设置，那么这里用master即可</span><br><span class="line">token &#x3D; 私人令牌                #你前面设置的Gitee的私人令牌</span><br><span class="line">path &#x3D;                          #图片存储路径，如果不设置的话就会存储到主目录，建议分类</span><br><span class="line">origin &#x3D; gitee                  #选择gitee才会传到gitee</span><br></pre></td></tr></table></figure><p>如图所示区域就是我的“repo”——“leok77/blog-img-test”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151332.png" alt="image-20210207160704736"></p><p>设置path的好处就是图片存储的位置在文件夹里，而不是全都存在主目录，这样当自己手贱同一张图片多次上传，或者要修改某一篇博文的内容的时候，可以通过找对应文件夹，而不是看着全部的主目录两眼一抹黑。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151335.png" alt="image-20210207161022952"></p><p>我设置里的repo和我前面提的repo不完全一致是因为这里设置中的是我一在用的图床仓库，前面那是我为了演示新建的仓库，懒得换了(懒癌晚期)。记得将“GithubPlus”设置为默认。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151339.png" alt="image-20210207160104869"></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><blockquote><p>Typora官网：<a href="https://typora.io/">https://typora.io/</a></p></blockquote><p>我现在写博客是通过VSCode(我知道VSCode也有PicGo插件，但是我还没搞明白怎么让他传到Gitee上)，而博客中插入图片以及看Markdown都是通过Typora，因为Typora用来做阅读器十分的舒服，以及插入图片的时候可以配合PicGo直接上传，没有人想每次插入图片的时候，都打开PicGo——上传图片——等待连接——粘贴到博文中吧。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151343.png" alt="image-20210207162300664"></p><p>这样设置好之后，无论你是把图片直接拖动到Typora中，还是把Snipaste截图后的图片粘贴到Typora中，他都会自动帮你自动调用PicGo上传图片，并直接转化为可用的图片连接。</p><h2 id="Python脚本修改url字符转置"><a href="#Python脚本修改url字符转置" class="headerlink" title="Python脚本修改url字符转置"></a>Python脚本修改url字符转置</h2><blockquote><p>可能是我的设置原因或者更新了PicGo的原因，之前使用的时候生成的图片url默认就是中文，但是现在变成了特殊字符转置之后的，也就是我的图片连接变成了一串”%NN”串，虽然这样兼容的编辑器多了，但是影响可读性，索性写了个脚本转置回中文，写完博客后运行一下再发布，美滋滋。</p></blockquote><p>其中的”get_all_path”和”get_abspath_dst”本来是另一个脚本里面的，这里为了方便就放在一个文件里面了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得root_path目录下的所有文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_path</span>(<span class="params">root_path=<span class="string">&#x27;&#x27;</span>, all_path=<span class="literal">None</span></span>):</span></span><br><span class="line">    root_path = os.path.abspath(root_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root_path):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + root_path + <span class="string">&#x27; ** NOT EXIST!!&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> all_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        all_path = []</span><br><span class="line">    <span class="comment"># 如果是 文件 或者是 空文件夹，直接添加到all_path中</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(root_path) <span class="keyword">or</span> (<span class="keyword">not</span> os.listdir(root_path)):</span><br><span class="line">        all_path.append(root_path)</span><br><span class="line">    <span class="comment"># 如果是 非空文件夹 则遍历添加文件夹内部内容</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># os.walk的经典用法：对以root_path为根的每个目录进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(root_path):</span><br><span class="line">            <span class="keyword">for</span> dir_name <span class="keyword">in</span> dirs:</span><br><span class="line">                dir_path = os.path.join(root, dir_name)</span><br><span class="line">                <span class="comment"># 只将空文件夹填入all_path，非空文件夹会由内部文件路径填入all_path</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.listdir(dir_path):</span><br><span class="line">                    all_path.append(dir_path)</span><br><span class="line">            <span class="keyword">for</span> basename <span class="keyword">in</span> files:</span><br><span class="line">                all_path.append(os.path.join(root, basename))</span><br><span class="line">    <span class="keyword">return</span> all_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 abspath_dst ，在源文件名后面加日期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_abspath_dst</span>(<span class="params">abspath_src=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    abspath_src = os.path.abspath(abspath_src)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + abspath_src + <span class="string">&#x27;** NOT  EXIST!&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    root, ext = os.path.splitext(abspath_src)</span><br><span class="line">    abspath_dst = root + datetime.datetime.now().strftime(<span class="string">&#x27;-%Y-%m-%d-%H-%M-%S&#x27;</span>) + ext</span><br><span class="line">    <span class="keyword">return</span> abspath_dst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_escape_to_chinese</span>(<span class="params">filename=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    abspath_src = os.path.abspath(filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + abspath_src + <span class="string">&#x27; ** NOT EXIST!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    abspath_dst = get_abspath_dst(abspath_src)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(abspath_src)</span></span><br><span class="line">    <span class="comment"># print(abspath_dst)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(abspath_src, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath_dst, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> dst_file:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> src_file.readlines():</span><br><span class="line">                <span class="keyword">if</span> line.find(<span class="string">&#x27;http&#x27;</span>):</span><br><span class="line">                    dst_file.write(parse.unquote(line))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dst_file.write(line)</span><br><span class="line"></span><br><span class="line">    os.replace(abspath_dst, abspath_src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 博文所在文件夹 &quot;博客文件夹/source/_posts&quot;</span></span><br><span class="line">    <span class="comment"># 如果要将草稿文件夹一并处理，使用 &quot;博客文件夹/source&quot; 即可</span></span><br><span class="line">    root_path = <span class="string">r&#x27;C:/Users/LeoK77/Documents/WorkSpace/Blog-Hexo-LeoK77/source/_posts&#x27;</span></span><br><span class="line">    <span class="comment"># 获取目录下的所有文件路径</span></span><br><span class="line">    root_paths = get_all_path(root_path)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> root_paths:</span><br><span class="line">        basename, ext = os.path.splitext(path)</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">&#x27;.md&#x27;</span>:</span><br><span class="line">            <span class="comment"># 对 &quot;.md&quot; 即Markdown类型的文件进行url转置，变回中文字符</span></span><br><span class="line">            url_escape_to_chinese(path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：因为我本身就没想过要在gitee图床里带空格，所以我这里没考虑不转置空格的情况，而Markdown里一个内含空格的链接是会被断开的，所以如果有需求的话可以自己改一下</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用也很简单，将上述python代码保存为一个python文件，然后写完博文之后python跑一下即可；我这里将跑的代码保存为了一个bat文件放在桌面上，这样我只需要双击它就可以了。</p><ol><li>cd &quot;C:\Users\LeoK77\Documents\WorkSpace\PyCharm-Projects\ToolBox\&quot;<ol><li>上述代码在我电脑里储存在这个位置，由于我使用的时候是两个文件，并不像上面结合在了一起，所以我需要cd 到这个路径再跑代码</li></ol></li><li>python.exe .\urlEscape_by_urllib.py<ol><li>python运行即可</li></ol></li><li>pause<ol><li>这个是为了让窗口停顿一下，我好知道有没有出问题，不然窗口一闪而过，我不知道执行结果是好的还是坏的</li></ol></li></ol><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &quot;C:\Users\LeoK77\Documents\WorkSpace\PyCharm-Projects\ToolBox\&quot; &amp;&amp; python.exe .\urlEscape_by_urllib.py &amp;&amp; <span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210321095746.png" alt="image-20210321095745810"></p>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统的开发环境搭建</title>
      <link href="2021/02/07/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2021/02/07/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并不是所有的IDE都自带编译器，比如JetBrains家的CLion，虽然特别好用，但是Build时使用的编译器是需要自己配置(其实也不麻烦)，Win10平台不像Linux或MacOS可以直接一条命令安装，这里分享一下我电脑中的开发环境是如何搭建的以及个人比较推荐的IDE</p></blockquote><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><blockquote><p>既然是讨论Win10系统，那么我认为这里的C/C++的IDE可以分为两类，一类是Visual Studio；另一类就是其他IDE(使用TDM-GCC或其他类GCC编译器，而不是使用VS的编译器)</p></blockquote><h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><p>“巨硬”家的宇宙第一IDE，Win10环境下最强大的IDE没有之一(虽然我好像只有学C#的时候一直用他)，但是有些过于前卫——默认情况下写C程序的时候，scanf等函数是被禁用的(有安全漏洞)，需要自己关闭安全性检查，VS2015的时候可直接在创建项目的时候关闭，后来就需要自己设置了。</p><p>“scanf”函数报错如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152529.png" alt="image-20210207131119120"></p><h4 id="解决方法一-单文件"><a href="#解决方法一-单文件" class="headerlink" title="解决方法一 - 单文件"></a>解决方法一 - 单文件</h4><p>在要使用“scanf”等函数的文件首部添加如下语句：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152531.png" alt="image-20210207132051922"></p><h4 id="解决方法二-整个项目"><a href="#解决方法二-整个项目" class="headerlink" title="解决方法二 - 整个项目"></a>解决方法二 - 整个项目</h4><p>如果整个项目都是C语言项目，又不想用“scanf_s”替换“scanf”，那么可以在项目属性中添加规则，或者直接禁用SDL。</p><p>方法一、将“_CRT_SECURE_NO_WARNINGS”添加到预处理器中</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152534.png" alt="image-20210207132716500"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152537.png" alt="image-20210207132557514"></p><p>方法二、直接关闭“SDL检查”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152540.png" alt="image-20210207132904636"></p><h3 id="其他IDE及编译器"><a href="#其他IDE及编译器" class="headerlink" title="其他IDE及编译器"></a>其他IDE及编译器</h3><blockquote><p>除了第一个TDM-GCC是编译器外，后面的CLion、Code::Blocks都是IDE</p></blockquote><h4 id="编译器-TDM-GCC"><a href="#编译器-TDM-GCC" class="headerlink" title="编译器-TDM-GCC"></a>编译器-TDM-GCC</h4><blockquote><p>Windows系统下没有原生的GCC，所以需要MinGW、MinGW64、TDM-GCC之类的环境。<br>这里以TDM-GCC为例，主要是TDM-GCC的安装简单粗暴且没啥幺蛾子，并不是说MinGW(有些老)、MinGW64(托管在sourceforge让人眼花缭乱，不能一眼让人搞明白咋下载安装)</p></blockquote><p>TDM-GCC is a compiler suite for Microsoft Windows. It is a commonly recommended compiler in many books, both for beginners and more experienced programmers.<br>译文：TDM-GCC时一款适用于微软Windows系统的编译器。他在很多书中被广泛提及，对于初学者和进阶的程序员都十分的友好。  </p><blockquote><p>以上内容摘自TDM-GCC Wiki：<a href="https://en.wikipedia.org/wiki/TDM-GCC">https://en.wikipedia.org/wiki/TDM-GCC</a></p></blockquote><p>下载TDM-GCC直接去他的官网，点击官网首页的发行版，例如现在最新的发行版是“TDM-GCC 9.2.0 release”，点击之后可以看到下载按钮，选择“tdm64-gcc-9.2.0.exe”进行下载。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152555.png" alt="20210207122915"></p><blockquote><p>TDM-GCC官网：<a href="https://jmeubank.github.io/tdm-gcc/">https://jmeubank.github.io/tdm-gcc/</a></p></blockquote><p>下载下来的“tdm64-gcc-9.2.0.exe”本质上是一个管理器，你可以使用它管理电脑中的TDM-GCC。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152558.png" alt="20210207123052"></p><p>而且TDM-GCC会自动配置环境变量，在cmd下输入”gcc –version”，有如图所示内容就说明安装成功了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316204757.png" alt="image-20210316204757626"></p><h4 id="CLion——JetBrains的C-C-IDE"><a href="#CLion——JetBrains的C-C-IDE" class="headerlink" title="CLion——JetBrains的C/C++ IDE"></a>CLion——JetBrains的C/C++ IDE</h4><blockquote><p>CLion本身不带编译器，支持MinGW(MinGW、MinGW64、TDM-GCC(个人推荐))、Visual Studio、、CygWin等编译器(虽然部分不是编译器，但这里为了好表示，以上几个都视为编译器)，需要单独安装。</p></blockquote><p>如果你使用过IDEA(Java)或者PyCharm(Python)，那么你一定知道JetBrains(不知道的话我就当你知道了，总之就是一个公司的同系列产品)，CLion就是JetBrains旗下的一款专为C/C++开发的IDE，快捷键与IDEA基本一致，代码补全功能可以用“丧心病狂”来形容，十分的强大，至少我习惯了JetBrians家的IDE之后，用其他的环境写代码没有代码补全的情况下我感觉十分难受。</p><p>只可惜这款IDE不是免费的，且没有社区版，但是不要气馁，对于学生用户可以申请免费许可证(需要有教育邮箱，高校学生咨询学长或者老师，我们学校是一入校就分配了教育邮箱的)，只要用他写的程序不是用于商业用途，就可以随便用。</p><p>配置编译器：(Customize-&gt;All settings-&gt;)settings-&gt;Build-&gt;Toolchains，然后如图所示(虽然截图时我默认还是VS，但我现在只用TDM-GCC了)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152600.png" alt="20210207123343"></p><blockquote><p>JetBrains官网：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a><br>CLion：<a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a><br>JetBrains学生认证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a></p></blockquote><h4 id="VSCode——配合C-C-及Code-Runner插件"><a href="#VSCode——配合C-C-及Code-Runner插件" class="headerlink" title="VSCode——配合C/C++及Code Runner插件"></a>VSCode——配合C/C++及Code Runner插件</h4><p>严格意义上来说VSCode似乎算不上一个IDE，但是它安装插件之后又好像是个IDE，但对于我(目前)来说他本质上只是一个文本编辑器以及SSH工具，当且仅当我实在是不想建个项目或者懒得打开CLion的时候我会用VSCode跑一些测试代码。</p><p>我知道有很多带佬会教如何详细的配置VSCode如何成为一个特别好用的C/C++IDE，但是我只是浅尝辄止，所以我只安装C/C++、Code Runner插件以及装好TDM-GCC就够了，当然我这样做不适合写项目，但是我写项目还真不用VSCode。</p><p>在设置里配置好”在终端运行”(先按下”Ctrl+,”，然后输入”Code-runner: Run In Terminal”，将如图所示的地方打钩)，这个选项默认是false，如果不启用的话那么在运行程序时是无法输入内容的，因为默认是如下面第二图所示在”输出窗口(只读编辑器)”下运行的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316211023.png" alt="image-20210316211023124"></p><p>默认在输出窗口执行程序，按照上述设置好”Code-runner: Run In Terminal”后就可以在终端中输入输出了，我就不再单独截图演示了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316210420.png" alt="image-20210316210420383"></p><h4 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code::Blocks"></a>Code::Blocks</h4><p>Code::Blocks是一个开放源码的全功能的跨平台C/C++集成开发环境。Code::Blocks是开放源码软件。Code::Blocks由纯粹的C++语言开发完成，它使用了著名的图形界面库wxWidgets(3.x)版。对于追求完美的C++程序员，再也不必忍受Eclipse的缓慢。</p><blockquote><p>以上内容摘自CodeBlocks百度百科：<a href="https://baike.baidu.com/item/Code::Blocks/2131200">https://baike.baidu.com/item/Code::Blocks/2131200</a></p></blockquote><p>硬挑缺点的话那就是他没有中文版(有民间汉化，但是使用民间汉化之后有时会导致代码自动补全功能失灵的状况)，很多人推荐的IDE，我们学校机房电脑的上默认的IDE就有他。</p><blockquote><p>Code::Blocks官网：<a href="http://www.codeblocks.org/">http://www.codeblocks.org/</a></p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><blockquote><p>Python官网：<a href="https://www.python.org/">https://www.python.org/</a></p></blockquote><h3 id="下载Python"><a href="#下载Python" class="headerlink" title="下载Python"></a>下载Python</h3><p>下载Python可以通过微软应用商店、Python官网以及各大镜像源。我使用的是在Python官网下载。</p><blockquote><p>安装的时候建议选择”Add Python to PATH”，不然还得自己手动添加到PATH</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316211824.png" alt="image-20210316211824546"></p><h4 id="Python官网"><a href="#Python官网" class="headerlink" title="Python官网"></a>Python官网</h4><blockquote><p>Python - Windows：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p></blockquote><p>以Python 3.7.9 为例，我下载的时候会选择“x86_64”即64位，“executable installer”版，安装时不需要额外下载内容。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152604.png" alt="image-20210207190601060"></p><h4 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h4><p>以华为云为例，进入进入华为云的Python镜像源，找到要安装的Python版本，如Python3.7.9，则点击3.7.9，选择详细版本，对于华为云镜像源选择“python-3.7.9.exe”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152607.png" alt="image-20210207191126236"></p><blockquote><p>华为云 - Python：<a href="https://repo.huaweicloud.com/python/">https://repo.huaweicloud.com/python/</a></p></blockquote><h4 id="Windows应用商店"><a href="#Windows应用商店" class="headerlink" title="Windows应用商店"></a>Windows应用商店</h4><p>一般情况下，除非系统只允许安装应用商店的程序，或者实在是懒得去官网/镜像源下载，我不会从这儿下载python。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152609.png" alt="image-20210207190208372"></p><h3 id="pip切换为国内源"><a href="#pip切换为国内源" class="headerlink" title="pip切换为国内源"></a>pip切换为国内源</h3><h4 id="pip-config-命令-此方法需要-pip-V-gt-10-0-0"><a href="#pip-config-命令-此方法需要-pip-V-gt-10-0-0" class="headerlink" title="pip config 命令 - 此方法需要 pip -V &gt;= 10.0.0"></a>pip config 命令 - 此方法需要 pip -V &gt;= 10.0.0</h4><p>虽然说要求“pip -V &gt;= 10.0.0”，看起来好像门槛有些高，但是目前pip版本已经到“21.0.1”了</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152613.png" alt="image-20210207203833204"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install pip -U  #通过默认源升级pip</span><br><span class="line">#通过TUNA清华源更新pip</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br><span class="line">#设置pip的默认源为TUNA清华源</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">#设置pip的默认源为华为云</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="IDE——PyCharm"><a href="#IDE——PyCharm" class="headerlink" title="IDE——PyCharm"></a>IDE——PyCharm</h3><blockquote><p>虽然Python自带的IDLE好像功能就够用了，但是谁会嫌弃更好用的IDE(PyCharm)呢</p></blockquote><p>只需要知道PyCharm很好用就够了，而且PyCharm有可以免费使用的社区版(不涉及商业行为，学生还可以用教育邮箱申请使用专业版)，无论是项目管理还是代码补全等一系列小工具，JetBrains家的IDE永远都是首屈一指的。</p><blockquote><p>JetBrains官网：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a><br>CLion：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a><br>JetBrains学生认证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a></p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>感觉Java的要求没那么多，很多教程都说Win10里Java需要配置环境变量才能使用，但实际上只要没有在cmd里用Java的要求，没必要加环境变量。而且实测安装jre8他会自动配置好环境变量。</p><p>当电脑中有多个Java环境的时候，只要在IDE里选对应的Java环境就好了，这是跟路径有关的，而不是“唯一性”。环境变量实际上就是省去了输入父路径的功夫，如果使用的时候输入父路径，那么就相当于有这个环境变量了。</p><p>而“电脑中只可以有一个Java”，是只可以有一个“java.exe”在环境变量里，如果我既把“Java8”的路径添进入了，又把“Java11”的路径填进去了，那么这两个“java.exe”在执行的时候就冲突了，无法识别具体是哪个了。</p><p>比如我的电脑中，我将“C:\Program Files (x86)\Common Files\Oracle\Java\javapath”添加到了环境变量里，那么这个目录下的“java.exe”我就可以直接引用了。这时候，我是直接以“java”的形式调用，还是以“&amp; ‘C:\Program Files (x86)\Common Files\Oracle\Java\javapath\java.exe’”的形式(因为路径中有空格，所以看起来不太一样)调用这个“java.exe”，实际使用上是完全一致的，只是一个方便一个不方便罢了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152616.png" alt="image-20210207202022066"></p><h3 id="Java版本选择"><a href="#Java版本选择" class="headerlink" title="Java版本选择"></a>Java版本选择</h3><h4 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h4><p>很多项目都是采用Java8作为主要的Java，这是因为Java8相较于其他版本来说比较“老”，却一直被维护，所以他经久不衰，是目前来说的首选的“稳定版”，至于学习Java的话可以用新版，因为新版中有新的特性，Java8虽然稳定但是作为老版本来说总有被淘汰的一天。(我环境变量里是Java8是因为我MC服务器用Java8，别的不吹，就是稳定，虽然用Java15的时候也没遇到过崩的情况)</p><blockquote><p>Java8：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p></blockquote><h4 id="Java-新版本"><a href="#Java-新版本" class="headerlink" title="Java - 新版本"></a>Java - 新版本</h4><blockquote><p><a href="https://www.oracle.com/java/technologies/java-se-glance.html">https://www.oracle.com/java/technologies/java-se-glance.html</a></p></blockquote><h3 id="Java多版本问题"><a href="#Java多版本问题" class="headerlink" title="Java多版本问题"></a>Java多版本问题</h3><p>前面已经提到了JDK在安装的时候是会自动添加到环境变量里的，当电脑里有多个Java环境的时候，只需要把自己想要使用的那个Java环境调动到最前面就可以了(命令行里使用”java”命令的时候是在环境变量里从头开始找，找到第一个包含”Java”的就直接用，不考虑后面的)。</p><p>比如在如图所示的情况下，我在cmd下”java -version”的结果就是jdk15的结果，而如果我把jdk8放在第一个，那么就是默认jdk8了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316212859.png" alt="image-20210316212859639"></p><p>如图所示这两个路径里面的”javapth”目录下的”java.exe、javac.exe、javew.exe、jshell.exe”在我的理解下本质上是指向安装的jdk目录下的链接，所以完全可以自己建一个文件夹，然后在这个文件夹里创建自己想用的jdk的这四个应用程序的链接，然后把这个文件夹添加到环境变量PATH的首位，这样就可以直接调用自己想用的jdk了。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>其实我本人并没有写过Node.js的项目，但是用的Hexo、PicGo等软件需要使用Node.js。而Hexo使用新版的Node.js的时候会出现一些Warning，虽然影响不大，但是使用的时候终端全是Warning着实让人恼火，所以我需要使用旧版的Node.js，以免我以后需要学习这门语言的时候环境受到影响，所以我使用NVS(Node Version Swithcer)来管理我电脑中的Node.js。</p><h3 id="直接安装Node-js"><a href="#直接安装Node-js" class="headerlink" title="直接安装Node.js"></a>直接安装Node.js</h3><blockquote><p>Node.js官网：<a href="https://nodejs.org/">https://nodejs.org</a><br>Node.js - 淘宝镜像：<a href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a><br>Node.js - 华为云：<a href="https://repo.huaweicloud.com/nodejs/">https://repo.huaweicloud.com/nodejs/</a></p></blockquote><h3 id="NVS-Node-Version-Switcher——Node版本管理"><a href="#NVS-Node-Version-Switcher——Node版本管理" class="headerlink" title="NVS - Node Version Switcher——Node版本管理"></a>NVS - Node Version Switcher——Node版本管理</h3><p>NVS是Github上的一个开源项目，允许电脑中存在多个Node.js环境，并在使用时决定选择哪个作为默认环境，下载、安装及使用方法请参考官方文档，其实不用记住太多的命令，在终端里输入“nvs”就可以以一种友好的方式通过“nvs”管理不同版本的Node.js了，但是部分命令确实是仅仅用“nvs”无法解决的。</p><blockquote><p>NVS - Github：<a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a></p></blockquote><p>下面是我认为较为常用或者需要进行设置的地方：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nvs           #不带参数运行，有交互界面</span><br><span class="line">nvs remote    #查看nvs下载时使用的仓库</span><br><span class="line">nvs remote node-taobao https://npm.taobao.org/mirrors/node  #添加淘宝镜像源到nvs中</span><br><span class="line">nvs remote node-huawei https://repo.huaweicloud.com/nodejs/ #添加华为云镜像源到nvs中</span><br><span class="line">nvs add <span class="number">12</span>    #安装Node.js <span class="number">12</span></span><br><span class="line">nvs use <span class="number">12</span>    #使用Node.js <span class="number">12</span></span><br><span class="line">nvs link <span class="number">12</span>   #将Node.js <span class="number">12</span>设置为默认的Node.js</span><br><span class="line">#设置为默认的版本之后需要再nvs use <span class="number">12</span>一下</span><br><span class="line">nvs ls        #查看nvs安装的Node.js版本、正在用的版本、默认的版本</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152620.png" alt="image-20210207140942926"></p><h3 id="NPM国内源"><a href="#NPM国内源" class="headerlink" title="NPM国内源"></a>NPM国内源</h3><p>npm的默认下载仓库是<a href="https://registry.npmjs.org/">https://registry.npmjs.org</a>，访问速度不是那么的快，国内用户没有科学上网工具的话可以切换为淘宝仓库镜像源或者华为云镜像源等国内镜像源。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org   #设置为淘宝仓库镜像源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/  #设置为华为云仓库镜像源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org        #切换回默认源</span><br><span class="line">npm config list   #查看设置是否成功</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152624.png" alt="image-20210207174829067"></p><h3 id="npm-check管理包"><a href="#npm-check管理包" class="headerlink" title="npm-check管理包"></a>npm-check管理包</h3><p>对于我来说使用Node.js时，我没了解npm怎么才能十分优雅的查看自己正在使用的包有没有可以升级的，所以我安装了npn-check用来检测包是否有可用升级。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npm-check -g --save # 全局安装 npm-check</span><br><span class="line">npm-check -u # 在使用node.js的地方进行检查</span><br></pre></td></tr></table></figure><p>比如我使用的Hexo框架是需要nodejs的，那么在我的Hexo博客文件夹中，我可以使用上述命令检查是否有可升级的包，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210328124531.png" alt="image-20210328124531852"></p>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux非系统性命令记录</title>
      <link href="2021/02/06/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/06/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录在安装、配置及使用Linux的过程中所用到的一些命令，因为这些命令有些杂乱，所以并不是系统性的进行记录，而是把用到的都记录过来，方便以后查看</p></blockquote><h2 id="Linux通用"><a href="#Linux通用" class="headerlink" title="Linux通用"></a>Linux通用</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh -y   <span class="comment">#安装zsh</span></span><br><span class="line">chsh -s /bin/zsh username <span class="comment">#修改用户的默认终端为zsh</span></span><br><span class="line"><span class="comment">#下载并安装 oh-my-zsh</span></span><br><span class="line">wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><h4 id="VSCode-Remote-SSH"><a href="#VSCode-Remote-SSH" class="headerlink" title="VSCode Remote SSH"></a>VSCode Remote SSH</h4><p>需要在VSCode中安装插件“Remote SSH”或者直接安装“Remote Development”，这样就可以在VSCode中使用SSH了。</p><p>修改openEuler虚拟机内部的“/etc/ssh/sshd_config”，启用如下设置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AllowAgentForwarding yes</span><br><span class="line">AllowTcpForwarding yes</span><br><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure><p>刷新sshd服务状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><p>在启用的“Remote SSH”插件中按照cmd使用ssh的语法即可：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh username@ip -p port</span><br><span class="line">ssh leok77@<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">201</span> -p <span class="number">22</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216220339.png" alt="image-20210216220339336"></p><h4 id="authorized-keys-公钥登录"><a href="#authorized-keys-公钥登录" class="headerlink" title="authorized_keys - 公钥登录"></a>authorized_keys - 公钥登录</h4><h5 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\LeoK77\.ssh\</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216214734.png" alt="image-20210216213935122"></p><h5 id="上传到openEuler虚拟机"><a href="#上传到openEuler虚拟机" class="headerlink" title="上传到openEuler虚拟机"></a>上传到openEuler虚拟机</h5><p>在你的用户文件夹中新建“.ssh”文件夹，并将你的公钥“id_rsa.pub”上传到这个文件夹中，然后将“id_rsa.pub”写入到“authorized_keys”中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir ./.ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"><span class="comment">## 将前面生成的公钥上传到这个文件夹里，可以使用VSCode，也可以使用Xftp等软件</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>这样使用SSH登录的时候就不需要每次都输入密码了，仅限于你当前使用的机器。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216215533.png" alt="image-20210216215532960"></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>添加新用户到wheel组(管理员)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -g users -G wheel -s /bin/bash username</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户及其对应的文件目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel -f username</span><br></pre></td></tr></table></figure><h2 id="CentOS-openEuler"><a href="#CentOS-openEuler" class="headerlink" title="CentOS / openEuler"></a>CentOS / openEuler</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>设置静态IP，修改“/etc/sysconfig/network-scripts/ifcfg-enp0s3”文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## BOOTPROTO&#x3D;dhcp      #dhcp动态分配</span><br><span class="line">BOOTPROTO&#x3D;static      #static静态分配</span><br><span class="line">IPADDR&#x3D;192.168.0.121  #静态IP地址</span><br><span class="line">NETMASK&#x3D;255.255.255.0 #子网掩码</span><br><span class="line">GATEWAY&#x3D;192.168.0.1   #默认网关</span><br><span class="line">DNS1&#x3D;223.5.5.5        #阿里云公共DNS</span><br><span class="line">DNS2&#x3D;180.76.76.76     #腾讯公共DNS</span><br></pre></td></tr></table></figure><p>重新加载配置文件，并重启网卡，使设置生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli c reload     <span class="comment">#重新加载网络连接</span></span><br><span class="line">sudo nmcli c up enp0s3  <span class="comment">#重启网卡</span></span><br></pre></td></tr></table></figure><h4 id="防火墙-端口开放"><a href="#防火墙-端口开放" class="headerlink" title="防火墙 - 端口开放"></a>防火墙 - 端口开放</h4><h5 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld    <span class="comment">#查看firewalld服务状态</span></span><br><span class="line">systemctl start firewalld     <span class="comment">#开启firewalld服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld    <span class="comment">#firewalld服务开机自启</span></span><br><span class="line">systemctl is-enable firewalld <span class="comment">#查看firewalld服务开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld   <span class="comment">#禁止firewalld服务开机自启</span></span><br><span class="line">service firewalld start       <span class="comment">#开启firewalld服务</span></span><br><span class="line">service firewalld restart     <span class="comment">#重启firewalld服务</span></span><br><span class="line">service firewalld stop        <span class="comment">#关闭firewalld服务</span></span><br></pre></td></tr></table></figure><h5 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state        <span class="comment">#查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload       <span class="comment">#重载防火墙 - 更改规则后需要重载</span></span><br><span class="line">firewall-cmd --list-all     <span class="comment">#查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-ports   <span class="comment">#查看所有打开的端口</span></span><br><span class="line">firewall-cmd --add-port=25565/tcp --permanent     <span class="comment">#永久添加25565端口(全局)</span></span><br><span class="line">firewall-cmd --remove-port=25565/tcp --permanent  <span class="comment">#永久删除25565端口(全局)</span></span><br><span class="line">firewall-cmd --add-port=65001-65010/tcp --permanent      <span class="comment">#永久增加65001-65010端口(全局)</span></span><br><span class="line">firewall-cmd --zone=public --add-port=25565/tcp --permanent     <span class="comment">#永久添加25565端口(public)</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=25565/tcp --permanent  <span class="comment">#永久删除25565端口(public)</span></span><br></pre></td></tr></table></figure><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum makecache</span><br><span class="line">sudo yum grouplist</span><br><span class="line">sudo yum groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">./hello</span><br><span class="line">g++ -o hello-cpp hello.cpp</span><br><span class="line">./hello-cpp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinecraftJava版开服指北</title>
      <link href="2021/02/04/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/"/>
      <url>2021/02/04/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文以Win10平台为例，如果有在Linux系统下开服的要求(如各种云服务器)，可以把MC开服后的Server文件夹整个上传到Linux服务器上，然后执行相应命令即可<br>Minecraft Java Edition需要电脑中有Java环境，我使用的是Java8，Oracle Java8官方下载地址(需注册账号)：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p></blockquote><h2 id="原版服"><a href="#原版服" class="headerlink" title="原版服"></a>原版服</h2><h3 id="下载服务器核心-server-jar"><a href="#下载服务器核心-server-jar" class="headerlink" title="下载服务器核心 - server.jar"></a>下载服务器核心 - server.jar</h3><h4 id="Minecraft官方启动器下载server-jar"><a href="#Minecraft官方启动器下载server-jar" class="headerlink" title="Minecraft官方启动器下载server.jar"></a>Minecraft官方启动器下载server.jar</h4><p>这里不阐述官启本身的下载方式，仅展示如何通过官启下载对应版本的server.jar：</p><p>打开我的世界官方启动器，先点击“配置”，再点击“新建”，会出现新建页面，然后在如图所示位置先选择游戏版本，再点击“服务器”，就可以跳转到浏览器下载对应游戏版本的“server.jar”了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153605.png" alt="image-20210204193616825"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153609.png" alt="image-20210204193755584"></p><h4 id="我的世界中文Wiki下载server-jar"><a href="#我的世界中文Wiki下载server-jar" class="headerlink" title="我的世界中文Wiki下载server.jar"></a>我的世界中文Wiki下载server.jar</h4><blockquote><p>我的世界中文Wiki：<a href="https://minecraft-zh.gamepedia.com/Minecraft_Wiki">https://minecraft-zh.gamepedia.com/Minecraft_Wiki</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153611.png" alt="image-20210204194521618"></p><h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>把server.jar放到一个文件夹中，比如我这里是 C:/Games/MinecraftServer 那么整个“MinecraftServer”文件夹就是这个服务器的文件夹。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153714.png" alt="image-20210204194845865"></p><p>打开cmd，cd到这个文件夹中，执行命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx2G -jar server.jar nogui</span><br><span class="line"># 内存大小可以自己设置，我本地单人服务端是这样设置的</span><br><span class="line">-Xms512M:   #分配最小内存<span class="number">512</span>M</span><br><span class="line">-Xmx2G:     #分配最大内存<span class="number">2</span>G</span><br><span class="line"><span class="function">nogui:      #服务器信息都在命令行输出，没有<span class="title">GUI</span></span></span><br></pre></td></tr></table></figure><p>你会发现服务器并没有完全启动起来，这是因为第一次启动服务端之后需要配置“eula.txt”以及“server.properties”文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153616.png" alt="image-20210204195452726"></p><p>修改“eula.txt”：打开此文件，将其中的“eula=false”修改为“eula=true”：</p><p>文件内容大致意思就是说不同意MOJANG的最终用户许可协议就不可以开服，设置为true后就是同意了，没得选，想开服只能同意</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153619.png" alt="image-20210204195833961"></p><p>此时就可以再次执行上面那条命令开服了，但是如果想对服务器做一些“定制”的话，需要修改一下“server.properties”文件再开服，此文件可以通过win10自带的“记事本”打开，文件每个属性各代表什么可以参考我的世界中文Wiki中的内容，这里仅指出几个我认为比较重要的：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">difficulty</span>=<span class="string">3    # 游戏难度改为“困难”，因为此模式下村民才可以百分之百转化成僵尸村民</span></span><br><span class="line"><span class="meta">level-seed</span>=     <span class="string"># 游戏种子，如果你希望使用特定的种子开服，那么填到这里</span></span><br><span class="line"><span class="meta">max-players</span>=<span class="string">5   # 服务器同时容纳的最大玩家数量，同时最多有多少个人可以在线</span></span><br><span class="line"><span class="attr">motd</span>=<span class="string">A Minecraft Server # 服务器的描述，在客户端的“多人游戏”那里可以看到这句话</span></span><br><span class="line"><span class="meta">online-mode</span>=<span class="string">true    # 可以理解为正版验证</span></span><br><span class="line"><span class="meta">server-ip</span>=          <span class="string"># 服务器IP，一般空着</span></span><br><span class="line"><span class="meta">server-port</span>=<span class="string">25565   # 服务器端口，如我本地访问的时候就是 127.0.0.1:25565</span></span><br><span class="line"><span class="meta">view-distance</span>=<span class="string">10    # 视距，服务器出现卡顿的情况下可缩小此值，一般建议默认</span></span><br><span class="line"><span class="meta">white-list</span>=<span class="string">true     # 开启白名单，以免奇奇怪怪的人进来</span></span><br><span class="line"><span class="meta">enforce-whitelist</span>=<span class="string">true  # 不在白名单列表中的用户会被踢出服务器</span></span><br></pre></td></tr></table></figure><p>注：<strong>如果你想给server.properties文件打注释的话，建议备份一下，然后把注释打到备份的文件里，不然你会发现运行之后你的注释都没了，文件中你自己调的属性顺序也都变回默认的了，当然属性值还是你自己设置的</strong></p><blockquote><p>我的世界中文Wiki - Server.properties：<a href="https://minecraft-zh.gamepedia.com/Server.properties">https://minecraft-zh.gamepedia.com/Server.properties</a></p></blockquote><p>设置好后就可以再次通过前面执行的命令开服了。</p><p>如果开启了白名单，则需要在终端运行时的服务端使用 /whitelist add username 的形式添加白名单，或者直接修改服务器文件夹下的 whitelist.json 文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153622.png" alt="image-20210204202458114"></p><p>关闭服务器时在运行着的服务器终端输入 /stop 即可。</p><p>可以把运行服务器的命令放到一个 .bat 文件中，这样可以直接在win10系统下运行这个 .bat 文件来开启服务端：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153625.png" alt="image-20210204203002984"></p><h3 id="部署到Linux服务器"><a href="#部署到Linux服务器" class="headerlink" title="部署到Linux服务器"></a>部署到Linux服务器</h3><blockquote><p>由于我没有买阿里云或者腾讯云、华为云的云服务器，所以这里我使用Linux虚拟机来代替</p></blockquote><p>需要设置或知道的云服务器信息：</p><ul><li>服务器IP地址 - 公网IP，云服务器会给分配</li><li>服务器开启SSH服务 - 一般此服务默认开启</li><li>服务器用户名和密码 - 服务器里一个用户的用户名和密码(最好不是root用户)</li></ul><p>我使用的工具：Xshell、Xftp。家庭、个人或学生不作为商业用途可以免费使用。</p><blockquote><p>软件官网：<br>Xshell：<a href="https://www.netsarang.com/zh/xshell/">https://www.netsarang.com/zh/xshell/</a><br>Xftp：<a href="https://www.netsarang.com/zh/xftp/">https://www.netsarang.com/zh/xftp/</a></p></blockquote><p>通过Xshell链接到Linux系统</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153627.png" alt="image-20210204204514595"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153630.png" alt="image-20210204204542724"></p><p>连接成功后的界面应如图所示(示例中的Linux系统是Ubuntu Server LTS 20.04)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153632.png" alt="image-20210204205030197"></p><p>通过Xftp上传Server文件夹 - 建议先将文件夹压缩成ZIP包，再上传到服务器解压</p><p>直接拖动过去就可以执行上传操作，速度与带宽有关</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153635.png" alt="image-20210204205219967"></p><p>回到Xshell中，安装java8及unzip：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-8-jdk unzip</span><br></pre></td></tr></table></figure><p>安装结束之后查看java版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>解压服务端压缩包到指定文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip MinecraftServer.zip -d MinecraftServer</span><br></pre></td></tr></table></figure><p>cd到服务端文件夹，新建一个screen：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MinecraftServer/</span><br><span class="line">screen -S MC_server <span class="comment"># 这样当SSH关闭的时候，MC服务端依旧会在云服务器上运行</span></span><br></pre></td></tr></table></figure><p>查看服务器内存大小后，修改开服命令参数再执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>输出结果以M为单位，根据自己服务器的内存大小来定，比如我这里可以设置为最大内存1G。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153639.png" alt="image-20210204211651280"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx1G -jar server.jar nogui</span><br></pre></td></tr></table></figure><p>云服务器上执行的很慢属于正常现象，毕竟如果一年一百出头的云电脑能打得过几千块的笔记本的话，那还要啥实体机。</p><p>比如我此处的Linux系统IP地址是192.168.0.131，Minecraft服务器端口号是默认的25565，开放对应端口后(云服务器需要在控制台的安全组策略中开放对应端口，不然无法访问)，我就可以通过192.168.0.131:25565链接服务器了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153642.png" alt="image-20210204213113871"></p><p>之后远程链接云服务器进行控制的时候，只需要执行“screen -R”就可以恢复之前创建的后台运行的程序了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -R</span><br></pre></td></tr></table></figure><h2 id="Fabric-mod服"><a href="#Fabric-mod服" class="headerlink" title="Fabric mod服"></a>Fabric mod服</h2><blockquote><p>我本地的单人服务端就是一个Fabric端，其中我添加了一些优化mod，获得了一些不是那么原版的功能以及对服务器的优化，所以Fabric端某种意义上也是原版端。<br>如果开Fabric服的话，除了原版服部分下载server.jar的两种方法以外，此处也可通过fabric下载server.jar</p></blockquote><h3 id="下载并安装Fabric"><a href="#下载并安装Fabric" class="headerlink" title="下载并安装Fabric"></a>下载并安装Fabric</h3><p>进入Fabric官网，点击如图所示下载fabric安装器</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153647.png" alt="image-20210205111007615"></p><blockquote><p>Fabric官网：<a href="https://fabricmc.net/use/">https://fabricmc.net/use/</a></p></blockquote><p>打开安装器，执行安装操作：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153650.png" alt="image-20210205112321558"></p><p>安装过程如果无科学上网的话会比较慢，但是可以下载完成，耐心等待即可。</p><p>如果没有下载服务端，则可以在此处下载“server.jar”核心文件，根据提示，需要将开服命令中的“server.jar”文字替换为“fabric-server-launch.jar”，注意，替换的是命令中的文字，而不是替换文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153652.png" alt="image-20210205112459011"></p><p>开服命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx2G -jar fabric-server-launch.jar nogui</span><br></pre></td></tr></table></figure><p>开服成功后的命令行信息与原版服基本一致：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153655.png" alt="image-20210205112937398"></p><h3 id="Fabric-服务端-mod推荐"><a href="#Fabric-服务端-mod推荐" class="headerlink" title="Fabric 服务端 mod推荐"></a>Fabric 服务端 mod推荐</h3><h4 id="Fabric-API-必装"><a href="#Fabric-API-必装" class="headerlink" title="Fabric API - 必装"></a>Fabric API - 必装</h4><p>基本上是一个必装mod，很多fabric的mod都需要他作为前置mod</p><blockquote><p>Curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/fabric-api/files/all">https://www.curseforge.com/minecraft/mc-mods/fabric-api/files/all</a></p></blockquote><h4 id="Carpet-优化-修Bug-假人"><a href="#Carpet-优化-修Bug-假人" class="headerlink" title="Carpet - 优化/修Bug/假人"></a>Carpet - 优化/修Bug/假人</h4><p>carpet模组是一个功能强大的模组，里面有很多的优化内容，可以修复或增加一些游戏特性，可以提供挂机的假人(我用的最多的就是假人)</p><blockquote><p>curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/carpet/files/all">https://www.curseforge.com/minecraft/mc-mods/carpet/files/all</a><br>github：<a href="https://github.com/gnembon/fabric-carpet">https://github.com/gnembon/fabric-carpet</a><br>wiki：<a href="https://github.com/gnembon/fabric-carpet/wiki/Current-Available-Settings">https://github.com/gnembon/fabric-carpet/wiki/Current-Available-Settings</a>  </p></blockquote><p>我的Carpet配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onePlayerSleeping true      # 单人睡觉跳过夜晚 - 我的服务器里只有假人</span><br><span class="line">commandPlayer true          # 生存玩家可以使用 &#x2F;player 指令 - 假人相关</span><br><span class="line">leadFix true                # 修复缰绳bug</span><br><span class="line">antiCheatDisabled true      # 关闭反飞行 - 因为我红石机器排错时会使用 Tweakroo 的 FreeCamera 功能</span><br><span class="line">defaultLoggers mobcaps,tps  # 默认加载 mobcaps 和 tps 信息 - Tab 键显示这些信息</span><br><span class="line">lagFreeSpawning true        # 减少CPU和内存占用</span><br></pre></td></tr></table></figure><h4 id="化学元素三件套-lithium、sodium、phosphor"><a href="#化学元素三件套-lithium、sodium、phosphor" class="headerlink" title="化学元素三件套 - lithium、sodium、phosphor"></a>化学元素三件套 - lithium、sodium、phosphor</h4><p>同一个作者的三个优化mod，装在服务端可以显著减少卡顿，客户端可不装，mod简介可以参考我的世界中文论坛中的帖子：</p><blockquote><p>我的世界中文论坛(MCBBS)：<br>Lithium：<a href="https://www.mcbbs.net/thread-1080959-1-1.html">https://www.mcbbs.net/thread-1080959-1-1.html</a><br>Sodium：<a href="https://www.mcbbs.net/thread-1079347-1-1.html">https://www.mcbbs.net/thread-1079347-1-1.html</a><br>Phosphor：<a href="https://www.mcbbs.net/thread-1081821-1-1.html">https://www.mcbbs.net/thread-1081821-1-1.html</a><br>Curseforge：<br><a href="https://www.curseforge.com/minecraft/mc-mods/lithium/files/all">https://www.curseforge.com/minecraft/mc-mods/lithium/files/all</a><br><a href="https://www.curseforge.com/minecraft/mc-mods/sodium/files/all">https://www.curseforge.com/minecraft/mc-mods/sodium/files/all</a><br><a href="https://www.curseforge.com/minecraft/mc-mods/phosphor/files/all">https://www.curseforge.com/minecraft/mc-mods/phosphor/files/all</a></p></blockquote><h4 id="BBOR-建筑生成查看"><a href="#BBOR-建筑生成查看" class="headerlink" title="BBOR - 建筑生成查看"></a>BBOR - 建筑生成查看</h4><p>可以查看出生点范围，各种建筑的轮廓</p><blockquote><p>Curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/bounding-box-outline-reloaded/files/all">https://www.curseforge.com/minecraft/mc-mods/bounding-box-outline-reloaded/files/all</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Minecraft指北 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox基础使用教程</title>
      <link href="2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>选择VirtualBox而不是VMware Workstation的原因：VirtualBox是开源软件，对于个人的Linux学习来说，既免费又够用，且相较于VMware Workstation来说更为小巧，也没有那么多的自启动服务，不会在你不使用虚拟机的时候也有那么多服务在后台运行。  </p></blockquote><h2 id="下载并安装VirtualBox"><a href="#下载并安装VirtualBox" class="headerlink" title="下载并安装VirtualBox"></a>下载并安装VirtualBox</h2><p>注：<strong>以下说明以Win10系统为例，使用其他系统操作会有一些不同</strong></p><h3 id="下载VirtualBox"><a href="#下载VirtualBox" class="headerlink" title="下载VirtualBox"></a>下载VirtualBox</h3><p>找到VirtualBox官网，在下载界面选择自己想要下载的版本即可，我这里是Win10系统，选择“Windows Hosts”即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152117.png" alt="image-20210128162739725"></p><blockquote><p>VirtualBox官网下载界面：<a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p></blockquote><h3 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h3><p>安装VirtualBox的注意事项并不多，基本上按他默认的内容来即可，其中安装位置按照自己习惯进行选择，我之前也觉着装在C盘会拖慢系统，会单独分区进行安装软件，但是现在固态硬盘读写速度极快，也不像机械硬盘有磁盘碎片，装不装在C盘对系统的影响微乎其微，所以我现在基本上按照软件的默认位置直接安装。(非专业人士，没做过详细比对，软件安装选择默认的C盘路径仅个人想法)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152121.png" alt="image-20210128171122821"></p><h2 id="配置VirtualBox"><a href="#配置VirtualBox" class="headerlink" title="配置VirtualBox"></a>配置VirtualBox</h2><h3 id="修改虚拟机的默认安装位置"><a href="#修改虚拟机的默认安装位置" class="headerlink" title="修改虚拟机的默认安装位置"></a>修改虚拟机的默认安装位置</h3><p>VirtualBox创建的虚拟机的默认位置在用户路径”C:\Users\username&quot;下，安装位置可改可不改，根据个人习惯即可。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152123.png" alt="image-20210128172029879"></p><h3 id="注册系统安装镜像"><a href="#注册系统安装镜像" class="headerlink" title="注册系统安装镜像"></a>注册系统安装镜像</h3><p>VirtualBox并不会对你的计算机进行全盘扫描来寻找镜像文件，所以需要指定这些镜像文件的位置，即便不指定位置，也可以在创建虚拟机的时候再注册镜像文件，但是我习惯于提前注册：</p><p>在VirtualBox的主界面点击左上角的“管理”，然后点击“虚拟介质管理”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152127.png" alt="image-20210128173829678"></p><p>依次选择“虚拟光盘”、“注册”以及要注册的镜像文件</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152129.png" alt="image-20210128174019686"></p><h2 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h2><h3 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h3><p>点击“工具”之后可以看到“新建”选项，点击后开始新建虚拟机的流程。</p><h4 id="名称、位置、类型及版本"><a href="#名称、位置、类型及版本" class="headerlink" title="名称、位置、类型及版本"></a>名称、位置、类型及版本</h4><p>名称：这个虚拟机在你的电脑中的名字，可以理解为文件名<br>文件夹：虚拟机存储位置的父目录，会在这个文件夹里新建一个存储虚拟机的文件夹<br>类型和版本：选择自己想要安装的虚拟机的种类即可，种类不一致会一些问题  </p><blockquote><p>注：对于Linux系统，如果要安装的不是主流发行版的话，版本一栏不会给出具体的发行版名称，这时需要选择“Other Linux”</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152133.png" alt="image-20210129131629346"></p><h4 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h4><p>一般情况下默认分配的内存大小是让这个系统处于“能用”范畴的内存大小，如果要想“流畅地使用”虚拟机，物理机内存较大的情况下建议多分配一些。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152136.png" alt="image-20210129131700510"></p><h4 id="虚拟硬盘"><a href="#虚拟硬盘" class="headerlink" title="虚拟硬盘"></a>虚拟硬盘</h4><p>虚拟硬盘选项如图所示，不做赘述，一般按照默认的“现在创建虚拟硬盘”即可。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152139.png" alt="image-20210129131716155"></p><p>可以选择的虚拟硬盘种类：</p><ul><li>VDI：VirtualBox的专用的磁盘映像种类，仅可供VirtualBox自己使用  </li><li>VHD：Microsoft Virtual PC的原生格式(本人了解也不多)  </li><li>VMDK：VMware的虚拟机磁盘种类，除了可供VMware使用以外，可供市面上大部分常用的虚拟机软件使用</li></ul><p>如果没有将此虚拟机转移到别的虚拟机软件中使用的需求的话，使用默认的VDI类型即可。即便是此时选择了VDI类型，之后也可以使用VirtualBox自带的VBoxManager更改磁盘类型以适配别的虚拟机软件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152142.png" alt="image-20210129131728694"></p><p>动态分配和固定分配的优缺点如图所示，需要注意的是“固定大小”不仅直接将创建好的空间完全分配给虚拟硬盘，后续也无法改变这块硬盘的大小，我一般选择动态分配</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152145.png" alt="image-20210129131737708"></p><p>磁盘大小依照自己要装的系统而定，不要盲目信任软件给出的推荐大小，比如CentOS的推荐大小是8GB，如果是安装Server版那么算是绰绰有余，但若是安装带GUI的完全版，则会因为空间太小而无法安装，所以明确自己要装的系统需要多大的空间也是一件非常重要的事。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152147.png" alt="image-20210129131746654"></p><h3 id="设置虚拟机"><a href="#设置虚拟机" class="headerlink" title="设置虚拟机"></a>设置虚拟机</h3><p>进入对虚拟机的设置项，对虚拟机做一些较为详细的设置。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152150.png" alt="image-20210129131858099"></p><h4 id="常规设置"><a href="#常规设置" class="headerlink" title="常规设置"></a>常规设置</h4><p>对于有图形界面的虚拟机一般可以开启“共享粘贴板”和“拖放”这两项设置，便于物理机和虚拟机之间的交互(需要安装增强工具)，比如我这里的“Win10”虚拟机，当我开启这两个选项并安装“增强工具”之后，就可以实现物理机与虚拟机之间这种较为便捷的交互。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152153.png" alt="image-20210129132025514"></p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><p>内存：如果不满意之前的内存分配，可以在这里重新分配内存大小<br>EFI：对于有EFI需求的系统可以开启，对于部分系统开启此处后可以提升一些使用体验，比如openEuler在不开启EFI的情况下，安装时会有部分内容显示不完全，开启之后显示的分辨率更好且显示内容完全</p><p>处理器数量：与内存的分配原则类似，适当增加这里的处理器数量可以提升虚拟机的流畅性，但是这里分配太多的话会引起物理机的卡顿从而虚拟机也卡</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152156.png" alt="image-20210129132341342"></p><h4 id="显示设置"><a href="#显示设置" class="headerlink" title="显示设置"></a>显示设置</h4><p>显存大小：与内存的分配原则类似<br>硬件3D加速：如果物理机配置好的话可以开启，能使虚拟机的画面更为流畅甚至绚丽(若要安装的是只是用CUI的Linux系统，则没必要开启)，但物理机配置不够好的情况下会导致双方都卡顿</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152159.png" alt="image-20210129132430852"></p><h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><ol><li><p>网络地址转换(NAT)：可以将物理机理解为一个路由器，虚拟机的网络都经过物理机转发之后与外界网络进行链接</p><ul><li>优点：无需进行复杂设置，就可以使虚拟机联网</li><li>缺点：使用SSH链接虚拟机或需要访问虚拟机的某个端口时，需要先将虚拟机端口映射到物理机的端口，当需要使用的端口数较多时，设置起来有些烦人</li></ul></li><li><p>桥接网卡：将物理机的网卡虚拟化，虚拟机也可经过此网卡联网，与物理机在同一个网段下(在同一个局域网下)</p><ul><li>优点：虚拟机有自己的IPv4地址，与物理机在一个网段下，可以互相ping通</li><li>缺点：一般仅适用于有自己的路由器的情况，尤其是校园网用户一般情况下无法使用(校园网转路由器则可使用)</li></ul></li><li><p>仅主机(Host-Only)网络：虚拟机没有访问外网的能力，仅可以与物理机交互</p></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152203.png" alt="image-20210129132816115"></p><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><p>点击启动，VirtualBox虚拟机在第一次启动时会要求你选择系统镜像，选择好要使用的镜像后，执行对应系统的安装过程即可。</p><p>如果安装系统时要断网安装(如Win10系统，我安装的时候习惯在断网情况下安装，以免在安装过程给我弄一大堆没用的东西)，需要在“网络设置”中不启用网络连接。</p><h2 id="实例-安装openEuler虚拟机"><a href="#实例-安装openEuler虚拟机" class="headerlink" title="实例 - 安装openEuler虚拟机"></a>实例 - 安装openEuler虚拟机</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="下载openEuler系统镜像"><a href="#下载openEuler系统镜像" class="headerlink" title="下载openEuler系统镜像"></a>下载openEuler系统镜像</h4><p>首先进入openEuler的官网，并点击“下载”按钮</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151741.png" alt="image-20210203214744209"></p><blockquote><p>openEuler官网：<a href="https://openeuler.org/zh/">https://openeuler.org/zh/</a></p></blockquote><p>选中“LTS”即 Long Term Support(长期支持) 版本，在筛选出来的版本中找一个合适的版本，合适与否因人而异，一般带有最新的补丁的LTS版即可，此处我选择的是“openEuler 20.03 LTS SP1”，然后点击其对应的“下载”按钮</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151745.png" alt="image-20210203215435882"></p><p>依次选择“ISO”、“x86_64”，可以到达镜像及SHA256类型的HASH校验和文件列表，此处我选择的分别是“openEuler-20.03-LTS-SP1-x86_64-dvd.iso”以及“openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151748.png" alt="image-20210203220443535"></p><blockquote><p>openEuler-20.03-LTS-SP1-x86_64-dvd.iso：<a href="https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso">https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso</a><br>openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum：<a href="https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum">https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum</a></p></blockquote><h4 id="校验openEuler系统镜像"><a href="#校验openEuler系统镜像" class="headerlink" title="校验openEuler系统镜像"></a>校验openEuler系统镜像</h4><p>为了验证文件的完整性，需要对系统镜像进行HASH校验，若计算得出的校验和与官方提供的不一致，则说明完整性被破坏，需要重新下载</p><p>这里由于校验和文件的后缀名是“sha256sum”，可以得出校验类型是“SHA256”，在Windows系统下可以在终端输入指令来计算校验和，比如我的校验命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Get-FileHash D:\Linux_ISO\openEuler-<span class="number">20</span>.<span class="number">03</span>-LTS-SP1-x86_64-dvd.iso -Algorithm SHA256| <span class="built_in">Format</span>-List</span><br></pre></td></tr></table></figure><p>其中“D:\Linux_ISO\openEuler-20.03-LTS-SP1-x86_64-dvd.iso”是我电脑中的镜像文件存储路径，请替换路径后使用校验命令进行校验</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151752.png" alt="image-20210203221742431"></p><p>然后与“openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum”中的校验和进行比较，“sha256sum”文件可以使用Windows自带的“记事本”打开，在打开方式中选择对应应用即可</p><h3 id="在Virtual中安装openEuler"><a href="#在Virtual中安装openEuler" class="headerlink" title="在Virtual中安装openEuler"></a>在Virtual中安装openEuler</h3><blockquote><p>“新建”及“设置”属于VirtualBox的操作，其具体细节可以参考文章首部提供的博文链接： <a href="https://leok77.github.io/2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">VirtualBox的简单使用教程</a> ，这里仅给出一些需要注意的点</p></blockquote><h4 id="新建openEuler虚拟机"><a href="#新建openEuler虚拟机" class="headerlink" title="新建openEuler虚拟机"></a>新建openEuler虚拟机</h4><h5 id="系统类型"><a href="#系统类型" class="headerlink" title="系统类型"></a>系统类型</h5><p>openEuler是一款社区支持的开源的Linux系统，基于CentOS定制而成，但是不隶属于CentOS的母公司Rad Hat，所以这里应该选择的版本是Other Linux(64-bit)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151755.png" alt="image-20210204093206163"></p><h5 id="最小虚拟化空间要求"><a href="#最小虚拟化空间要求" class="headerlink" title="最小虚拟化空间要求"></a>最小虚拟化空间要求</h5><p>openEuler官方文档中给出的最小虚拟化空间要求如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151758.png" alt="image-20210204093727166"></p><p>实测在使用Server版的情况下，并不需要严格按照这里的要求，参照CentOS Server虚拟机的配置即可，内存2GB，硬盘8GB(我习惯性凑整改成了10GB)。</p><h4 id="设置openEuler虚拟机"><a href="#设置openEuler虚拟机" class="headerlink" title="设置openEuler虚拟机"></a>设置openEuler虚拟机</h4><ol><li><p>在“系统设置”启用EFI，这样可以让安装系统的界面更为友好，主要体现为不会有内容显示在显示器外部(即显示器可以完全显示图形界面)</p></li><li><p>如果要安装带GUI的虚拟机，为了GUI的流畅性，还可以在“显示设置”中启用3D加速，并增大显存大小</p></li><li><p>如果对于之前分配的硬盘存储空间不满意，可以在“管理”-“虚拟介质管理”找到对应的“虚拟硬盘”，并增加其大小，VirtualBox暂不支持缩小虚拟硬盘</p></li></ol><h4 id="安装openEuler虚拟机"><a href="#安装openEuler虚拟机" class="headerlink" title="安装openEuler虚拟机"></a>安装openEuler虚拟机</h4><h5 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h5><p>设置好后，点击“启动”虚拟机，VirtualBox虚拟机第一次启动时会要求选择安装镜像，选择好镜像后进入系统安装页面。</p><p>在安装页面选择默认的“Test this media &amp; install openEuler”即可，即先验证镜像再安装，可以检测出一些镜像可能存在的奇奇怪怪的问题(实际上经过校验之后的镜像一般是不会存在问题的)。</p><p>验证完之后会开始安装过程，因为我仅使用CLI(命令行终端)，不使用GUI，所以我选择的语言是美式英语</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151801.png" alt="image-20210204125331352"></p><h5 id="Software-Selection"><a href="#Software-Selection" class="headerlink" title="Software Selection"></a>Software Selection</h5><p>软件选择可以理解为版本安装，因为这个镜像中包含了很多的软件，而需要安装的并不是全部，给出的有“Minimal Install”、“Server”、“Virtualization Host”三个基础内容，安装时选择基础版本，再选择右侧的额外软件包即可。</p><p>我选择安装的是“Server”版，未安装右侧提供的额外软件。</p><h5 id="Installation-Destination"><a href="#Installation-Destination" class="headerlink" title="Installation Destination"></a>Installation Destination</h5><p>安装位置选择，一般情况下默认的自动分配即可，但是需要先把它点开一下，否则默认的自动分配是不生效的，且无法进入下面的安装阶段。</p><h5 id="Network-amp-Host-Name"><a href="#Network-amp-Host-Name" class="headerlink" title="Network &amp; Host Name"></a>Network &amp; Host Name</h5><p>Host Name即主机名，在局域网中若开启让其他网络设备发现的功能，那么其他设备看到的此主机名字就是此处设置的名字，修改后别忘了点击“Apply”，不然不生效</p><h5 id="Root-Password"><a href="#Root-Password" class="headerlink" title="Root Password"></a>Root Password</h5><p>设置超级管理员账户的密码，密码要求如下：</p><ul><li>口令长度至少8个字符。</li><li>口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。</li><li>口令不能和账号一样。</li><li>口令不能使用字典词汇。</li></ul><h5 id="User-Creation-可选项"><a href="#User-Creation-可选项" class="headerlink" title="User Creation(可选项)"></a>User Creation(可选项)</h5><p>添加一个普通用户/管理员，管理员需要选择“Make this user administrator”，这样这个用户就可以“sudo”了，密码要求与Root Password的要求一致。</p><p>建议在这里添加一个管理员用户，一般情况下没必要以root用户运行。</p><h5 id="Begin-Installation"><a href="#Begin-Installation" class="headerlink" title="Begin Installation"></a>Begin Installation</h5><p>以上信息都设置好之后就可以点击“Begin Installation”开始安装了。</p><p>安装结束之后，点击“Reboot System”，就可以重启进入系统了。</p><h3 id="SSH连接openEuler"><a href="#SSH连接openEuler" class="headerlink" title="SSH连接openEuler"></a>SSH连接openEuler</h3><p>连接openEuler的IP地址以及端口号需要根据网络模式来决定</p><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换(NAT)"></a>网络地址转换(NAT)</h4><p>使用“ip addr”获取虚拟机的IP地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151806.png" alt="image-20210206143759055"></p><p>打开虚拟机的网络设置：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151808.png" alt="image-20210206143915209"></p><p>设置端口转发规则：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151811.png" alt="image-20210206144146988"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主机IP：    127.0.0.1   ## localhost</span><br><span class="line">主机端口：  10122       ## 自己设置，避开特定的那些端口</span><br><span class="line">子系统IP：  10.0.2.15   ## 通过“ip addr”获取的IP地址</span><br><span class="line">子系统端口：22          ## SSH服务的默认端口</span><br></pre></td></tr></table></figure><p>那么通过SSH连接openEuler时的IP地址就是127.0.0.1，端口号是10122：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151814.png" alt="image-20210206144534640"></p><h4 id="桥接网卡"><a href="#桥接网卡" class="headerlink" title="桥接网卡"></a>桥接网卡</h4><h5 id="DHCP自动获取IP"><a href="#DHCP自动获取IP" class="headerlink" title="DHCP自动获取IP"></a>DHCP自动获取IP</h5><p>通过“ip addr”获取openEuler的IP地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151818.png" alt="image-20210206144751919"></p><p>那么通过SSH连接openEuler时的IP地址就是192.168.0.103，端口号是默认的22：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151820.png" alt="image-20210206144946060"></p><h5 id="设置静态IP-可选项"><a href="#设置静态IP-可选项" class="headerlink" title="设置静态IP(可选项)"></a>设置静态IP(可选项)</h5><blockquote><p>适用场景：非校园网用户，虚拟机的网络链接方式是桥接模式</p></blockquote><h6 id="获取物理机的IP信息"><a href="#获取物理机的IP信息" class="headerlink" title="获取物理机的IP信息"></a>获取物理机的IP信息</h6><p>以Win10系统为例，打开cmd，执行“ipconfig”：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br></pre></td></tr></table></figure><p>找到如图所示的信息，需要有方框中框出的这三项信息。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151824.png" alt="image-20210204130106958"></p><p>由此得出了物理机的IP信息为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Address:    IPv4地址:   192.168.0.111</span><br><span class="line">Netmask:    子网掩码:   255.255.255.0</span><br><span class="line">Gateway:    默认网关:   192.168.0.1</span><br></pre></td></tr></table></figure><p>在cmd执行“arp -a”</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure><p>找到接口为物理机IPv4地址的信息，列出的这些Internet地址是已经被分配了的，openEuler设置静态IP时要避开，192.168.0.116是当前分配给openEuler的IP地址，可以通过“ip addr”查看</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151826.png" alt="image-20210204130413555"></p><h6 id="设置openEuler的静态IP"><a href="#设置openEuler的静态IP" class="headerlink" title="设置openEuler的静态IP"></a>设置openEuler的静态IP</h6><p>输入命令“ip addr”查看网卡名字(一般是enp0s3)</p><p>编辑“/etc/sysconfig/network-scripts/ifcfg-enp0s3”文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure><p>找到“BOOTPROTO=dhcp”，将其注释掉并添加“BOOTPROTO=static”</p><p>在文末添加如下信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.0.121    ## 不能是前面已分配的地址</span><br><span class="line">NETMASK&#x3D;255.255.255.0   ## 与物理机一致</span><br><span class="line">GATEWAY&#x3D;192.168.0.1     ## 与物理机一致</span><br><span class="line">DNS1&#x3D;223.5.5.5          ## 阿里云公共DNS</span><br><span class="line">DNS2&#x3D;180.76.76.76       ## 百度公共DNS</span><br></pre></td></tr></table></figure><p>修改完后文件如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151830.png" alt="image-20210204151402588"></p><p>在终端执行“sudo nmcli c reload”刷新网络信息，并执行“sudo nmcli c up enp0s3”使变更立即生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli c reload</span><br><span class="line">sudo nmcli c up enp0s3</span><br></pre></td></tr></table></figure><p>那么通过SSH连接openEuler时的IP地址就是192.168.0.121，端口号是默认的22：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151832.png" alt="image-20210206145541614"></p>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VirtualBox </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10软件推荐</title>
      <link href="2021/01/27/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>2021/01/27/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>这篇博文是为了分享和记录一下我正在用的win10平台的一些软件，软件这种东西仁者见仁智者见智，仅供参考。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>安装并首次完全更新完win10系统之后我做的第一件事：安装浏览器</p><p>这里推荐两款浏览器，分别是微软的新版Edge浏览器，和火狐浏览器。首先阐述一下我不使用旧版Edge的原因：我使用旧版Edge的时候，时常会出现用浏览器下载东西卡住的现象，虽然浏览器的本职工作不包括下载，但是一个系统刚安装好的时候，下载别的软件都是要通过浏览器的，而我多次重装系统的经验告诉我，旧版Edge的下载功能极其羸弱，这一点使得我对这款浏览器并不感冒。</p><h3 id="新版Edge浏览器"><a href="#新版Edge浏览器" class="headerlink" title="新版Edge浏览器"></a>新版Edge浏览器</h3><p>新版Edge浏览器基于谷歌的开源Chromium内核(其实市面上很多浏览器都是采用的这个内核)，且支持Windows/Mac/Android/IOS平台的同步功能(截至2021年1月27日，Linux平台的Microsoft Edge浏览器尚未提供账号登陆功能)，对于喜欢多个平台共用同一款浏览器，且使用同步的收藏夹、密码等内容的用户来说是一款很棒的浏览器，且使用的账号是微软账号，不需要像Chrome浏览器那样科学上网才可以同步。但是需要注意新版Edge和旧版Edge不可以并存，若要使用旧版Edge的话，请不要升级到新版的Edge浏览器。</p><blockquote><p>Edge官网地址：<a href="https://www.microsoft.com/zh-cn/edge">https://www.microsoft.com/zh-cn/edge</a></p></blockquote><h3 id="FireFox火狐浏览器"><a href="#FireFox火狐浏览器" class="headerlink" title="FireFox火狐浏览器"></a>FireFox火狐浏览器</h3><p>火狐浏览器支持全平台(包括Linux平台，广为流传的Ubuntu的默认浏览器就是火狐浏览器)，且提供同步服务(由于中国国情，提供的同步服务分为全球服务和国内服务，且两个同步服务不互通)，在新版Edge面世之前我一直使用的是火狐浏览器，且当我使用带图形界面的Linux系统时，火狐浏览器是我的首选。乍一看火狐浏览器几乎没有缺点，应该是我没有设置好的原因，当我使用火狐浏览器的时候，偶尔会出现页面加载很慢的现象(网络正常且要访问的页面不是需要科学上网的页面)，所以新版Edge出现之后我选择了新版Edge。</p><blockquote><p>Firefox官网地址：<a href="https://www.firefox.com.cn/">https://www.firefox.com.cn/</a><br>注：在Linux平台使用发行版自带的软件库时，安装的火狐浏览器可能不提供国内同步服务，请使用来自火狐中文社区的拓展：<a href="http://mozilla.com.cn/thread-343905-1-1.html">http://mozilla.com.cn/thread-343905-1-1.html</a> (参考自ArchWiki)。</p></blockquote><p>PS:搜索引擎建议使用微软的必应，因为百度的搜索结果往往不是那么靠谱，毕竟跟钱沾边；谷歌搜索需要科学上网，挺麻烦的。</p><blockquote><p>必应国内版：<a href="https://cn.bing.com/">https://cn.bing.com/</a></p></blockquote><h2 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h2><h3 id="Internet-Download-Manager下载器"><a href="#Internet-Download-Manager下载器" class="headerlink" title="Internet Download Manager下载器"></a>Internet Download Manager下载器</h3><p>IDM下载器(注意这是一个付费软件)，Windows平台的一个多线程下载利器，支持浏览器资源嗅探，在下载的时候基本可以跑满带宽且不会像迅雷一样占用极大资源，直观表现就是风扇不会起飞。但是不支持BT和ed2k下载。</p><blockquote><p>IDM官网：<a href="https://www.internetdownloadmanager.com/">https://www.internetdownloadmanager.com/</a></p></blockquote><h3 id="qBittorrent-Enhanced-Edition-BT下载利器"><a href="#qBittorrent-Enhanced-Edition-BT下载利器" class="headerlink" title="qBittorrent-Enhanced-Edition - BT下载利器"></a>qBittorrent-Enhanced-Edition - BT下载利器</h3><p>顾名思义，qBittorrent-Enhanced-Edition是qBittorrent的增强版，我认为相比于qBittorrent来说最值得提一嘴的是增加了自动更新Tracker的功能，按照我的理解，Tracker就是记录这个资源在哪儿有，也把你的信息分享到Tracker服务器供别人下载。</p><p>BT社区需要大家一起维护，不要觉着迅雷好用就只用迅雷，现在国内BT社区环境不好很大一部分原因就是迅雷的问题，也许会有人觉着普通用户用啥软件都一样，请参考百度网盘，迅雷比百度网盘还算良心，但是恶心就是恶心，没得洗。</p><blockquote><p>qBittorrent-Enhanced-Edition：<a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a><br>Tracker(自带默认)：<a href="https://cdn.jsdelivr.net/gh/ngosang/trackerslist/trackers_best.txt">https://cdn.jsdelivr.net/gh/ngosang/trackerslist/trackers_best.txt</a><br>Tracker：<a href="https://trackerslist.com/#/zh">https://trackerslist.com/#/zh</a></p></blockquote><h3 id="迅雷-推荐仅限于Ed2K连接使用"><a href="#迅雷-推荐仅限于Ed2K连接使用" class="headerlink" title="迅雷 - 推荐仅限于Ed2K连接使用"></a>迅雷 - 推荐仅限于Ed2K连接使用</h3><p>迅雷，让人又爱又恨，但国内的ed2k工具我没有找到比他更棒的替代品，所以他也是我电脑里的下载器之一，当然仅限于下载ed2k链接的时候我才会把它打开，平时他必然是被我关掉的，弹窗和时不时占资源着实让人恶心。嫌弃归嫌弃，但是用起来也确实简单易懂。</p><blockquote><p>迅雷官网：<a href="https://www.xunlei.com/">https://www.xunlei.com/</a></p></blockquote><h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><h3 id="Visual-Studio-Code：一款近乎全能的文本编辑器"><a href="#Visual-Studio-Code：一款近乎全能的文本编辑器" class="headerlink" title="Visual Studio Code：一款近乎全能的文本编辑器"></a>Visual Studio Code：一款近乎全能的文本编辑器</h3><p>VScode，微软家的一大力作，装上插件之后可以被称为神器，但是我并没有装多少插件，仅仅是把他当作文本编辑器来用(像我这样的菜鸡写代码的时候当然是选择用IDE了，JetBrains永远的神)，主要是因为使用起来不占多少资源，且可以将文件保存为几乎任意类型(默认自带的记事本就不行，我想要将一个文件保存为没有后缀名的文件的时候，记事本都会把它保存为文本文件即TXT)，编辑文本的时候十分好用。</p><blockquote><p>VScode官网：<a href="https://code.visualstudio.com/#alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p></blockquote><p>我选择的是System Installer，即将VScode安装为此计算机的所有用户都可以使用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153835.png" alt="image-20210127114145372"></p><p>安装时建议勾选“其他”这一栏的这几项，这样在想编辑一些文件时就可以方便地直接打开VScode对其进行编辑，而不需要改变这些文件的默认应用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153837.png" alt="image-20210127114724973"></p><h3 id="Typora：Markdown编辑器"><a href="#Typora：Markdown编辑器" class="headerlink" title="Typora：Markdown编辑器"></a>Typora：Markdown编辑器</h3><p>Typora，markdown神器，编辑markdown文件时的首选软件，支持“所见即所得”，也就是输入之后直接转换为对应markdown格式，而不是左右分屏一边是源代码一边是markdown转义之后的文章。</p><p>但也并不是完美无缺，有时会出现渲染错误(可能是我的个例，说白了就是自己的Markdown语法掌握的不好，写出有歧义的格式)，所以我现在主要使用markdown来读文章或者插入图片，写文章的时候其实是使用Typora搭配VScode(搭配Markdown All in One以及markdownlint这两个插件)一起用的。</p><blockquote><p>Typora官网：<a href="https://typora.io/">https://typora.io/</a></p></blockquote><h2 id="工具：适合开机自启"><a href="#工具：适合开机自启" class="headerlink" title="工具：适合开机自启"></a>工具：适合开机自启</h2><blockquote><p>以下的工具都是我选择开机自启的工具，当然个别可能还是用的时候再开比较好，但我的使用习惯是这些开机自启，而且这些工具占用资源也不多，我内存还蛮大的(16G)，不会因为这些小工具爆内存，顶多偶尔CPU飚上去(点名火绒)。</p></blockquote><h3 id="火绒安全软件：杀毒-弹窗拦截"><a href="#火绒安全软件：杀毒-弹窗拦截" class="headerlink" title="火绒安全软件：杀毒+弹窗拦截"></a>火绒安全软件：杀毒+弹窗拦截</h3><p>火绒安全软件，很多人说win10自带的Windows Defender就很棒，不需要其他的杀毒软件，但是多一重保护比没有好，而且不怎么占用资源。</p><p>其实我使用火绒的主要目的是使用他的弹窗拦截功能，所以如果自己电脑没有带弹窗的软件的话可以跳过这儿了，可以自己比对火绒的弹窗库来找出电脑中有哪些软件带弹窗，也可以自己选择想阻拦哪些窗口，十分的轻量又好用。(如我电脑里用的时候才开的迅雷，就被他无情的进行了拦截)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153840.png" alt="火绒弹窗拦截截屏"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153843.png" alt="image-20210127155501216"></p><p>美中不足的就是有时候开机会占用一大片资源以及自动查杀时CPU占用很高导致风扇狂转，但是大多数情况下我都感受不到这个软件的存在。</p><blockquote><p>火绒安全官网：<a href="https://huorong.cn/">https://huorong.cn/</a></p></blockquote><h3 id="网易邮箱大师：多平台邮箱一同管理"><a href="#网易邮箱大师：多平台邮箱一同管理" class="headerlink" title="网易邮箱大师：多平台邮箱一同管理"></a>网易邮箱大师：多平台邮箱一同管理</h3><p>网易邮箱大师，支持Windows/MacOS/Android/IOS平台且提供同步服务，相比于Win10自带的Mail来说更为人性化(个人观点)，且在新平台登录网易邮箱大师的时候，你所添加过的邮箱是要求你重新验证一遍密码的，基本上不用担心网易账号泄露之后所有的邮箱都被泄露。</p><blockquote><p>网易邮箱大师官网：<a href="http://mail.163.com/dashi/">http://mail.163.com/dashi/</a></p></blockquote><h3 id="Snipaste：截屏神器"><a href="#Snipaste：截屏神器" class="headerlink" title="Snipaste：截屏神器"></a>Snipaste：截屏神器</h3><p>Snipaste，功能强大的截屏软件，绑定快捷键之后可以快捷键截屏，且截屏具有窗口捕获功能，即他会判定一下鼠标所在的窗口，然后优先截屏范围是这个窗口的范围，也支持鼠标指针按住之后选择范围，且可以增加矩形框、马赛克、箭头、文字等内容，截屏之后也可以选择保存到剪切板或直接保存为图片，十分的人性化。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153851.png" alt="image-20210127143720953"></p><p>如图所示，截屏的瞬间CPU占用为0.5%，内存占用为12.5M，磁盘占用0.1M/s；而日常待机时仅占用12.3M的内存，不会给电脑带来很大的负担。</p><blockquote><p>Snipaste官网：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></p></blockquote><h3 id="腾讯桌面整理"><a href="#腾讯桌面整理" class="headerlink" title="腾讯桌面整理"></a>腾讯桌面整理</h3><p>腾讯桌面整理，这款软件放在“工具”而不是“腾讯系软件”的原因是这真的是一款好软件，不要因为患有“腾讯PTSD”就抗拒他，在竞品中免费且不抢占大量资源。</p><p>可以下载的独立于腾讯电脑管家之外的小软件，可以双击隐藏/显示桌面图标，在桌面上以网格的形式存放一些软件，提供的文件搜索工具响应速度和搜索结果整理强于Windows的文件管理器。其提供的壁纸功能请自己选择是否使用，本人是不使用的。</p><p>主要功能的效果图：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153854.png" alt="image-20210127150643067"></p><p>下载时请注意下载“桌面整理独立版”，如果点的是立即下载的话，那么安装的是腾讯电脑管家。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153857.png" alt="image-20210127163152412"></p><blockquote><p>腾讯桌面整理官网：<a href="https://guanjia.qq.com/product/zmzl/">https://guanjia.qq.com/product/zmzl/</a></p></blockquote><h3 id="Everything-搜索神器"><a href="#Everything-搜索神器" class="headerlink" title="Everything - 搜索神器"></a>Everything - 搜索神器</h3><p>一开始我是抗拒Everything的，因为在知乎看到了太多吹他的软文，以为有什么猫腻，后来厌倦了腾讯桌面整理的搜索引擎之后(因为个人权限配置问题，激活的时候需要管理员)，决定试一试Everything，然后爱上了这个软件，占资源小，反应快，搜索功能真的强大，且是免费软件，点一个大大的赞。</p><p>我绑定的快捷键是”Ctrl+Alt+Space”，注意绑定快捷键时是选择”显示窗口快捷键”而不是新建窗口，保持开机自启后台常驻即可，占用不了多少资源。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316203323.png" alt="image-20210316203323695"></p><p>而且搜索的时候支持正则表达式，比如下面就是在”C:\Users\LeoK77\Documents\WorkSpace&quot;路径下搜索所有*.cpp(即CPP类型的文件)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316203113.png" alt="image-20210316203113620"></p><blockquote><p>Everything官网：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p></blockquote><h3 id="PowerToys：微软小型工具包"><a href="#PowerToys：微软小型工具包" class="headerlink" title="PowerToys：微软小型工具包"></a>PowerToys：微软小型工具包</h3><p>微软官方的一些小工具的集合，我开启的是如图所示的这几个工具。(众所周知微软就喜欢自己背地里搞些好用的小软件，而不是直接登录Win10应用商店)</p><p>虽然名字是”Toys”可能会对一些人劝退，但我综合使用下来还是蛮不错的；缺点的话就是PowerToys Run功能后台占用内存有一百多M，不是太需要这个功能或者电脑内存不是那么大的话还是不要开启了(我电脑内存16G)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316194201.png" alt="image-20210316194201867"></p><blockquote><p>PowerToys GitHub：<a href="https://github.com/microsoft/PowerToys">https://github.com/microsoft/PowerToys</a></p></blockquote><h3 id="Windows-TopMost-Control：窗口置顶工具"><a href="#Windows-TopMost-Control：窗口置顶工具" class="headerlink" title="Windows TopMost Control：窗口置顶工具"></a>Windows TopMost Control：窗口置顶工具</h3><p>在任务栏常驻，设置快捷键后，现在处于活跃状态的窗口(不妨起名”窗口一”)会被置顶，其他的窗口(不妨起名”窗口二”)处于活跃状态后，”窗口一”还在最前面。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316195900.png" alt="image-20210316195859877"></p><p>如图所示当我把Typora置顶后，我在VSCode中编辑的时候，Typora并不会因为失去焦点而被VSCode遮住(仅做一个示例，并不是最常用的使用情况)。</p><blockquote><p>Windows TopMost Control：<a href="https://www.sordum.org/9182/window-topmost-control-v1-2/">https://www.sordum.org/9182/window-topmost-control-v1-2/</a></p></blockquote><h3 id="TrafficMonitor：系统资源占用显示"><a href="#TrafficMonitor：系统资源占用显示" class="headerlink" title="TrafficMonitor：系统资源占用显示"></a>TrafficMonitor：系统资源占用显示</h3><p>实时显示系统资源的占用情况，包括CPU、内存占用率以及当前的网络，对于部分人来说可能比较鸡肋，但是对于我来说很好用，因为通过让他常驻状态栏，我可以了解我的电脑处于一种什么样的资源占用状态，来判断我正在进行的工作有没有出现问题。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316202624.png" alt="image-20210316202617174"></p><blockquote><p>Traffic Monitor GitHub：<a href="https://github.com/zhongyang219/TrafficMonitor">https://github.com/zhongyang219/TrafficMonitor</a></p></blockquote><h2 id="工具：适合使用时启用"><a href="#工具：适合使用时启用" class="headerlink" title="工具：适合使用时启用"></a>工具：适合使用时启用</h2><h3 id="PotPlayer：视频播放器"><a href="#PotPlayer：视频播放器" class="headerlink" title="PotPlayer：视频播放器"></a>PotPlayer：视频播放器</h3><p>Potplayer，这应该是很多win10用户的选择，轻量级但是支持多种格式，且使用起来极其方便，对于本地视频的播放极其友好。</p><p>喜欢折腾的话甚至可以用PotPlayer看直播(但是我之前没找到好的直播源，电视直播源基本都是转播的网络源，有些卡)</p><blockquote><p>Potplayer官网：<a href="https://potplayer.daum.net/">https://potplayer.daum.net/</a></p></blockquote><h3 id="BandiZip：解压缩软件"><a href="#BandiZip：解压缩软件" class="headerlink" title="BandiZip：解压缩软件"></a>BandiZip：解压缩软件</h3><p>Bandizip，免费但是强大的压缩软件，且没有烦人的广告(指弹窗广告，打开本体的时候还是有广告的，但是使用右键集成功能时无广告)骚扰你，并支持在系统右键菜单栏中添加常用功能选项，如“添加到XXX.zip等格式”、“解压到…”，简单易用，不流氓。</p><p>压缩包的右键菜单如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153846.png" alt="image-20210127144129861"></p><p>普通文件的右键菜单如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153848.png" alt="image-20210127144224036"></p><blockquote><p>Bandizip官网：<a href="https://www.bandisoft.com/">https://www.bandisoft.com/</a></p></blockquote><h3 id="Tablacus-Explorer-多标签文件资源管理器"><a href="#Tablacus-Explorer-多标签文件资源管理器" class="headerlink" title="Tablacus Explorer - 多标签文件资源管理器"></a>Tablacus Explorer - 多标签文件资源管理器</h3><p>每当我需要在不同的文件夹下复制文件或者文件夹时，通常需要打开两个文件资源管理器，然后中途如果需要临时弄别的东西，切回来时要把两个文件资源管理器调用一遍才能到主桌面最前，但是Tablacus Explorer解决了这个问题，支持多标签多窗口，可以在一个窗口内展示两个文件资源管理器。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301085547.png" alt="image-20210301085547720"></p><blockquote><p>Tablacus Explorer：<a href="https://github.com/tablacus/TablacusExplorer">https://github.com/tablacus/TablacusExplorer</a></p></blockquote><h3 id="Microsoft便笺-jian"><a href="#Microsoft便笺-jian" class="headerlink" title="Microsoft便笺(jian)"></a>Microsoft便笺(jian)</h3><p>轻量级产品，以窗口的形式作为一个备忘录存在，固定在任务栏随时唤醒，提醒自己计划要做的任务有哪些。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301092646.png" alt="image-20210301092646614"></p><p>下载安装在Win10应用商店即可，搜索“便笺”，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301092944.png" alt="image-20210301092943900"></p><h3 id="Windows-Terminal：Win10终端"><a href="#Windows-Terminal：Win10终端" class="headerlink" title="Windows Terminal：Win10终端"></a>Windows Terminal：Win10终端</h3><p>是否觉着cmd不好用，powershell有些丑？试一试Windows Terminal吧，颜值高，兼容一些Linux下shell的用法，感觉不要太爽。</p><p>要在Windows Terminal下执行脚本，需要依次进行如下操作：设置-&gt;更新和安全-&gt;开发者选项(拉到最下方)-&gt;应用以下设置以执行脚本。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301093447.png" alt="image-20210301093446877"></p><p>下载安装在Win10应用商店即可，搜索“Windows Terminal”，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301093601.png" alt="image-20210301093601384"></p><h3 id="DiskGenius：强大的磁盘管理工具"><a href="#DiskGenius：强大的磁盘管理工具" class="headerlink" title="DiskGenius：强大的磁盘管理工具"></a>DiskGenius：强大的磁盘管理工具</h3><p>对于我来说，DiskGenius几乎是我离不开的工具之一，我会用它做磁盘分区种类转换(MBR-&gt;GPT)、用它清空/格式化磁盘、用它检测磁盘坏道、用它进行磁盘分区……因为我之前总是装系统装着玩儿，所以磁盘管理这块用DiskGenius比较多(作为一个弟弟实在是不太会用Linux终端分盘，仅有的一次还是使用arch的时候，但我现在是Windows的忠实用户了，Linux还是在虚拟机里比较好)</p><p>中文软件使用方式就不多说了，但凡认字应该就能看懂怎么用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316201037.png" alt="image-20210316201037103"></p><blockquote><p>DiskGenius：<a href="https://www.diskgenius.cn/">https://www.diskgenius.cn/</a></p></blockquote><h2 id="腾讯系软件"><a href="#腾讯系软件" class="headerlink" title="腾讯系软件"></a>腾讯系软件</h2><h3 id="TIM：比PC版QQ简洁"><a href="#TIM：比PC版QQ简洁" class="headerlink" title="TIM：比PC版QQ简洁"></a>TIM：比PC版QQ简洁</h3><p>TIM，之所以选择TIM而不选择QQ是因为TIM在电脑上的操作逻辑要比QQ好一些，且花里胡哨的东西也少一些，日常聊天一个窗口即可，不需要像QQ挂着一个主标签，聊天框分离开。(TIM也可以把某一个聊天框从主界面分离出来，凭自己喜好而定)</p><p>(弱弱的说一句，有时候觉着TIM就像是在Win10平台的MacOS的QQ)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153912.png" alt="image-20210127145139111"></p><blockquote><p>TIM官网：<a href="https://office.qq.com/">https://office.qq.com/</a></p></blockquote><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>微信，懂得都懂，都在用，没办法。当然，不喜欢下载微信客户端的话也可以使用微信网页版。</p><blockquote><p>微信Win10客户端下载：<a href="https://pc.weixin.qq.com/?lang=zh_CN">https://pc.weixin.qq.com/?lang=zh_CN</a><br>微信网页版：<a href="https://wx.qq.com/">https://wx.qq.com/</a></p></blockquote><h3 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h3><p>QQ音乐，国内的音乐软件也就QQ音乐和网易云音乐两个平台最火热，但是网易云很多歌曲因为版权问题歌单变灰，不能听了，虽然QQ音乐也不见得多好，但我还是选择了使用它。</p><p>PS:我知道有些软件可以“解锁”网易云灰色歌单，或者可以直接听收费的音乐，但是用起来要么是麻烦要么不是那么舒服，我也曾经使用过一些类似的软件，但是本人不是发烧友，也不喜欢看歌曲评论，为了少折腾，QQ音乐是我现阶段最好的选择。如果喜欢听的歌以国外的歌曲为主，可以选择Apple Music。</p><blockquote><p>QQ音乐官网：<a href="https://y.qq.com/download/index.html">https://y.qq.com/download/index.html</a></p></blockquote><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><h3 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h3><p>Steam，蒸汽平台要面世了管我Steam什么事呢(滑稽)。需要注意的是steam的任何资源请认准steam官网，不要以为浏览器搜出来的steam管家之类的就是官方平台，纯粹骗钱的。</p><blockquote><p>steam官网：<a href="https://store.steampowered.com/">https://store.steampowered.com/</a></p></blockquote><h3 id="UU网游加速器：免费加速Steam社区"><a href="#UU网游加速器：免费加速Steam社区" class="headerlink" title="UU网游加速器：免费加速Steam社区"></a>UU网游加速器：免费加速Steam社区</h3><p>UU网游加速器，喜欢逛社区的可以使用一下，包括steam个人主页也都是需要加速社区才可以访问的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153902.png" alt="image-20210127154151291"></p><blockquote><p>UU加速器官网：<a href="https://uu.163.com/">https://uu.163.com/</a></p></blockquote><h3 id="Minecraft-Java-Edition：我的世界Java版"><a href="#Minecraft-Java-Edition：我的世界Java版" class="headerlink" title="Minecraft Java Edition：我的世界Java版"></a>Minecraft Java Edition：我的世界Java版</h3><ul><li>Plain Craft Launcher 2：我目前正在用的启动器(虽然我是用的预览版，没买正式版，但目前来看还是很好用的一款启动器)，颜值高、可以自动装forge、fabric、optifine，可以直接通过启动器装mod(似乎不全)，功能很强大，个人觉着挺好用的。(有能力支持正式版，没能力的像我这种穷孩子用公开预览版也没事，在作者的爱发电平台下载，正式版找”Alpha”，预览版找”Beta”)</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316192538.png" alt="image-20210316192538576"></p><blockquote><p>作者龙腾猫跃的爱发电：<a href="https://afdian.net/@LTCat">https://afdian.net/@LTCat</a></p></blockquote><ul><li>MultiMC，一款只支持正版用户使用的MC启动器，可以多个版本共存，各个实例之间互不影响，mod支持也十分友好，mod加载器使用其提供的forge/fabric可以直接安装。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153906.png" alt="image-20210127153234044"></p><blockquote><p>MultiMC官网：<a href="https://multimc.org/">https://multimc.org/</a></p></blockquote><ul><li>HMCL，我使用的第一个启动器，支持离线登录/正版登录/第三方平台登录，此启动器一般建议一个启动器只安装一个游戏版本，因为他的各个版本之间的.minecraft文件夹是不会自行区分的，而是都堆在启动器本身所在的目录下，有多版本需求的只需要将启动器本体复制到另一个目录下即可。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153909.png" alt="image-20210127153540080"></p><blockquote><p>HMCL官网：<a href="https://hmcl.huangyuhui.net/">https://hmcl.huangyuhui.net/</a><br>HMCL Github：<a href="https://github.com/huanghongxun/HMCL">https://github.com/huanghongxun/HMCL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
