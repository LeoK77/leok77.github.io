<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库系统实验-第三章-数据库的安全性控制</title>
      <link href="2021/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p></blockquote><h2 id="实验3-1——用户标识与鉴别"><a href="#实验3-1——用户标识与鉴别" class="headerlink" title="实验3.1——用户标识与鉴别"></a>实验3.1——用户标识与鉴别</h2><blockquote><p>实验目的：本实验的目的是通过实验加深对数据安全性的理解，并掌握SQL Server中有关用户登录认证及管理方法</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server Management Studio中设置SQL Server的安全认证模式</li><li>在SQL Server中建立一个名为“李勇”的登录用户、数据库用户</li><li>演示在SQL Server中取消“李勇”这个用户</li></ol><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server Management Studio中将所属的SQL Server服务器设置为Windows NT和SQL Server混合安全认证模式</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512081800.png" alt="image-20210512081800613"></p><p>(2)在SQL Server Management Studio中为自己建立一个服务器用户、数据库用户</p><p>以新建的服务器用户“李勇”登录，在服务器属性的权限页面如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512082802.png" alt="image-20210512082802666"></p><p>(3)使用Transact_SQL撤销李勇这个登录账号(在管理员模式下)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School</span><br><span class="line"><span class="keyword">exec</span> sp_revokedbaccess <span class="string">&#x27;李勇&#x27;</span>;</span><br><span class="line"><span class="keyword">exec</span> sp_droplogin <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512083644.png" alt="image-20210512083644791"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在School数据库中创建账号”王二”，密码：123，并向其授予数据库访问权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_addlogin <span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;School&#x27;</span>, <span class="string">&#x27;English&#x27;</span></span><br><span class="line">go</span><br><span class="line">USE School</span><br><span class="line">go</span><br><span class="line"><span class="keyword">exec</span> sp_grantdbaccess <span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)撤销“王二”这个账号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School</span><br><span class="line"><span class="keyword">exec</span> sp_revokedbaccess <span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="keyword">exec</span> sp_droplogin <span class="string">&#x27;王二&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="实验3-2——自主存取控制"><a href="#实验3-2——自主存取控制" class="headerlink" title="实验3.2——自主存取控制"></a>实验3.2——自主存取控制</h2><blockquote><p>实验目的：通过实验加深对数据库存取控制机制的理解，通过自主存取控制进行权限管理，熟悉SQL-Server中的角色管理</p></blockquote><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>分别通过SQL Server Management Studio和SQL语言的数据控制功能，设置和管理数据操作权限。对新建用户“李勇”授予school数据库中students表的SELECT权限</li><li>通过SQL Server Management Studio，实现对SQL Server的用户和角色管理。具体是创建一个数据库角色OP_of_students，代表一个可以对students表进行操作的操作员，对角色的权限进行设置，并将“李勇”、“Web”添加到这个角色中。该实验体现角色应用灵活高效的特点</li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server中建立一个名为“李勇”的登录用户、School数据库的用户</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512090112.png" alt="image-20210512090112639"></p><p>(2)使用用户名为李勇，输入用户口令登录到SQL Server Management Studio，新建SQL查询。在“查询”的文本编辑器中输入SQL语句“SELECT * FROM STUDENTS”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息 229，级别 14，状态 5，第 3 行</span><br><span class="line">拒绝了对对象 &#39;STUDENTS&#39; (数据库 &#39;School&#39;，架构 &#39;dbo&#39;)的 SELECT 权限。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512090738.png" alt="image-20210512090738564"></p><p>(3)将School数据库的操作权限赋予数据库用户李勇</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以管理员身份登录</span></span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> STUDENTS</span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(4)在School数据库中新建OP_of_students角色</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512091455.png" alt="image-20210512091455445"></p><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)以sa账号登录SQL Server Management Studio，按“新建查询”快捷键，输入下列代码并执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;happyrat&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>, <span class="keyword">insert</span>, <span class="keyword">update</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> public;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">select</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br><span class="line">DENY <span class="keyword">update</span> <span class="keyword">ON</span> students <span class="keyword">TO</span> happyrat;</span><br></pre></td></tr></table></figure><p>(2)第1行代码新建了一个名为”李勇”的登录账户，”123456”是什么？”李勇”登录账户将映射为数据库用户名happyart，为什么？将是哪个数据库的用户？<br>解释第4~7行代码的作用。<br>若以账户李勇登录服务器，能否对school数据库的表students进行select和update操作，为什么？</p><ol><li>“123456”是”李勇”账户的口令(Password)</li><li>第3行代码中，通过sp_grantdbaccess将’李勇’映射到了’happyart’用户名</li><li>将是”School”数据库的用户，因为第2行代码将当前数据库切换为了”School”数据库</li><li>第4行代码：将对表STUDENTS的查询、插入、更新权限授予PUBLIC用户组</li><li>第5行代码：将对表STUDENTS的所有权限授予”happyart”用户名(即登录账户”李勇”)</li><li>第6行代码：收回”happyart”用户对表STUDENTS的查询权限</li><li>第7行代码：禁止”happyart”用户对表STUDENTS的更新权限</li><li>若以”李勇”登录服务器，可以对School数据库的表STUDENTS进行SELECT操作，不能进行UPDATE操作，因为”李勇”在School数据库中映射到用户名”happyart”上；虽然第6行代码收回了SELECT权限，但”李勇”依旧属于PUBLIC组，而PUBLIC组具有对STUDENTS的SELECT权限；第7行代码是禁止happyart对STUDENTS更新，即便PUBLIC组具有此权限，用户”李勇”也无法进行UPDATE操作，因为被DENY语句禁用了</li></ol><h2 id="实验3-3——视图机制在自主存取控制上的应用"><a href="#实验3-3——视图机制在自主存取控制上的应用" class="headerlink" title="实验3.3——视图机制在自主存取控制上的应用"></a>实验3.3——视图机制在自主存取控制上的应用</h2><blockquote><p>实验目的：通过实验加深对数据安全性的理解，熟悉视图机制在自主存取控制上的应用</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>创建选课表CHOICES上的视图CS_View，授权给计算机系的讲授计算科学这门课程(课程号：10010)的数据库用户李勇，让其具有视图上的SELECT权限</li><li>对视图上的Score属性列的UPDATE权限授予用户李勇，可以修改学生的成绩，但是不能对学生的基本信息，如学号、选课号进行修改</li></ol><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在数据库School上创建用户”李勇”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">USE School;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)用sa账户登录数据库。新建查询，然后在CHOICES表上创建视图CS_View(选课课程号10010)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_View</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CHOICES <span class="keyword">WHERE</span> Cid<span class="operator">=</span><span class="string">&#x27;10010&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(3)在视图CS_View上给用户”李勇”授予School的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> dbo.CS_View <span class="keyword">TO</span> &quot;李勇&quot;;</span><br></pre></td></tr></table></figure><p>(4)将视图CS_View上Score列的更新权限授予用户”李勇”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(score) <span class="keyword">ON</span> CS_View <span class="keyword">TO</span> &quot;李勇&quot;;</span><br></pre></td></tr></table></figure><p>(5)以用户李勇登录服务器，对CS_View进行查询操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CS_View;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512125001.png" alt="image-20210512125001747"></p><p>(6)对no为500024940的学生的成绩进行修改，改为90分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS_View</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span><span class="number">90</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">no</span><span class="operator">=</span><span class="string">&#x27;500024940&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CS_View <span class="keyword">WHERE</span> <span class="keyword">no</span><span class="operator">=</span><span class="string">&#x27;500024940&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512125218.png" alt="image-20210512125217989"></p><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在数据库School上创建用户”王二”。在STUDENTS表上创建视图grade2000，把年级为2000的学生元组放入视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_addlogin N<span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess N<span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> grade2000 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="string">&#x27;2000&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2)授予用户王二在视图grade2000的SELECT权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> grade2000 <span class="keyword">TO</span> &quot;王二&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span>N<span class="string">&#x27;王二&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> grade2000;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210512130312.png" alt="image-20210512130312544"></p><h2 id="实验3-4——PUBLIC角色在安全性中的应用"><a href="#实验3-4——PUBLIC角色在安全性中的应用" class="headerlink" title="实验3.4——PUBLIC角色在安全性中的应用"></a>实验3.4——PUBLIC角色在安全性中的应用</h2><blockquote><p>实验目的：通过实验加深对PUBILC角色的理解，特别是PUBLIC角色在安全性管理中的应用</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server 2005 Management Studio中新建查询，创建test登录用户以public访问数据库，在school数据库的students表上授权查询操作给public，验证test用户是否可以查询students，再撤销public权限，再验证是否可以查询</li><li>在school数据库的students表上授权查询操作给public，并授权给test用户，验证test用户是否可以查询students，先撤销public权限，验证是否可以查询，再撤销test权限，再验证是否可以查询</li><li>在school数据库的students表上授权查询操作给public，并授权给test用户，验证test用户是否可以查询students，先撤销test权限，验证是否可以查询，再撤销public权限，再验证是否可以查询</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)以管理员用户登录SQL Server，创建test登录用户以public访问数据库，在school数据库的students表上授权查询操作给public；<br>再以test用户登录SQL Server，新建查询验证是否可以对students表进行查询操作；<br>再以管理员用户登录，撤销public权限，然后以test用户登录，查询students</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 新建test用户</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_addlogin <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_grantdbaccess <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授权给public</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519112326.png" alt="image-20210519112326670"></p><p>(2)与管理员用户登录SQL SERVER，在school数据库的students表上授权查询操作给public和test；<br>再以test用户登录SQL Server，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回public的查询权限，再以test用户登录，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回test的查询权限，再以test用户登录，验证查询操作权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授权给public用户组和test用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC], test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销test权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519181535.png" alt="image-20210519181534971"></p><p>(3)与管理员用户登录SQL SERVER，在school数据库的students表上授权查询操作给public和test；<br>再以test用户登录SQL Server，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回test的查询权限，再以test用户登录，验证查询操作权限；<br>再以管理员用户登录SQL Server，收回public的查询权限，再以test用户登录，验证查询操作权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授权给public用户组和test用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">TO</span> [PUBLIC], test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销test权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 切换回管理员用户，撤销public权限</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> STUDENTS <span class="keyword">FROM</span> [PUBLIC];</span><br><span class="line"><span class="comment">-- 切换到test用户验证查询权限</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210519182028.png" alt="image-20210519182028582"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><ul><li>从实验中可以看出，授权给public与授权给指定用户有什么区别？在实际应用中，哪个更安全一些？</li></ul><p>从实验中可以看出，当某个用户拥有来自多个用户组的对某个表的相同权限的时候，授权给public与授权给指定用户是没有区别的，当且仅当收回此用户从属的所有用户组及用户自身的此权限(或者使用DENY语句禁用相应权限)之后，才可以彻底收回此用户的相应权限；<br>在实际应用中授权给指定用户更为安全，避免收回用户权限之后，用户还具有来自其他用户组的此权限</p><h2 id="实验3-5——理解架构的安全性管理"><a href="#实验3-5——理解架构的安全性管理" class="headerlink" title="实验3.5——理解架构的安全性管理"></a>实验3.5——理解架构的安全性管理</h2><blockquote><p>实验目的：通过实验加深对SQL Server中新增加的特性——架构(Schema)的理解，并对自定义的架构进行权限的授予与撤销，掌握SQL Server中的架构管理</p></blockquote><h3 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在SQL Server中创建一个user1用户，采用SQL Server身份验证，密码为user1，允许其访问数据库test，并加入dbowner的架构和角色成员，用user1登录SQL Server，创建表a，并查询表a，看执行语句是否正确？</li><li>在SQL Server中以管理员账户登录，再次创建表a，看执行是否正确，若正确，看看是否出现两个表a，若出现，执行一段插入语句insert a values(‘a’, ‘aa’)，在管理工具中查看数据插入到哪个表中？</li><li>分别在管理员账户和user1账户下新建查询，执行查询语句对表a进行查询，分别记录查询结果，并说明系统分别对哪个表a进行查询？</li></ol><h3 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)在SQL Server中创建一个user1的登录用户，采用SQL Server身份验证，密码user1，允许其访问数据库test，并加入dbowner的架构和角色成员；<br>用user1账户登录SQL Server新建查询，创建表a，在user1用户下查看test数据库下的对象</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br><span class="line"><span class="keyword">CREATE</span> LOGIN user1 <span class="keyword">with</span> password <span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>, default_database <span class="operator">=</span> test;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">for</span> LOGIN user1;</span><br><span class="line"><span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> user1 <span class="keyword">with</span> default_schema <span class="operator">=</span>db_owner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a;</span><br></pre></td></tr></table></figure><p>(2)以管理员账户登录SQL Server，创建表a，此时查询数据库test下对象，发现有两个表a</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520103614.png" alt="image-20210520103613933"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dbo.a;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> db_owner.a;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520103929.png" alt="image-20210520103929163"></p><p>(3)在SQL Server中以管理员账户登录，查询表a；再以user1账户登录，查询表a</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 管理员账户登录</span></span><br><span class="line">REVERT ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a;</span><br><span class="line"><span class="comment">-- 用户user1登录</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a;</span><br></pre></td></tr></table></figure><p>以管理员账户查询的是dbo.a，以user1账户查询的是db_owner.a，因为管理员账户的默认架构是dbo，而user1账户的默认架构是db_owner</p><h3 id="自我实践-4"><a href="#自我实践-4" class="headerlink" title="自我实践"></a>自我实践</h3><p>在实验中为什么能够成功地建立两个名称相同的表a？<br>如果对user1不分配dbowner的架构和角色成员，上述实验是否可以实现，请实验验证</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 管理员账户的默认架构是dbo，user1分配的默认架构是db_owner，所以创建表a时是在两个不同的架构中创建了同类型的表a，两者之间互不影响</span></span><br><span class="line"><span class="comment">-- 2. 如果不分配db_owner的架构和角色成员，上述实验不能实现</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> user1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">for</span> LOGIN user1;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a</span><br><span class="line">(</span><br><span class="line">    a1 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    b1 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 因为user1不属于db_owner的角色成员，所以user1不具有在test数据库中新建表的权限，也就无法创建两张表</span></span><br><span class="line"><span class="comment">-- 即便是user1属于db_owner的角色成员，不分配db_owner架构的情况下，user1的默认架构是dbo，同一数据库同一架构下的表名字互不相同，无法创建两张表</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/20210520104939.png" alt="image-20210520104939880"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统-LeetCode刷题记录-MSSQLSERVER</title>
      <link href="2021/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-MSSQLSERVER/"/>
      <url>2021/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-MSSQLSERVER/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自<a href="https://leetcode-cn.com/problemset/database/">LeetCode的数据库模块</a>，使用的语言环境是SQL Server(因为2021春季学期学的是SQL Server)</p></blockquote><p><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 条件中要求“无论person是否有地址信息，都需要基于上述两表提供person的地址信息”，即person无对应的地址信息时，需要返回NULL，可以使用左结合(LEFT JOIN)，需要注意此时不是用WHERE而是用ON</span></span><br><span class="line"><span class="keyword">SELECT</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">FROM</span> Person <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address</span><br><span class="line"><span class="keyword">ON</span> Person.PersonId <span class="operator">=</span> Address.PersonId;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 查询出来的列名要更改，不是默认的&quot;Salary&quot;，而是&quot;SecondHighestSalary&quot;</span></span><br><span class="line"><span class="comment">-- 2. 对于第二高的薪水，也就是比最高的薪水中，找最高的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary) <span class="string">&#x27;SecondHighestSalary&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Salary<span class="operator">&lt;</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary)</span><br><span class="line">    <span class="keyword">FROM</span> Employee</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name &quot;Employee&quot;</span><br><span class="line"><span class="keyword">FROM</span> Employee Staff</span><br><span class="line"><span class="keyword">WHERE</span> Salary<span class="operator">&gt;</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> Salary</span><br><span class="line">    <span class="keyword">FROM</span> Employee Manager</span><br><span class="line">    <span class="keyword">WHERE</span> Staff.ManagerId <span class="operator">=</span> Manager.Id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Email</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Email <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/">183. 从不订购的客户</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name &quot;Customers&quot;</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> CustomerId</span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/department-highest-salary/">184. 部门工资最高的员工</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 当一个表被重命名之后，使用这个表中的字段值时，需要用重命名后的表名</span></span><br><span class="line"><span class="keyword">SELECT</span> Department.Name &quot;Department&quot;,</span><br><span class="line">       Employee_Cur.Name &quot;Employee&quot;,</span><br><span class="line">       Salary</span><br><span class="line"><span class="keyword">FROM</span> Employee Employee_Cur, Department</span><br><span class="line"><span class="keyword">WHERE</span> DepartmentId <span class="operator">=</span> Department.Id</span><br><span class="line">  <span class="keyword">AND</span> Salary<span class="operator">=</span>(</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Salary)</span><br><span class="line">      <span class="keyword">FROM</span> Employee Employee_SameDept</span><br><span class="line">      <span class="keyword">WHERE</span> Employee_Cur.DepartmentId <span class="operator">=</span> Employee_SameDept.DepartmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. DELETE后面需要指定要删除的表</span></span><br><span class="line"><span class="comment">-- 2. DELETE可以FROM多张表(或一张表指定多个别名)，并对这多张表使用连接，只需在前面指定要删除满足条件的哪张表的元组即可</span></span><br><span class="line"><span class="keyword">DELETE</span> Person_Del</span><br><span class="line"><span class="keyword">FROM</span> Person Person_Del, Person Person_Save</span><br><span class="line"><span class="keyword">WHERE</span> Person_Del.Email <span class="operator">=</span> Person_Save.Email</span><br><span class="line">  <span class="keyword">AND</span> Person_Del.Id <span class="operator">&gt;</span> Person_Save.Id;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rising-temperature/">197. 上升的温度</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 此题使用到了Date类型的字段，计算两个日期之间的差值可以使用DATEDIFF函数，DATEDIFF(datepart,startdate,enddate)，比如此题是今天昨天，那么就是day，属于“天”这个量级</span></span><br><span class="line"><span class="comment">-- 2. WHERE后面条件的顺序也是需要考虑的，在AND的情况下，使用资源少的条件应该放在前面，因为先判断前面的再判断后面的，比如此题这两个条件，如果把DATEDIFF放在前面就会超时</span></span><br><span class="line"><span class="keyword">SELECT</span> Today.id</span><br><span class="line"><span class="keyword">FROM</span> Weather Today, Weather Yestoday</span><br><span class="line"><span class="keyword">WHERE</span> Today.Temperature<span class="operator">&gt;</span>Yestoday.Temperature</span><br><span class="line">  <span class="keyword">AND</span> DATEDIFF(<span class="keyword">day</span>, Yestoday.recordDate, Today.recordDate)<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, population, area</span><br><span class="line"><span class="keyword">FROM</span> World</span><br><span class="line"><span class="keyword">WHERE</span> area<span class="operator">&gt;=</span><span class="number">3000000</span></span><br><span class="line">   <span class="keyword">OR</span> population<span class="operator">&gt;=</span><span class="number">25000000</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/">596. 超过5名学生的课</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. 要求中有一个条件是“学生在每个课中不应被重复计算”，按照常识来说，如题所示的这个表中应该没有重复项，但是为了安全期间，在COUNT函数中增加了DISTINCT来进行去重</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line"><span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> student)<span class="operator">&gt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/not-boring-movies/">620. 有趣的电影</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意事项：</span></span><br><span class="line"><span class="comment">-- 1. LIKE后面的字符串用单引号括起来，不可以用双引号</span></span><br><span class="line"><span class="comment">-- 2. 判断两者是否相等就是用=，不要因为写其他语言写多的顺手写==</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cinema</span><br><span class="line"><span class="keyword">WHERE</span> description <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;boring&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-salary/">627. 变更性别</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注：参考自别人的解析，先使用ASCII函数将字符转换成ASCII码，计算得到转换后性别的ASCII码后，再用CHAR函数转换为字符类型</span></span><br><span class="line"><span class="keyword">UPDATE</span> salary</span><br><span class="line"><span class="keyword">SET</span> sex<span class="operator">=</span><span class="type">CHAR</span>(ASCII(<span class="string">&#x27;m&#x27;</span>) <span class="operator">-</span> ASCII(sex) <span class="operator">+</span> ASCII(<span class="string">&#x27;f&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统实验-第二章-数据库的完整性控制</title>
      <link href="2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
      <url>2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p></blockquote><h2 id="实验2-1——实体完整性"><a href="#实验2-1——实体完整性" class="headerlink" title="实验2.1——实体完整性"></a>实验2.1——实体完整性</h2><blockquote><p>实验目的：学习实体完整性的建立，以及实践违反实体完整性的结果</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>在数据库School中建立表Stu_Union，进行主键约束，在没有违反实体完整性的前提下插入并更新一条记录</li><li>演示违反实体完整性的插入操作</li><li>演示违反实体完整性的更新操作</li><li>演示事务的处理，包括事务的建立、处理，以及出错时的事务回退</li><li>通过建立Scholarship表，插入数据，演示当与现有的数据环境不等时，无法建立实体完整性以及参照完整性</li></ol><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)输入下述SQL语句并执行。并思考为什么把sno设置为””没有违反NOT NULL的约束？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Stu_Union</span><br><span class="line">(</span><br><span class="line">    Sno   <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sname <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    Ssex  <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    Sage  <span class="type">INT</span>,</span><br><span class="line">    Sdept <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Stu_Union <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (sno)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10000&#x27;</span>, N<span class="string">&#x27;王敏&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="comment">-- 没有违反NOT NULL约束的原因：</span></span><br><span class="line"><span class="comment">-- NULL是一个&quot;不知道&quot;或者&quot;不确定&quot;的数据值，不是0不是空格</span></span><br><span class="line"><span class="comment">-- Sno=&#x27;&#x27; 这里的 &#x27;&#x27; 是一个空字符串，而不是NULL，不满足NULL定义</span></span><br><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="string">&#x27;95002&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> N<span class="string">&#x27;王敏&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417125938.png" alt="image-20210417125938690"></p><p>(2)输入下述SQL语句并执行。违反主键的唯一性属性，破坏实体完整性，系统中止操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95002&#x27;</span>, N<span class="string">&#x27;王嘉&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130047.png" alt="image-20210417130047224"></p><p>(3)输入下述SQL语句并执行。违反主键的NOT NULL属性，破坏实体完整性，系统中止操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Stu_Union</span><br><span class="line"><span class="keyword">SET</span> Sno<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;95002&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130116.png" alt="image-20210417130116287"></p><p>(4)输入下述SQL语句并执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T1;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95009&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95003&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95005&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130208.png" alt="image-20210417130208185"></p><p>当SET XACT_ABORT为ON时，如果Transact-SQL语句产生运行时错误，整个事务将终止并回滚；为OFF时，只回滚产生错误的Transact-SQL语句，而事务将继续进行处理。<br>编译错误(语法错误等)不受SET XACT_ABORT ON影响。<br>对于大多数OLE DB提供程序(包括SQL Server)，隐性或显式事务中的数据修改语句必须将XACT_ABORT设置为ON；唯一不需要设置该选项的情况是提供程序支持嵌套事务时。</p><p>(5)输入下述SQL语句并执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这是一个会因为破坏完整性而回滚的事务实例</span></span><br><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T2;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95007&#x27;</span>, N<span class="string">&#x27;李明&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95009&#x27;</span>, N<span class="string">&#x27;李进&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130414.png" alt="image-20210417130414187"></p><p>(6)输入下述SQL语句并执行。配合(5)展示在SET XACT_ABORT ON的情况下TRANSACTION中的语句出错时，前面的即使正确的语句也会回滚</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br></pre></td></tr></table></figure><p>(7)输入下述SQL语句并执行。新建一个Scholarship表并插入两条数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">(</span><br><span class="line">    M_ID    <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Stu_id  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    R_money <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;700000&#x27;</span>, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;800000&#x27;</span>, <span class="number">8000</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Scholarship;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130442.png" alt="image-20210417130442514"></p><p>(8)输入下述SQL语句并执行。当前的数据环境不满足M_ID称为主键，因为数据列M_ID不满足实体完整性的唯一属性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> PK_Scholarship <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (M_ID);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130507.png" alt="image-20210417130507461"></p><p>(9)输入下述SQL语句并执行。 Scholarship数据库中的数据，不满足Stu_id与STUDENTS表中的sid的对应性，所以创建参照完整性失败</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Scholarship</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Scholarship <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Stu_id) <span class="keyword">REFERENCES</span> STUDENTS (sid);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130532.png" alt="image-20210417130532354"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)在School数据库中建立一张新表Class<br>– 包括Class_id(varchar(4))，name(varchar(10))，Department(varchar(20))<br>– 并约束Class_id为主键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Class</span><br><span class="line">(</span><br><span class="line">    Class_id   <span class="type">VARCHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    name       <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Department <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Class <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2)创建事务T3，在事务中插入一个元组(‘00001’, ‘01CSC’, ‘CS’)<br>– 并在T3中嵌套创建事务T4，T4也插入和T3一样的元组，编写代码测试，查看结果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> XACT_ABORT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T3;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Class</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;01CSC&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Class;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION T4;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Class</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;01CSC&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T4;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION T3;</span><br><span class="line"><span class="comment">-- 执行失败，因为T4插入的元组破坏了实体完整性，导致T4事务失败，而T4事务处于T3事务内部，所以T3事务也相应失败，前面的插入语句回滚，Class表为空</span></span><br></pre></td></tr></table></figure><h2 id="实验2-2——参照完整性"><a href="#实验2-2——参照完整性" class="headerlink" title="实验2.2——参照完整性"></a>实验2.2——参照完整性</h2><blockquote><p>实验目的：学习建立外键，以及利用FOREIGN KEY……REFERENCES子句以及各种约束保证参照完整性</p></blockquote><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>演示参照完整性</li><li>演示涉及参照完整性的级联删除</li><li>演示涉及参照完整性的多重级联删除</li><li>修改外键的约束</li><li>演示互参照问题及解决方法</li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)为演示参照完整性，建立表Course，令Cno为其主键，并在Stu_Union中插入数据，为下面的实验步骤做预先准备</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Union</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;EE&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course</span><br><span class="line">(</span><br><span class="line">    Cno     <span class="type">CHAR</span>(<span class="number">4</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Cname   <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Cpoints <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Cno)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>, <span class="string">&#x27;ComputerNetworks&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;0002&#x27;</span>, <span class="string">&#x27;Database&#x27;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130806.png" alt="image-20210417130806718"></p><p>(2)建立表SC，令Sno和Cno分别为参照Stu_Union表以及Course表的外键，设定为级联删除，并令(Sno, Cno)为其主键。在不违反参照完整性的前提下，插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(</span><br><span class="line">    Sno   <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    Cno   <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    Grade <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_SC <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Sno, Cno),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;95002&#x27;</span>, <span class="string">&#x27;0001&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;95002&#x27;</span>, <span class="string">&#x27;0002&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;0001&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;0002&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130836.png" alt="image-20210417130835965"></p><p>(3)演示违反参照完整性的插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;99&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 语句与 FOREIGN KEY 约束&quot;FK__SC__Sno__6E01572D&quot;冲突。该冲突发生于数据库&quot;School&quot;，表&quot;dbo.Stu_Union&quot;, column &#x27;Sno&#x27;。</span></span><br><span class="line"><span class="comment">-- 即此插入语句中的Sno在Stu_Union表中不存在，Cno在Course表中不存在，不满足外键条件，破坏了参照完整性</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130901.png" alt="image-20210417130901529"></p><p>(4)在Stu_Union中删除数据，演示级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="comment">-- SC表中的Sno具有ON DELETE CASCADE具有连带删除作用，也就是在STUDENTS中删除某个学号，SC表中的对应这个学号为外键的所有记录都会被删除</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130934.png" alt="image-20210417130934721"></p><p>(5)在Course中删除数据，演示级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="comment">-- SC表中的Cno具有ON DELETE CASCADE具有连带删除作用，也就是在Course中删除某个课程号，SC表中的对应这个课程号为外键的所有记录都会被删除</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417130951.png" alt="image-20210417130951369"></p><blockquote><p>PS：6~10第一遍的时候忘了截图，数据库中内容已经被删除了，可以通过换学号来重新演示，但是个人比较懒，就不换学号从头来一遍了</p></blockquote><p>(6)为了演示多重级联删除，建立Stu_Card表，令Stu_id为参照Stu_Union表的外键，令Card_id为其主键，并插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Stu_Card</span><br><span class="line">(</span><br><span class="line">    card_id        <span class="type">CHAR</span>(<span class="number">14</span>),</span><br><span class="line">    Stu_id         <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">REFERENCES</span> STUDENTS (sid) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    remained_money <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Stu_Card <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (card_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Stu_Card</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;05212567&#x27;</span>, <span class="string">&#x27;800001216&#x27;</span>, <span class="number">100.25</span>),</span><br><span class="line">       (<span class="string">&#x27;05212222&#x27;</span>, <span class="string">&#x27;800005753&#x27;</span>, <span class="number">200.50</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br></pre></td></tr></table></figure><p>(7)为了演示多重级联删除，建立ICBC_Card表，令Stu_card_id为参照Stu_Card表的外键，令bank_id为其主键，并插入数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">(</span><br><span class="line">    bank_id        <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    stu_card_id    <span class="type">CHAR</span>(<span class="number">14</span>) <span class="keyword">REFERENCES</span> Stu_Card (card_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    restored_money <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_ICBC_Card <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (bank_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ICBC_Card</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;9558844022312&#x27;</span>, <span class="string">&#x27;05212567&#x27;</span>, <span class="number">15000.1</span>),</span><br><span class="line">       (<span class="string">&#x27;9558844023645&#x27;</span>, <span class="string">&#x27;05212222&#x27;</span>, <span class="number">50000.3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(8)通过删除STUDENTS表中的一条记录，演示三个表的多重级联删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> CHOICES</span><br><span class="line">    <span class="keyword">DROP</span> [FK_CHOICES_STUDENTS];</span><br><span class="line"><span class="comment">-- 需要将CHOICES中引用STUDENTS表中的外键设置为ON DELETE CASCADE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> CHOICES</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> [FK_CHOICES_STUDENTS] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> ([sid]) <span class="keyword">REFERENCES</span> [dbo].[STUDENTS] ([sid]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800001216&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(9)演示事务中进行多重级联失败的处理。修改ICBC_Card表中的外键属性，使其变为On delete No action，演示事务中通过删除STUDENTS表中的一条记录，多重级联删除失败，整个事务回滚到事务的初始状态</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改外键约束类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> FK__ICBC_Card__stu_c__74AE54BC;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ICBC_Card</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_ICBC <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (stu_card_id)</span><br><span class="line">        <span class="keyword">REFERENCES</span> Stu_Card (card_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="comment">-- ON DELETE NO ACTION不能级联删除</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION DEL;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800005753&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION DEL;</span><br><span class="line"><span class="comment">-- 查看上述操作是否生效(是否成功删除)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Card;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ICBC_Card;</span><br></pre></td></tr></table></figure><p>(10)演示互参照问题及其解决方法。要建立教师授课和课程教师听课关系的两张表，规定一个教师可以授多门课，但是每个课程只能指定一个教师去听课，所以要为两张表建立相互之间的参照关系</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以下建表会失败，因为定义Listen_Course表的时候Teach_Course表还没建立，无法作为外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">(</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>,</span><br><span class="line">    Tname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Listen_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Teacher_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Listen_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Course_id) <span class="keyword">REFERENCES</span> Teach_Course (Course_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teach_Course</span><br><span class="line">(</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Cname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Teach_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Course_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Teach_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Teacher_id) <span class="keyword">REFERENCES</span> Listen_Course (Teacher_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131407.png" alt="image-20210417131407273"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解决方法，先创建Listen_Course不带外键，再创建Teach_Course，再ALTER TABLE将外键插入到Listen_Course中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">(</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>,</span><br><span class="line">    Tname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Listen_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Teacher_id),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teach_Course</span><br><span class="line">(</span><br><span class="line">    Course_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Cname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Teacher_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Teach_Course <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Course_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Teach_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Teacher_id) <span class="keyword">REFERENCES</span> Listen_Course (Teacher_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Listen_Course</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Listen_Course <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Course_id) <span class="keyword">REFERENCES</span> Teach_Course (Course_id);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131536.png" alt="image-20210417131536805"></p><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)用ALTER TABLE语句将SC表中的ON DELETE CASCADE改为ON DELETE NO ACTION，重新插入SC的数据，重复操作上述实验内容的4.5.观察结果，分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK__SC__Sno__6E01572D;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK__SC__Cno__6EF57B66;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Sno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Cno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION;</span><br><span class="line"><span class="comment">-- 执行实验内容的4.5.时执行失败，因为ON DELETE NO ACTION不是级联删除，在删除的时候会不采取动作，产生冲突</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Stu_Union</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;95002&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;0001&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>(2)用ALTER TABLE语句将SC表中的ON DELETE CASCADE改为ON DELETE SET NULL，重新插入SC的数据，重复操作上述实验内容的4.5.观察结果，分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE SET NULL执行失败，因为外键参考的主键有不可为空的约束条件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">DROP</span> FK_SC_Sno,</span><br><span class="line">        FK_SC_Cno;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SC_Sno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Stu_Union (Sno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> FK_SC_Cno <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course (Cno) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>(3)创建一个班里的学生互助表，规定：包括学生编号，学生姓名，学生的帮助对象，每个学生有且仅有一个帮助对象，帮助对象也必须是班里的学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MutualAid</span><br><span class="line">(</span><br><span class="line">    Sno       <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sname     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    AidObject <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">REFERENCES</span> MutualAid (Sno),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_MutualAid <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Sno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(4)学校学生会的每个部们都有一个部长，每个部长领导多个部员，每个部只有一个部员有评测部长的权利。<br>– 给出体现这两种关系(领导和评测)的两张互参照的表的定义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Leader</span><br><span class="line">(</span><br><span class="line">    Leader_id <span class="type">CHAR</span>,</span><br><span class="line">    Lname      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Depart_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Leader <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Leader_id),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Depart_Choose_Leader</span><br><span class="line">(</span><br><span class="line">    Depart_id  <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Dname      <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    Leader_id <span class="type">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Depart_Choose_Leader <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Depart_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_Depart_Choose_Leader <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Leader_id) <span class="keyword">REFERENCES</span> Leader (Leader_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Leader</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Leader <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Depart_id) <span class="keyword">REFERENCES</span> Depart_Choose_Leader (Depart_id);</span><br></pre></td></tr></table></figure><h2 id="实验2-3——用户自定义完整性"><a href="#实验2-3——用户自定义完整性" class="headerlink" title="实验2.3——用户自定义完整性"></a>实验2.3——用户自定义完整性</h2><blockquote><p>实验目的：学习用户自定义约束</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>掌握创建表时创建自定义UNIQUE约束、CHECK约束</li><li>掌握插入新建的用户自定义约束</li><li>掌握创建Rule以及Rule与表属性的绑定，以及绑定的解除</li></ol><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)创建Worker表，并自定义两个约束U1以及U2，其中U1规定Name字段唯一，U2规定Sage(级别)字段的上限是28</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">(</span><br><span class="line">    Number     <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    Name       <span class="type">CHAR</span>(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> U1 <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Sex        <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    Sage       <span class="type">INT</span></span><br><span class="line">        <span class="keyword">CONSTRAINT</span> U2 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;=</span> <span class="number">20</span>),</span><br><span class="line">    Department <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_Worker <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2)在Worker表中插入一条合法记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00001&#x27;</span>, N<span class="string">&#x27;李勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">14</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Worker;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131642.png" alt="image-20210417131642828"></p><p>(3)演示违反U2约束的例子，规定U2元组的sage属性的值必须小于等于28</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00002&#x27;</span>, N<span class="string">&#x27;王勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131709.png" alt="image-20210417131709916"></p><p>(4)去除U2约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">    <span class="keyword">DROP</span> U2;</span><br></pre></td></tr></table></figure><p>(5)重新插入(3)中想要插入的数据，由于去除了U2约束，所以插入成功</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00002&#x27;</span>, N<span class="string">&#x27;王勇&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Worker;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131747.png" alt="image-20210417131747154"></p><p>(6)创建规则rule_sex，规定插入或更新的值只能是M或F，并绑定到Worker的sex字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE rule_sex <span class="keyword">AS</span> <span class="variable">@value</span> <span class="keyword">IN</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line"><span class="keyword">EXEC</span> sp_bindrule rule_sex, <span class="string">&#x27;Worker.Sex&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(7)演示违反规则rule_sex的插入操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00003&#x27;</span>, N<span class="string">&#x27;王浩&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">25</span>, N<span class="string">&#x27;研发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417131813.png" alt="image-20210417131813579"></p><p>(8)解除Worker.sex与rule_sex的绑定</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_unbindrule <span class="string">&#x27;Worker.Sex&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)加入约束U3，令Sage的值大于等于0</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Worker</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> U3 <span class="keyword">CHECK</span> (Sage <span class="operator">&gt;=</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">-38</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(2)加入规则R2，确保插入的记录的Sage值在1到100之间，并绑定的Sage上</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE rule_sage <span class="keyword">AS</span> <span class="variable">@value</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="variable">@value</span> <span class="operator">&lt;=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_bindrule rule_sage, <span class="string">&#x27;Worker.Sage&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00005&#x27;</span>, N<span class="string">&#x27;TEST-R2&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">99</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00006&#x27;</span>, N<span class="string">&#x27;R2-WA&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">101</span>, N<span class="string">&#x27;科技部&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="实验2-4——触发器"><a href="#实验2-4——触发器" class="headerlink" title="实验2.4——触发器"></a>实验2.4——触发器</h2><blockquote><p>实验目的：通过实验使学生加深对数据完整性的理解，学会创建和使用触发器</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>创建和使用触发器，学习使用SQL Server的触发器(与SQL标准的触发器语法不太一样)</li><li>测试使用违法触发器约束的语句时的结果</li><li>学习INSTEAD OF触发器在不可更新视图上的应用</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)为worker表创建触发器T1，当插入或是更新表中数据时，保证所操作的记录的Sage值大于0</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T1</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">INSERT</span> , <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF (<span class="keyword">SELECT</span> Sage</span><br><span class="line">           <span class="keyword">FROM</span> inserted) <span class="operator">&lt;</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;Sage must be a integer more than zero! Transaction fail&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(2)为Worker表建立触发器T2，禁止删除编号为00001的CEO</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T2</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">DELETE</span></span><br><span class="line">    <span class="keyword">AS</span> IF (<span class="keyword">SELECT</span> Number</span><br><span class="line">           <span class="keyword">FROM</span> deleted) <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;He is the CEO! Delete Fail!&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(3)Worker表中的人员的编号是不可改变的，创建触发器T3实现更新中编号的不可改变性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T3</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF <span class="keyword">UPDATE</span>(Number)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;Every number cannot be changed!&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>(4)演示违反T1触发器的约束的插入操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00005&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">-10</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120142.png" alt="image-20210417120142140"></p><p>(5)演示违反T1触发器的约束的更新操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span> <span class="number">-7</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120232.png" alt="image-20210417120232781"></p><p>(6)演示违反T2触发器的约束的删除操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Worker</span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417120452.png" alt="image-20210417120452503"></p><p>(7)演示违反T3触发器的约束的更新操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Number<span class="operator">=</span><span class="string">&#x27;00007&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417121116.png" alt="image-20210417121116420"></p><p>(8)演示INSTEAD OF触发器在不可更新视图上的运用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建不可更新视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> StudentScholarShip <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ST.sid, ST.sname, ST.grade, SC.R_money</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS ST,</span><br><span class="line">     Scholarship SC</span><br><span class="line"><span class="keyword">WHERE</span> ST.sID <span class="operator">=</span> SC.Stu_id;</span><br><span class="line"><span class="comment">-- 测试不可更新视图</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentScholarShip</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="number">2003</span>, <span class="number">1500</span>);</span><br><span class="line"><span class="comment">-- 创建触发器，将原本一次性插入到StudentScholarShip视图的INSERT语句分解，从而避免一次对多个基表进行操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Ins_Stu_Scholarship</span><br><span class="line">    <span class="keyword">ON</span> StudentScholarShip</span><br><span class="line">    INSTEAD <span class="keyword">OF</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line">    IF (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">            <span class="keyword">FROM</span> STUDENTS S,</span><br><span class="line">                 inserted i</span><br><span class="line">            <span class="keyword">WHERE</span> S.sid <span class="operator">=</span> i.sid</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS</span><br><span class="line">            <span class="keyword">SELECT</span> sid, sname, <span class="keyword">null</span>, grade</span><br><span class="line">            <span class="keyword">FROM</span> inserted</span><br><span class="line">            <span class="keyword">DECLARE</span> <span class="variable">@MAX</span>_M_ID <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="variable">@MAX</span>_M_ID <span class="operator">=</span> <span class="built_in">MAX</span>(M_ID)</span><br><span class="line">            <span class="keyword">FROM</span> Scholarship</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scholarship</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="variable">@MAX</span>_M_ID <span class="operator">+</span> <span class="number">1</span>, sid, R_money</span><br><span class="line">            <span class="keyword">FROM</span> inserted</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        PRINT N<span class="string">&#x27;数据已经存在&#x27;</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">-- 测试插入，此时可以进行更新</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentScholarShip</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="number">2003</span>, <span class="number">1500</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> StudentScholarShip;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;1000&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Scholarship</span><br><span class="line"><span class="keyword">WHERE</span> Stu_id <span class="operator">=</span> <span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417122314.png" alt="image-20210417122314341"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)建立一个在Work表上的触发器T4，要求插入记录的Sage值必须比表中已记录的最大的Sage值大</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T4</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">AS</span> IF (((<span class="keyword">SELECT</span> Sage</span><br><span class="line">             <span class="keyword">FROM</span> inserted) <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">Max</span>(sage)</span><br><span class="line">                               <span class="keyword">FROM</span> Worker))</span><br><span class="line">            <span class="keyword">OR</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                 <span class="keyword">FROM</span> Worker</span><br><span class="line">                 <span class="keyword">WHERE</span> Sage <span class="operator">=</span> (</span><br><span class="line">                     <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Sage)</span><br><span class="line">                     <span class="keyword">FROM</span> Worker</span><br><span class="line">                 )) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        PRINT <span class="string">&#x27;SOMETHING WRONG&#x27;</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不满足触发器条件的插入语句会拒绝执行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">38</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 满足触发器条件的插入语句顺利执行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Worker</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;00004&#x27;</span>, N<span class="string">&#x27;李红&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">39</span>, N<span class="string">&#x27;开发部&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417125209.png" alt="image-20210417125209016"></p><p>(2)建立一个在Worker表上的触发器T5，要求当更新一个记录的时候，表中记录的Sage值要比老记录的Sage大，因为一般工资级别只能升不能降</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T5</span><br><span class="line">    <span class="keyword">ON</span> Worker</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">AS</span> IF ((<span class="keyword">SELECT</span> Sage</span><br><span class="line">            <span class="keyword">FROM</span> inserted) <span class="operator">&lt;=</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                               <span class="keyword">FROM</span> deleted))</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span> TRANSACTION</span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不满足触发器条件的更新语句会拒绝执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage <span class="operator">=</span> Sage <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00005&#x27;</span>;</span><br><span class="line"><span class="comment">-- 满足触发器条件的更新语句顺利执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> Worker</span><br><span class="line"><span class="keyword">SET</span> Sage <span class="operator">=</span> Sage <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> Number <span class="operator">=</span> <span class="string">&#x27;00005&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6/20210417124003.png" alt="image-20210417124003208"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第二章-进程管理</title>
      <link href="2021/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《操作系统考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统网课</a>。</p></blockquote><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的基本知识"><a href="#进程的基本知识" class="headerlink" title="进程的基本知识"></a>进程的基本知识</h3><ul><li>程序：一个指令序列。<ul><li>在早期的计算机中，只支持<strong>单道</strong>程序，也就是同一时间计算机的所有设备(CPU、内存、I/O设备等)都是只为这一道程序服务，这个阶段<strong>只有程序段和数据段</strong>：<ul><li>程序段：存放程序的代码</li><li>数据段：存放程序运行过程中处理的数据(如变量)</li></ul></li><li>引入<strong>多道</strong>程序技术之后，内存中同时存放多道程序，各个程序的代码、运算数据存放的位置不同。为了方便操作系统管理，完成<strong>各程序并发执行</strong>，引入了<strong>进程</strong>和<strong>进程实体</strong>的概念，<strong>PCB、程序段、数据段</strong>这三部分共同构成了<strong>进程实体</strong>(进程映像)<ul><li>PCB：进程控制块，是操作系统为每个运行的程序配置的一个数据结构，<strong>用来描述进程的各种信息</strong>(如<strong>程序代码存放位置</strong>及程序计数器、程序状态字、各种数据寄存器等<strong>处理机现场信息</strong>)</li></ul></li></ul></li></ul><p>进程实体(进程映像)：由程序段、数据段、PCB三部分组成。一般情况下，我们把进程实体简称为进程(实际上进程是动态的，进程实体是静态的)，例如，所谓创建进程，实质上就是创建进程实体中的PCB；而撤销进程，实质上就是撤销进程实体中的PCB，<strong>PCB是进程存在的唯一标志</strong>。</p><ul><li>进程的定义：强调“动态性”<ol><li>进程是程序的一次<strong>执行过程</strong></li><li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong></li><li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，是系统进行资源分配和调度的一个独立单位</li></ol></li><li>引入进程实体的概念之后，可以把进程定义为：<ul><li>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位</li></ul></li></ul><blockquote><p>可知，严格意义上来说，进程实体和进程并不一样，进程实体是<strong>静态</strong>的，而进程是<strong>动态</strong>的。不过，除非题目专门考察二者的区别，否则可以认为进程实体就是进程。因此也可以说“进程是由程序段、数据段、PCB三部分组成”，但并不严谨</p></blockquote><ul><li>进程的组成(进程<strong>内部</strong>由哪些部分构成)：进程(进程实体)由<strong>程序段、数据段、PCB三部分组成</strong><ol><li>程序段：存放程序的代码</li><li>数据段：存放程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量等</li><li>PCB：操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需要的各种信息——<strong>进程管理者(操作系统)所需要的数据</strong>都在PCB里；与之相对的，程序段和数据段存放的是<strong>程序本身运行所需的数据</strong><ol><li>进程描述信息</li><li>进程控制和管理信息</li><li>资源分配清单</li><li>处理机相关信息</li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401184534.png" alt="image-20210401184534228"></p><ul><li>进程的组织(<strong>多个进程之间</strong>的组织方式问题)<ol><li>链接方式：<ol><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ol></li><li>索引方式：<ol><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有各个索引表的指针</li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401185832.png" alt="image-20210401185832616"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401190012.png" alt="image-20210401190012228"></p><ul><li>进程的特征<ol><li>动态性(最基本的特征)：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性：内不能中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位；<strong>进程是资源分配、接受调度的基本单位</strong></li><li>异步性：各进程按给自独立的、不可预知的速度向前推进，操作系统要提供<strong>“进程同步机制”</strong>来解决异步问题——异步性会导致并发程序执行结果的不确定性。</li><li>结构性：每个进程都会配置一个PCB；从结构上看，进程由程序段、数据段和PCB组成</li></ol></li></ul><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><ul><li>进程的三种基本状态：<ol><li>运行态(Running)：占有CPU，并在CPU上运行<ol><li>在单核CPU环境下，每一个时刻最多只有一个进程处于运行态；n核处理机环境下可以有n个进程处于运行态</li></ol></li><li>就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU而暂时不能运行<ol><li>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，就可以进入运行态开始运行</li></ol></li><li>阻塞态(Waiting/Blocked，等待态)：因等待某一事件而暂时不能运行，完成这件事之后会进入就绪态<ol><li>例如等待操作系统分配打印机、等待读写磁盘操作的结果</li><li>CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</li></ol></li></ol></li><li>进程的另外两种状态：<ol><li>创建态(New，新建态)：操作系统需要完成创建进程——操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB</li><li>终止态(Terminated，结束态)：进程运行结束(或由于Bug导致进程无法继续执行下去，例如数组越界错误)，需要撤销进程——操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销进程PCB等工作</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401192743.png" alt="image-20210401192743370"></p><ul><li><p>进程的状态(五状态模型)：</p><ul><li>运行态：拥有CPU，拥有其他所需资源</li><li>就绪态：没有CPU，拥有其他所需资源</li><li>阻塞态：没有CPU，没有其他所需资源</li><li>创建态：操作系统为新进程分配资源、创建PCB</li><li>终止态：操作系统回收进程的资源、撤销PCB</li></ul></li><li><p>进程状态间的转换(五状态模型)：</p><ul><li>就绪态-&gt;运行态：进程被调度</li><li>运行态-&gt;就绪态：时间片到，或CPU被其他高优先级进程抢占</li><li>运行态-&gt;阻塞态：等待系统资源分配，或等待某事件发生(主动行为)</li><li>阻塞态-&gt;就绪态：资源分配到位，等待的事件发生(被动行为)</li><li>创建态-&gt;就绪态：系统完成创建进程相关的工作</li><li>运行态-&gt;终止态：进程运行结束，或运行过程中遇到不可修复的错误</li></ul></li><li><p>进程的状态(七状态模型)：除了上述五状态以外，还有两种挂起状态——挂起态(Suspend)，即暂时调到外存等待的进程状态为挂起状态</p><ul><li>就绪挂起：</li><li>阻塞挂起：</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402132124.png" alt="image-20210402132124159"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能——<strong>实现进程状态转换</strong></p><ul><li>进程控制的需要实现的功能：<ul><li>创建进程：初始化PCB、分配系统资源</li><li>创建态-&gt;就绪态：修改PCB内容和相应队列</li><li>就绪态-&gt;运行态：恢复进程运行环境、修改PCB内容和相应队列</li><li>运行态-&gt;阻塞态：保存进程运行环境、修改PCB内容和相应队列</li><li>阻塞态-&gt;就绪态：修改PCB内容和相应对列；如果等待的是资源，还需为进程分配系统资源</li><li>运行态-&gt;就绪态(进程切换)：保存进程运行环境、修改PCB内容和相应对列</li><li>运行态-&gt;终止态：回收进程拥有的资源、撤销PCB</li></ul></li></ul><p>用<strong>原语</strong>(操作系统内核的一部分，运行在核心态)实现进程控制，原语的特点是<strong>执行期间不允许中断</strong>，只能一气呵成；这种不可以被中断的操作被称为<strong>原子操作</strong>。原语采用“关中断指令”和“开中断指令”来实现——当使用<strong>关中断指令</strong>之后，对接受到的外部中断信号不采取措施，只有使用<strong>开中断指令</strong>之后，收到外部中断信号才会进入相应的中断处理程序——显然，<strong>开中断/关中断指令</strong>属于特权指令，只能在核心态下执行。</p><ul><li>原语：<ol><li>更新PCB中的信息(修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<ol><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复其运行环境</li></ol></li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol></li></ul><ol><li>进程的创建：<ul><li>创建原语：无-&gt;创建态-&gt;就绪态<ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul></li><li>引起进程创建的事件：<ul><li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些情况时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul></li></ul></li><li>进程的终止：<ul><li>撤销原语：就绪态/阻塞态/运行态-&gt;终止态-&gt;无<ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的事件：<ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul></li></ul></li><li>进程的阻塞和唤醒——阻塞原语和唤醒原语成对使用<ul><li>进程的阻塞：<ul><li>阻塞原语：运行态-&gt;阻塞态<ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>等待系统分配某种资源</li><li>等待相互合作的其他进程完成工作</li></ul></li></ul></li><li>进程的唤醒：<ul><li>唤醒原语：阻塞态-&gt;就绪态<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件：<ul><li>等待的事件发生——因何事阻塞，应由何事唤醒</li></ul></li></ul></li></ul></li><li>进程的切换：<ul><li>切换原语：运行态-&gt;阻塞态/就绪态、就绪态-&gt;运行态<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应对列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li>引起进程切换的事件<ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401200220.png" alt="image-20210401200220258"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><strong>进程通信：进程之间的信息交换。</strong>因为进程是分配系统资源的基本单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立，为了保证系统安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>，但是进程之间的信息交换必须实现，为了保证进程间的安全通信，操作系统提供了三种方法：共享存储、消息传递、管道通信。</p><ol><li>共享存储——两个进程对共享空间的访问必须是<strong>互斥</strong>的(互斥访问通过操作系统提供的工具实现)，操作系统只负责提供<strong>共享空间</strong>和<strong>同步互斥工具(P/V操作等)</strong><ol><li>基于数据结构的共享：只能存放固定的数据结构，比如共享空间里只能存放一个长度为10的数组。<ol><li>速度慢、限制多，是<strong>低级通信方式</strong></li></ol></li><li>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。<ol><li>速度快，是<strong>高级通信方式</strong></li></ol></li></ol></li><li>管道通信——<strong>管道</strong>是指用于连接读写进程的一个共享文件，有名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区<ol><li>管道只能采用<strong>半双工通信</strong>，<strong>某一时间段内只能实现单向的传输</strong>，如果要实现双向<strong>同时</strong>通信则需要设置两个管道</li><li>各进程要<strong>互斥</strong>的访问管道</li><li>数据以字符流的形式写入管道，当<strong>管道写满</strong>时，写进程的write()系统调用将被阻塞，等待读进程将数据取走；当读进程将数据全部取走后，<strong>管道变空</strong>，此时读进程的read()系统调用将被阻塞</li><li>如果没写满，就不允许读；如果管道没读空，就不允许写</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程同一时间最多只能有一个</strong>，否则可能会有读错数据的情况</li></ol></li><li>消息传递——进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换<ol><li>格式化的消息：消息头和消息体组成。消息头包括发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(比如计算机网络中的“报文”就是格式化的消息)</li><li>直接通信方式——直接将消息挂到接收进程的消息缓冲队列上<ol><li>发送方使用发送原语将消息发送到接收方的消息缓冲队列的尾部</li><li>接收方使用接收原语从消息缓冲队列中依次读取消息</li></ol></li><li>间接通信方式——消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”，可以类比做计算机网络中的电子邮件系统<ol><li>发送方使用发送原句将消息发送到信箱中</li><li>接收方使用接收原语从信箱中取出属于自己的消息</li></ol></li></ol></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401202503.png" alt="image-20210401202503528"></p><h3 id="线程及多线程模型"><a href="#线程及多线程模型" class="headerlink" title="线程及多线程模型"></a>线程及多线程模型</h3><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”来增加<strong>并发度</strong>。传统的进程是程序执行流的最小单位，引入线程之后，同一个进程下可以有多个线程，<strong>线程成为了程序执行流的最小单位</strong>。</p><p><strong>线程是一个基本的CPU执行单元，是程序执行流的最小单位</strong>；引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可并发</strong>，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务(可以类比为QQ能视频、聊天、传文件)；引入线程之后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>(如打印机、内存地址空间等都是分配给进程的)</p><ul><li>线程机制引发的变化<ul><li>资源分配、调度<ul><li>传统进程机制：进程是资源分配、调度的基本单位</li><li>引入线程后：进程是资源分配的基本单位；线程是调度的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制：只能进程间并发</li><li>引入线程后：各线程间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统进程并发：需要切换进程的运行环境，系统开销大</li><li>线程并发：如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后：并发所带来的系统开销减小</li></ul></li></ul></li><li>线程的属性：<ol><li>线程是处理机调度的基本单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块(TCB)</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程间的线程间通信无需系统干预</li><li>同一进程间的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销小</li><li>切换进程，系统开销大</li></ol></li></ul><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>引入目的</td><td>能并发执行，提高资源利用率和系统吞吐量</td><td>提高并发执行的速度，进一步提高资源利用率和系统吞吐量</td></tr><tr><td>并发性</td><td>较低</td><td>较高</td></tr><tr><td>基本属性(调度)</td><td>资源分配(拥有)的基本单位；独立调度/分派的基本单位</td><td>资源分配(拥有)的基本单位——进程；独立调度/分配的基本单位——线程</td></tr><tr><td>基本状态</td><td>就绪、执行、等待</td><td>就绪、执行、等待</td></tr><tr><td>拥有资源</td><td>资源拥有的基本单位——进程</td><td>资源拥有的基本单位——进程</td></tr><tr><td>系统开销</td><td>创建/撤销/切换时空开销较大</td><td>创建/撤销/切换时空开销较小</td></tr><tr><td>系统操作</td><td>创建，撤销，切换</td><td>创建，撤销，切换</td></tr><tr><td>存在标志</td><td>进程控制块PCB</td><td>进程控制块PCB，线程控制块TCB</td></tr></tbody></table><p>进程与线程的关系：单进程单线程；单进程多线程；多进程多单线程；多进程多线程</p><ul><li>线程的实现方式<ul><li>用户级线程(User-Level Thread, ULT)——由应用程序通过线程库实现，“从用户视角可以看到的线程”<ul><li>所有的线程管理工作都由应用程序负责(包括线程切换)</li><li>用户级线程中，线程切换在用户态下即可完成，无需操作系统干预</li><li>在用户看来，有多个线程；但是操作系统内核看来，意识不到线程的存在(用户级线程对用户不透明，对操作系统透明)</li></ul></li><li>内核级线程(Kernel-Level Thread， KLT， 内核支持的线程)——从操作系统内核视角可以看到的线程<ul><li>内核级线程的管理工作由操作系统内核完成</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成</li></ul></li></ul></li><li>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n&gt;=m)<ul><li>操作系统只“看得见”内核级线程，故<strong>内核级线程才是处理机分配的单位</strong></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401205201.png" alt="image-20210401205201171"></p><ul><li>多线程模型：<ul><li>多对一模型：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程<ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可以在多核处理机上并行运行</li></ul></li><li>一对一模型：一个用户级线程对应一个内核级线程，每个用户进程都有与之线程同数量的内核级线程<ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li><li>多对多模型：n用户级线程映射到m个内核级线程(n&gt;=m)，每个用户进程对应m个内核级线程<ul><li>克服了多对一模型并发度不高的缺点</li><li>克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401210113.png" alt="image-20210401210113278"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210401210328.png" alt="image-20210401210328731"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="处理机调度的概念、层次"><a href="#处理机调度的概念、层次" class="headerlink" title="处理机调度的概念、层次"></a>处理机调度的概念、层次</h3><p>调度：当有一堆任务要处理的时候，由于资源有限，这些事情没法同时处理，这时需要确定<strong>某种规则来决定处理这些任务的顺序</strong>，这就是调度研究的问题。</p><p>处理机调度：在多道程序系统中，进程的数量往往多于处理机的个数，这样不可能同时并行地处理各个进程。处理机调度就是从就绪队列中<strong>按照一定的算法选择一个进程并将处理机分配给它运行</strong>，以实现进程的<strong>并发执行</strong>。</p><ul><li>调度的三个层次：高级调度、中级调度、低级调度</li></ul><ol><li>高级调度(作业调度)：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使其获得竞争处理机的权利。<ol><li>原因：由于内存空间有限，有时无法将用户提交的作用全部放入内存，因此需要确定某种规则来决定将作业调入内存的顺序</li><li>高级调度是<strong>辅存(外存)与内存之间</strong>的调度。每个作业只调入一次调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li><li>高级调度主要是指<strong>调入</strong>的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出</li></ol></li><li>中级调度(内存调度)：决定将哪个处于挂起状态的进程重新调入内存<ol><li>为了提高内存利用率和系统吞吐量，引入了<strong>虚拟存储技术</strong>，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存</li><li><strong>挂起状态</strong>：暂时调至外存等待的进程状态为挂机状态。<ol><li><strong>PCB并不会一起调至外存，而是会常驻内存</strong>。PCB中记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理</li><li>被挂起的进程PCB会被放到<strong>挂起队列</strong>中</li></ol></li><li>一个进程可能会被多次调出调入内存，故而中级调度发生的频率比高级调度高</li></ol></li><li>低级调度(进程调度)：安装某种方法和策略从就绪队列中选取一个进程，将处理机分配给它<ol><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须设置进程调度</li><li>进程调度的频率很高，一般几十毫秒一次</li></ol></li></ol><table><thead><tr><th></th><th>要做什么</th><th>调度发生位置</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度(作业调度)</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存-&gt;内存(面向作业)</td><td>最低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度(内存调度)</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存中</td><td>外存-&gt;内存(面向进程)</td><td>中等</td><td>挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td></tr><tr><td>低级调度(进程调度)</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td>内存-&gt;CPU</td><td>最高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402132742.png" alt="image-20210402132742382"></p><h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p>进程调度(低级调度)——按照某种算法从就绪队列中选择一个进程为其分配处理机</p><ul><li><strong>需要进行</strong>进程调度与切换的情况：有的操作系统只允许进程主动放弃处理机；有的操作系统允许有更紧急的任务需要处理时，会强行剥夺处理机(被动放弃)<ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I/O)</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I/O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能进行</strong>进程调度与切换的情况：<ol><li>在<strong>处理中断的过程中</strong>。中断过程处理复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在<strong>操作系统内核程序临界区</strong>中<ol><li>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换——√</li><li>进程处于<strong>临界区</strong>时<strong>不能</strong>进行处理机调度——×——访问普通临界资源如打印机可以进程处理机调度<ol><li>临界资源：一个时间段内只允许一个进程使用的资源，各进程<strong>互斥</strong>访问临界资源</li><li>临界区：访问临界资源的那段代码。比如打印机是一种普通的临界资源，访问打印机的临界区是可以进行调度与切换的</li><li>内核程序临界区：一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列(由各就绪进程的PCB组成)</li></ol></li></ol></li><li>在**原子操作过程中(原语)**。原子操作不可中断，要一气呵成(如修改PCB中进程状态标志，并把PCB放到相应对列)</li></ol></li></ul><p>进程调度的方式——非剥夺调度方式(非抢占方式)、剥夺调度方式(抢占方式)</p><ul><li>非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机<ul><li>在运行过程中即便有更紧迫的任务到达时，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li><li>实现简单，系统开销小但是无法及时处理紧急任务，适用于早起的批处理系统</li></ul></li><li>剥夺调度方式(抢占方式)：允许操作系统剥夺处理机(被动放弃)<ul><li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的那个进程</li><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)，适用于分时操作系统、实时操作系统</li></ul></li></ul><p><strong>广义的进程调度</strong>包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤</p><ul><li>狭义的进程调度(选择一个进程)：从就绪队列中选中一个要运行的进程。这个进程可以使刚刚被暂停执行的进程，也可能是另一个进程，后一种情况需要进程切换</li><li>进程切换：一个进程让出处理机，另一个进程占用处理机的过程<ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ol></li></ul><p>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换必然会使整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行过程的时间减少。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402141045.png" alt="image-20210402141044978"></p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><ol><li>CPU利用率：CPU“忙碌”的时间占总时间的比例<ul><li>CPU利用率=CPU忙碌的时间/总时间</li></ul></li><li>系统吞吐量：单位时间内完成作业的数量<ul><li>系统吞吐量=总共完成了多少道作业/完成作业的总时间</li></ul></li><li>周转时间：作业被提交给系统开始，到作业完成为止的这段时间间隔<ul><li>周转时间=作业完成时间-作业提交时间(用户关心单个作业周转时间)<ol><li>作业在外存后备队列上等待作业调度(高级调度)的时间——有且仅有一次</li><li>进程在就绪队列上等待进程调度(低级调度)的时间——可能发生多次</li><li>进程在CPU上执行的时间——可能发生多次</li><li>进程等待I/O操作完成的时间——可能发生多次</li></ol></li><li>平均周转时间=各作业周转时间之和/作业数(操作系统关心系统整体表现)</li><li>带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行的时间<ul><li>带权周转时间&gt;=1</li><li>带权周转时间与周转时间都是越小越好</li></ul></li><li>平均带权周转时间=各作业带权周转时间之和/作业数</li></ul></li><li>等待时间：进程/作业处于等待处理机状态时间之和<ul><li>对于<strong>进程</strong>来说，等待时间是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实是进程也是在被服务的，所以不计入等待时间</li><li>对于<strong>作业</strong>来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li><li>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间</li></ul></li><li>响应时间：从用户提交请求到首次产生响应所用的时间</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402143215.png" alt="image-20210402143215451"></p><h3 id="进程调度算法-一"><a href="#进程调度算法-一" class="headerlink" title="进程调度算法(一)"></a>进程调度算法(一)</h3><p>是否会导致<strong>饥饿</strong>：某进程/作业长时间得不到服务</p><h4 id="FCFS——先来先服务"><a href="#FCFS——先来先服务" class="headerlink" title="FCFS——先来先服务"></a>FCFS——先来先服务</h4><p>FCFS-First Come First Serve</p><blockquote><p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。</p><p>但是没有考虑到作业的运行时间，因此导致了对短作业不友好</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>主要从“公平”的角度考虑</td></tr><tr><td>算法规则</td><td>按照作业/进程到达的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占</td><td>非抢占式算法</td></tr><tr><td>优点</td><td>公平、算法实现简单</td></tr><tr><td>缺点</td><td>排在长作业(进程)后面的短作业(进程)需要等待很长时间，带权周转时间很大，对短作业用户来说用户体验不好。即<strong>FCFS算法对长作业有利，对短作业不利</strong></td></tr><tr><td>是否会导致饥饿</td><td>不会出现某进程/作业长期得不到服务的情况</td></tr></tbody></table><table><thead><tr><th>FCFS(实例)</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>11</td><td>12</td><td>16</td></tr><tr><td>周转时间(完成时间-到达时间)</td><td>7</td><td>9</td><td>8</td><td>11</td></tr><tr><td>带权周转时间(周转时间/运行时间)</td><td>7/7=1</td><td>9/4</td><td>8/1=8</td><td>11/4</td></tr><tr><td>等待时间(周转时间-运行时间)</td><td>0</td><td>5</td><td>7</td><td>7</td></tr></tbody></table><p>运行顺序：P1-&gt;P2-&gt;P3-&gt;P4</p><p>注：如果是既有计算又有I/O操作的进程，则等待时间=周转时间-运行时间-I/O操作时间</p><h4 id="SJF——短作业优先"><a href="#SJF——短作业优先" class="headerlink" title="SJF——短作业优先"></a>SJF——短作业优先</h4><p>SJF-Shortest Job First</p><blockquote><p>SJF算法是选择一个执行时间最短的作业为其服务。</p><p>因为完全不考虑各个作业的等待时间，导致了对长作业不友好，甚至会造成饥饿问题</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</td></tr><tr><td>算法规则</td><td>最短的作业/进程优先得到服务(所谓“最短”，指要求的服务时间最短)</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF，Shortest Process First)算法”</td></tr><tr><td>是否可抢占</td><td>SJF和SPF是<strong>非抢占式</strong>算法，但也有抢占式的版本——<strong>最短剩余时间优先(SRTN，Shortest Remaining Time Next)算法</strong></td></tr><tr><td>优点</td><td>“最短的”平均等待时间、平均周转时间(需要有限定条件，不然最短的是SRTN)</td></tr><tr><td>缺点</td><td>不公平；<strong>对短作业有利，对长作业不利</strong>；可能产生饥饿现象；作业/进程的运行时间由用户提供，不一定真实，不一定能真正的短作业优先</td></tr><tr><td>是否会导致饥饿</td><td>会。如果源源不断地有短作业/进程到来，可能使长作业进场长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为“饿死”</td></tr></tbody></table><table><thead><tr><th>SPF</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>周转时间(完成-到达)</td><td>7</td><td>10</td><td>4</td><td>11</td></tr><tr><td>带权周转时间(周转/运行)</td><td>7/7=1</td><td>10/4=2.5</td><td>4/1=4</td><td>11/4</td></tr><tr><td>等待时间(周转-运行)</td><td>0</td><td>6</td><td>3</td><td>7</td></tr></tbody></table><p>运行顺序：P1-&gt;P3-&gt;P2-&gt;P4</p><h4 id="SRTN-最短剩余时间算法"><a href="#SRTN-最短剩余时间算法" class="headerlink" title="SRTN-最短剩余时间算法"></a>SRTN-最短剩余时间算法</h4><ul><li>最短剩余时间算法(<strong>抢占式</strong>)：每当有进程加入就绪队列就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列；当一个进程完成时也需要调度</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402153629.png" alt="image-20210402153629614"></p><table><thead><tr><th>时刻/剩余时间</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th><th>运行</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td><td></td></tr><tr><td>完成时间</td><td>7</td><td>4</td><td>1</td><td>4</td><td></td></tr><tr><td>0</td><td>7</td><td>-</td><td>-</td><td>-</td><td>P1</td></tr><tr><td>2</td><td>5</td><td>4</td><td>-</td><td>-</td><td>P1-&gt;P2</td></tr><tr><td>4</td><td>5</td><td>2</td><td>1</td><td>-</td><td>P2-&gt;P3</td></tr><tr><td>5</td><td>5</td><td>2</td><td>-</td><td>4</td><td>P3-&gt;P2</td></tr><tr><td>7</td><td>5</td><td>-</td><td>-</td><td>4</td><td>P2-&gt;P4</td></tr><tr><td>11</td><td>5</td><td>-</td><td>-</td><td>-</td><td>P4-&gt;P5</td></tr><tr><td>16</td><td>-</td><td>-</td><td>-</td><td>-</td><td>结束</td></tr></tbody></table><table><thead><tr><th>SRTN</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>16</td><td>7</td><td>5</td><td>11</td></tr><tr><td>周转时间(完成-到达)</td><td>16</td><td>5</td><td>1</td><td>6</td></tr><tr><td>带权周转时间(周转/运行)</td><td>16/7</td><td>5/4=1.25</td><td>1/1=1</td><td>6/4=1.5</td></tr><tr><td>等待时间(周转-运行)</td><td>9</td><td>1</td><td>0</td><td>2</td></tr></tbody></table><h4 id="SJF与SRTN"><a href="#SJF与SRTN" class="headerlink" title="SJF与SRTN"></a>SJF与SRTN</h4><ol><li>如果题目未特殊说明，则“短作业/进程优先算法”<strong>默认是非抢占式</strong>的</li><li>各种限定条件下平均等待时间、平均周转时间最少的调度算法：<ol><li>在<strong>所有进程同时可运行</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</li><li>在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</li><li><strong>抢占式</strong>的短作业/进程优先调度算法(SRTN)的平均等待时间、平均周转时间最少</li></ol></li><li>虽然SJF的平均等待时间、平均周转时间并不一定最少，但相比其他算法(如FCFS算法)，SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>当选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项时，<strong>当且仅当其他选项有明显错误的情况下，才可以认为这是一个正确选项</strong></li></ol><h4 id="HRRN——高响应比优先"><a href="#HRRN——高响应比优先" class="headerlink" title="HRRN——高响应比优先"></a>HRRN——高响应比优先</h4><p>HRRN-Highest Response Ratio Next</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>综合考虑作业/进程的等待时间和要求服务的时间</td></tr><tr><td>算法规则</td><td>在每次调度时先计算各个作业/进程的响应比，选择<strong>响应比最高</strong>的作业/进程为其服务。<strong>响应比=(等待时间+要求服务时间)/要求服务时间</strong></td></tr><tr><td>用于作业/进程调度</td><td>既可以用于作业调度，又可以用于进程调度</td></tr><tr><td>是否可抢占</td><td><strong>非抢占式</strong>算法，只有当前运行的作业/进程主动放弃处理机时(正常、异常完成或主动阻塞)，才需要调度，才需要计算响应比(计算所有就绪进程的响应比，选最高的进程)</td></tr><tr><td>优点</td><td>综合考虑了等待时间和运行时间(要求服务时间)；等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)</td></tr><tr><td>缺点</td><td></td></tr><tr><td>是否会导致饥饿</td><td>不会导致饥饿——不会出现某进程/作业长期得不到服务的情况。对于长作业来说，随着等待时间越来越久，其响应比会越来越大，从而避免了长作业饥饿的问题</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402161226.png" alt="image-20210402161226172"></p><table><thead><tr><th>HRRN</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>完成时间</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>周转时间(完成-到达)</td><td>7</td><td>10</td><td>4</td><td>11</td></tr><tr><td>带权周转时间(周转/运行)</td><td>7/7=1</td><td>10/4=2.5</td><td>4/1=4</td><td>11/4</td></tr><tr><td>等待时间(周转-运行)</td><td>0</td><td>6</td><td>3</td><td>7</td></tr></tbody></table><h4 id="FCFS、SJF-SPF、HRRN算法总结"><a href="#FCFS、SJF-SPF、HRRN算法总结" class="headerlink" title="FCFS、SJF/SPF、HRRN算法总结"></a>FCFS、SJF/SPF、HRRN算法总结</h4><p>FCFS、SJF/SPF、HRRN这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，不区分任务的紧急程度，因此对于用户来说，交互性槽糕。因此这三种算法一般适用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他算法使用，在现在也扮演着很重要的角色。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402161940.png" alt="image-20210402161940048"></p><h3 id="进程调度算法-二"><a href="#进程调度算法-二" class="headerlink" title="进程调度算法(二)"></a>进程调度算法(二)</h3><h4 id="时间片轮转调度算法-RR"><a href="#时间片轮转调度算法-RR" class="headerlink" title="时间片轮转调度算法(RR)"></a>时间片轮转调度算法(RR)</h4><p>RR-Round-Robin</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td></tr><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</td></tr><tr><td>是否可抢占</td><td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</td></tr><tr><td>优点</td><td>公平；响应快，适用于分时操作系统</td></tr><tr><td>缺点</td><td>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</td></tr><tr><td>是否会导致饥饿</td><td>不会出现某进程/作业长期得不到服务的情况</td></tr><tr><td>时间片太大时</td><td>每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为FCFS(先来先服务)调度算法，并且会增大进程响应时间；因此<strong>时间片不能太大</strong></td></tr><tr><td>时间片太小时</td><td>导致进程调度、切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少；因此<strong>时间片不能太小</strong>，一般来说，设计时间片时要让切换进程的开销不超过1%</td></tr></tbody></table><p>时间片轮转调度算法(RR)一般用于分时操作系统，更关注“响应时间”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402171543.png" alt="image-20210402171543640"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402171931.png" alt="image-20210402171931125"></p><table><thead><tr><th></th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>5</td><td>4</td><td>1</td><td>6</td></tr><tr><td>完成时间(RR时间片大小为2)</td><td>12</td><td>9</td><td>7</td><td>16</td></tr><tr><td>完成时间(RR时间片大小为5)</td><td>5</td><td>9</td><td>10</td><td>16</td></tr><tr><td>完成时间(FCFS)</td><td>5</td><td>9</td><td>10</td><td>16</td></tr></tbody></table><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>随着计算机的发展，特别是实时操作系统的实现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td></tr><tr><td>算法规则</td><td>每个作业/进程有格子的优先级，调度时选择优先级最高的作业/进程</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可以用于进程调度。设置还可以用于I/O调度中</td></tr><tr><td>是否可抢占</td><td>抢占式、非抢占式都有。做题时区别：非抢占式只需在进程主动放弃处理机时进行调度即可，抢占式还需要在就绪队列变化时检查是否会发生抢占</td></tr><tr><td>优点</td><td>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</td></tr><tr><td>缺点</td><td>若源源不断地有高优先级进程到来，则可能导致饥饿</td></tr><tr><td>是否会导致饥饿</td><td>会导致饥饿——会出现某进程/作业长期得不到服务的情况。</td></tr></tbody></table><ul><li>以下示例中规定：优先数越大，优先级越高(具体优先级确定方法视题目要求而定)</li></ul><table><thead><tr><th>优先级调度算法</th><th>P1</th><th>P2</th><th>P3</th><th>P4</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>2</td><td>4</td><td>5</td></tr><tr><td>运行时间</td><td>7</td><td>4</td><td>1</td><td>4</td></tr><tr><td>优先数</td><td>1</td><td>2</td><td>3</td><td>2</td></tr><tr><td>完成时间(非抢占式)</td><td>7</td><td>12</td><td>8</td><td>16</td></tr><tr><td>完成时间(抢占式)</td><td>16</td><td>7</td><td>5</td><td>11</td></tr></tbody></table><ul><li>上述非抢占式优先级算法示例中的执行顺序：P1-&gt;P3-&gt;P2-&gt;P4</li><li>上述抢占式优先级算法示例执行过程见下图</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402175305.png" alt="image-20210402175305500"></p><p>PS：就绪队列未必只有一个，可以按照不同优先级来组织，另外，也可以把优先级高的进程排在更靠近队头的位置。</p><ul><li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种<ul><li>静态优先级——创建进程时确定，之后一直不变；进程优先级(通常情况下)：<ul><li>系统进程优先级高于用户进程</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好I/O型进程(或称I/O繁忙型进程)<ul><li>与<strong>I/O繁忙型进程</strong>相对的是<strong>计算型进程</strong>(或称CPU繁忙型进程)</li><li>I/O设备和CPU可以<strong>并行</strong>工作。如果优先让I/O繁忙型进程优先运行的话，越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li></ul></li></ul></li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul></li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><blockquote><p>FCFS算法——公平<br>SJF算法——能尽快处理完短作业，平均等待/周转时间等参数很优秀<br>RR算法——可以让各个进程得到及时的响应<br>优先级调度算法——可以灵活地调整各种进程被服务的机会</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>算法思想</td><td>对其他调度算法的折中权衡</td></tr><tr><td>算法规则</td><td>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。2.新进程到达时先进入到第1级队列，按FCFS原则排序等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾；如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占</td><td><strong>抢占式</strong>算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，<strong>新进程会抢占处理机，原来运行的进程放回k级队列队尾</strong></td></tr><tr><td>优点</td><td>对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点);短进程只用较少的时间就可完成(FPF的优点);不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、I/O密集型进程(PS：可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</td></tr><tr><td>缺点</td><td></td></tr><tr><td>是否会导致饥饿</td><td>会出现某进程/作业长期得不到服务的情况——如果有源源不断的短进程(比如可以在第一级队列中被处理完的短进程)到达，那么在低级就绪队列的长进程就会长期得不到服务</td></tr></tbody></table><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402201559.png" alt="image-20210402201559273"></p><table><thead><tr><th></th><th>P1</th><th>P2</th><th>P3</th></tr></thead><tbody><tr><td>到达时间</td><td>0</td><td>1</td><td>5</td></tr><tr><td>运行时间</td><td>8</td><td>4</td><td>1</td></tr><tr><td>完成时间</td><td>13</td><td>8</td><td>6</td></tr></tbody></table><h4 id="进程调度算法-二-总结"><a href="#进程调度算法-二-总结" class="headerlink" title="进程调度算法(二)总结"></a>进程调度算法(二)总结</h4><p>比起早期的批处理操作系统，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时交互系统)更注重系统的<strong>响应时间、公平性、平衡性等指标</strong>。这几种算法恰好也能较好地满足交互式系统的需求，故而这三种算法适用于<strong>交互式系统</strong>(UNIX系统使用的就是多级反馈队列调度算法)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210402202547.png" alt="image-20210402202547892"></p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><p>进程的异步性：各并发执行的进程以各自独立的、不可预知的速度向前推进。比如管道通信，读进程与写进程并发地运行，由于并发必然导致异步，因此“写数据”与“读数据”这两个操作执行的先后顺序是不确定的，而实际应用中又要求按照“写数据-&gt;读数据”的顺序执行，<strong>进程同步</strong>所讨论的内容就是解决这种异步问题</p><ul><li>同步亦称直接制约关系<strong>，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上</strong>协调它们的工作次序而产生的制约关系**，进程间的直接制约关系就是源于它们之间的相互合作</li></ul><p>对于<strong>临界资源</strong>(一个时间段内只允许一个进程使用的资源)的访问必须<strong>互斥</strong>地进行。(许多物理设备，比如摄像头、打印机，都属于临界资源；除此之外还有许多的变量、数据、内存缓冲区等也都属于临界资源)</p><ul><li><p>互斥亦称间接制约关系<strong>，是指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须</strong>等待**；当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p></li><li><p>对于临界资源的互斥访问在逻辑上可以分为四个部分：</p><ol><li>进入区(entry section)：负责检查是否可进入临界区，若可进入，则应**设置正在访问临界资源的标志(可理解为“上锁”)**，以阻止其他进程同时进入临界区<ul><li>与退出区组成<strong>负责实现互斥的代码段</strong></li></ul></li><li>临界区(critical section，又称为“临界段”)：访问临界资源的那段代码</li><li>退出区(exit section)：负责<strong>解除正在访问临界资源的标志(可理解为“解锁”)</strong><ul><li>与进入区组成<strong>负责实现互斥的代码段</strong></li></ul></li><li>剩余区(remainder section)：做其他处理</li></ol></li><li><p>进程互斥需要遵循的原则：</p><ol><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403102038.png" alt="image-20210403102038161"></p><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想：两个进程在<strong>访问完临界区之后</strong>会把使用临界区的权限转交给另一个进程，即<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p><p>单标志法可以实现<strong>同一时刻最多只允许一个进程访问临界区</strong>，且一般情况下要求<strong>轮流顺序访问</strong>；如下图示例，P0和P1互斥，同一时间他们之中只有一个进程可以访问临界区，而且是按照P0-&gt;P1-&gt;P0-&gt;P1……的轮流顺序来访问的(P0结束后turn=1，P1结束之后turn=0)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403102704.png" alt="image-20210403102704430"></p><p>单标志法存在的问题：<strong>违背空闲让进原则</strong>。如上图示例，因为是<strong>轮流访问</strong>，所以初始允许进入临界区的进程是P0，倘若P0一直不访问临界区，那么<strong>虽然此时临界区空闲，但是并不允许P1进入临界区</strong>。</p><h4 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h4><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如”flag[0]=true”表示0号进程P0想要进入临界区；flag[]初始化的时候每个位置都设置为false；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应标志flag[i]设置为true，之后再开始访问临界区。</p><p>双标志先检查法存在的问题：<strong>违背忙则等待原则</strong>，原因在于<strong>进入区的检查和上锁这两个处理不是一气呵成的(不是原子操作)<strong>，在</strong>检查之后上锁之前可能发生进程切换</strong>。由于进程是并发执行的，进程异步推进，当按照某种顺序执行的时候，各个进程是有可能同时访问临界区，例如下图示例中，如果按照<strong>①⑤②⑥③⑦……</strong>这样的顺序执行，P0和P1会同时访问临界区</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403104139.png" alt="image-20210403104139666"></p><h4 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h4><p>算法思想：双标志先检查法的改版，由<strong>先检查后上锁</strong>改为了<strong>先上锁后检查</strong>的方法来避免出现两个进程同时进入临界区的问题。</p><p>双标志后检查法存在的问题：<strong>违背空闲让进、有限等待原则</strong>，会因各进程都长期无法访问临界资源而产生饥饿现象；原因在于<strong>进入区的上锁和检查这两个处理不是一气呵成的(不是原子操作)<strong>，在</strong>上锁之后检查之前可能发生进程切换</strong>。由于进程是并发执行的，进程异步推进，当按照某种顺序执行的时候，各个进程是有可能都不可以访问临界区，例如下图示例中，如果按照<strong>①⑤②⑥……</strong>这样的顺序执行，P0和P1将都不能访问临界区</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403104556.png" alt="image-20210403104556404"></p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><blockquote><p>上诉三种算法出现问题的地方往往是<strong>两个或多个进程并发执行的时候</strong>，并发执行的异步性容易导致问题的出现，比如<strong>标志位的设置与检查不是原子操作</strong>就会导致问题。</p></blockquote><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但谁也不让谁，最后谁都无法进入临界区，Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，<strong>主动让对方先使用临界区。</strong></p><p>进入区：1.主动争取。2.主动谦让。3.检查对方是否也想使用，且最后一次是不是自己说了“客气话”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403110310.png" alt="image-20210403110310835"></p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然<strong>未遵循让权等待</strong>的原则。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403110532.png" alt="image-20210403110531969"></p><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>算法思想：利用<strong>开/关中断指令</strong>实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p><ul><li>优点：简单、高效</li><li>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(开/关中断指令只能运行于内核态)</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403111014.png" alt="image-20210403111014606"></p><h4 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet(TS指令/TSL指令)"></a>TestAndSet(TS指令/TSL指令)</h4><p>TestAndSet指令简称为TS指令，也有地方称为TestAndSetLock指令，简称为TSL指令。<strong>TSL指令使用硬件实现，执行的过程不允许被中断</strong>，只能一气呵成。</p><p>算法思想：使用布尔型共享变量lock来描述临界区是否被加锁，TSL指令会加锁lock并返回lock指令原本的值(存在old中)，当且仅当返回值为false时，当前进程才可以使用临界区，否则只能一直执行TSL指令等待其他进程解锁lock(解锁临界区)</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：<strong>不满足让权等待原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403111648.png" alt="image-20210403111648624"></p><h4 id="Swap-XCHG指令"><a href="#Swap-XCHG指令" class="headerlink" title="Swap(XCHG指令)"></a>Swap(XCHG指令)</h4><p>Swap指令有时叫Exchange指令，或简称XCHG指令；<strong>Swap指令使用硬件实现，执行过程不允许被中断</strong>，只能一气呵成。</p><p>算法思想：逻辑上看Swap思想与TSL并无太大区别(在硬件层面的具体实现上有区别)，都是先记录当前临界区是否被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：<strong>不满足让权等待原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403112214.png" alt="image-20210403112214670"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403112609.png" alt="image-20210403112609307"></p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>进程互斥的软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法</p><p>进程互斥的硬件实现方式：中断屏蔽算法、TS/TSL指令、Swap/SCHG指令</p><ol><li>在双标志先检查法中，<strong>进入区的检查与上锁操作不能一气呵成</strong>，从而导致了两个进程有可能同时进入临界区</li><li>所有的解决方案都<strong>无法实现让权等待</strong></li></ol><p>用户进程可以通过使用操作系统提供的一对原语来对<strong>信号量</strong>进行操作，从而方便的实现了进程互斥、进程同步。其中，<strong>信号量其实是一个变量</strong>(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如系统中只有一台打印机，可以设置一个初始值为1的信号量来表示打印机资源的可使用情况(1表示有一台可用，0表示此资源已被其他进程占用)</p><p><strong>一对原语</strong>：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数；wait、signal原语通常简称为P、V操作(来自荷兰语proberen和verhogen)，因此wait(S)可简写为P(S)，signal(S)可以简写为V(S)</p><blockquote><p><strong>信号量机制</strong>可以实现互斥、同步、对一类系统资源的申请和释放</p><ol><li>互斥：设置初值为1的互斥信号量</li><li>同步：设置初值为0的同步信号量(实现一前一后)</li><li>对一类系统资源的申请和释放：设置一个信号量，初始值即为系统资源的数量(本质上也是同步问题，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续向下执行)</li></ol></blockquote><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量：用一个整数型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong>；与普通整数变量的区别——对信号量的操作只有三种，即<strong>初始化、P操作、V操作</strong></p><p>比如系统中只有一台打印机，可以使用整型信号量来表示打印机资源的数量：初始化S=1；wait(S)操作相当于“进入区”，先检查S资源数量，若<strong>资源数量不够则循环等待</strong>，若资源数量够则占用一个资源S-=1；signal(S)操作相当于“退出区”，释放一个资源S+=1。</p><p>整型信号量存在的问题：<strong>不满足让权等待原则</strong></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403123348.png" alt="image-20210403123348310"></p><p>PS：有一点逻辑问题——上面的wait(S)中，因为这是一个原语，所以while循环等待的时候处于原子操作中，无法被中断，也就无法切换进程，但实际情况上并非如此，此处仅是展示算法思想才这么写</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>记录型信号量：使用记录型数据结构表示信号量，以解决整型信号量存在的“忙等”问题；</p><ol><li>记录型数据结构除了记录剩余资源数量以外，还会记录<strong>等待队列</strong>；</li><li>wait(S)操作中，先假设此进程会占用一个系统资源(S.value–)，若没有可用资源(S.value&lt;0)，会<strong>将当前进程放入等待队列中(block操作)<strong>，让出处理机，实现了</strong>忙则等待</strong>；</li><li>signal(S)操作中，除了释放占用的资源外(S.value++)，还会判断等待队列中有没有处于等待状态的进程(S.value&lt;=0)，如果有的话，**取出并恢复队头进程(wakeup操作)**。</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403125102.png" alt="image-20210403125102299"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403125309.png" alt="image-20210403125309641"></p><p>PS：题目中遇到的信号量不做特殊说明的情况下，默认是<strong>记录型信号量</strong></p><h3 id="信号量机制实现进程互斥、同步、前驱关系"><a href="#信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="信号量机制实现进程互斥、同步、前驱关系"></a>信号量机制实现进程互斥、同步、前驱关系</h3><h4 id="进程互斥-信号量机制"><a href="#进程互斥-信号量机制" class="headerlink" title="进程互斥(信号量机制)"></a>进程互斥(信号量机制)</h4><ol><li>分析并发进程的关键活动，划定临界区(如对临界资源打印机的访问就应放在临界区中)</li><li>设置互斥信号量mutex(一般设置为这个名字)，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p>PS：对于不同的临界资源需要设置不同的互斥信号量；P、V操作必须成对出现，缺少P操作就不能保证临界资源的互斥访问，缺少V操作就会导致资源永不被释放，等待进程永不被唤醒</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403131159.png" alt="image-20210403131159580"></p><h4 id="进程同步-信号量机制"><a href="#进程同步-信号量机制" class="headerlink" title="进程同步(信号量机制)"></a>进程同步(信号量机制)</h4><p>进程同步：各并发执行的进程按要求有序地推进</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>假设如图所示的两个进程，P2进程的代码4必须在P1进程的代码2之后执行：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403131633.png" alt="image-20210403131633850"></p><h4 id="进程前驱关系-信号量机制"><a href="#进程前驱关系-信号量机制" class="headerlink" title="进程前驱关系(信号量机制)"></a>进程前驱关系(信号量机制)</h4><p>其实<strong>每一对前驱关系</strong>都是<strong>一个进程同步问题</strong>，即需要保证一前一后的操作</p><ol><li>为每一对前驱关系设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行V操作</li><li>在“后操作”之前对相应的同步变量执行P操作</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403132206.png" alt="image-20210403132206665"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403132305.png" alt="image-20210403132305485"></p><h3 id="经典进程互斥同步问题"><a href="#经典进程互斥同步问题" class="headerlink" title="经典进程互斥同步问题"></a>经典进程互斥同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用(这里的产品可理解为某种数据)</p><ol><li>生产者消费者共享一个初始为空，大小为n的缓冲区；<ol><li>空闲缓冲区初始值数量为n</li><li>非空闲缓冲区(产品)的数量为0</li></ol></li><li>只有<strong>缓冲区没满</strong>时，生产者才能把产品放入缓冲区中，否则必须等待<ol><li>同步关系。缓冲区满时，生产者要等待消费者取走产品</li></ol></li><li>只有<strong>缓冲区不空</strong>时，消费者才能从中取出产品，否则必须等待<ol><li>同步关系。缓冲区空时，消费者要等待生产者放入产品</li></ol></li><li>缓冲区是指临界资源，各进程必须<strong>互斥</strong>地访问<ol><li>倘若缓冲区不互斥，那么可能出现两个生产者进程同时向缓冲区放数据的情况，有可能导致缓冲区内数据顺序错乱，或者一个进程放的时候已经将缓冲区放满了，另一个进程强行放的时候将数据覆盖</li></ol></li></ol><ul><li>生产者消费者问题-PV操作题目分析步骤：<ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序<ol><li>生产者每次消耗(P)一个空闲缓冲区，并生产(V)一个产品</li><li>消费者每次消耗(P)一个产品，并释放(V)一个空闲缓冲区</li><li>往缓冲区放入/取走产品需要互斥</li></ol></li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值；互斥信号量初值一般设置为1，同步信号量的初始值要看对应的系统资源的初始值是多少</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty&#x3D;n;  &#x2F;&#x2F; 同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full&#x3D;0;   &#x2F;&#x2F; 同步信号量，表示非空闲缓冲区(产品)的数量</span><br><span class="line">producer()&#123;  &#x2F;&#x2F; 生产者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);        &#x2F;&#x2F; 把产品放入空闲缓冲区</span><br><span class="line">        P(mutex);        &#x2F;&#x2F; 占用缓冲区(互斥操作)</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);        &#x2F;&#x2F; 取消占用缓冲区(互斥操作)</span><br><span class="line">        V(full);         &#x2F;&#x2F; 增加一个产品(非空闲缓冲区)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123; &#x2F;&#x2F; 消费者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);         &#x2F;&#x2F; 消耗一个产品(非空闲缓冲区)</span><br><span class="line">        P(mutex);        &#x2F;&#x2F; 占用缓冲区(互斥操作)</span><br><span class="line">        从缓冲区中去除一件产品;</span><br><span class="line">        V(mutex);        &#x2F;&#x2F; 取消占用缓冲区(互斥操作)</span><br><span class="line">        V(empty);        &#x2F;&#x2F; 增加一个空闲缓冲区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥是<strong>同一进程</strong>中进程一对PV操作</li><li>实现同步是在其中一个进程中执行P，在另一个进程中执行V</li></ul><blockquote><ol><li>实现互斥的P操作一定要在实现同步的P操作之后</li><li>V操作不会使进程进入阻塞状态，因此两个V操作顺序可以变换</li></ol></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403135609.png" alt="两组同步关系及PV顺序"></p><h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放苹果，妈妈专门向盘子中放橘子，儿子专门等着吃盘子中的橘子，女儿专门等着吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；当且仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出水果。</p><ul><li>多生产者-多消费者问题，PV操作题目分析步骤：<ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系<ol><li>互斥关系：对缓冲区(盘子)的访问要互斥地进行</li><li>同步关系：<ol><li>爸爸将苹果放入盘子后，女儿才能取苹果</li><li>妈妈将句子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果(盘子为空这个事件由儿子或女儿取出水果后触发)</li></ol></li></ol></li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值；互斥信号量初值一般设置为1，同步信号量的初始值要看对应的系统资源的初始值是多少<ol><li>互斥关系：对缓冲区(盘子)的访问设置一个信号量mutex=1</li><li>同步关系：<ol><li>爸爸和女儿之间由苹果联系，设置apple=0</li><li>妈妈和儿子之间由橘子联系，设置orange=0</li><li>爸爸和妈妈放水果需要看盘子，设置plate=1</li></ol></li></ol></li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403141212.png" alt="image-20210403141212426"></p><p>PS：对于本题来说，由于<strong>缓冲区的大小为1</strong>，所以在任何时刻，apple、orange、plate三个同步信号量最多只有一个是1，所以在任何时刻最多只有一个进程的P操作不会被阻塞，能顺利进入临界区，也就是<strong>对于本题来说</strong>，即便不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象；但倘若<strong>缓冲区的大小设置为2及以上</strong>的话，就可能出现两个进程(如爸爸进程和妈妈进程)同时访问缓冲区的情况，有可能导致两个进程的写入缓冲区的数据相互覆盖的情况。</p><blockquote><ol><li>如果<strong>缓冲区的大小大于1</strong>，就<strong>必须设置</strong>一个专门的<strong>互斥信号量mutex</strong>来保证互斥访问缓冲区</li><li>如果<strong>缓冲区的大小为1</strong>，那么<strong>有可能不需要设置</strong>一个专门的<strong>互斥信号量mutex</strong>来保证互斥访问缓冲区(可不可以不设置互斥信号量需要具体问题具体分析)</li></ol></blockquote><p>在分析同步问题(一前一后问题)的时候，不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系，即正确的分析方法是<strong>从“事件”的角度</strong>来考虑，可以把“进程行为的前后关系”抽象为“事件的前后关系”。</p><p>比如可以从上面示例中找出与盘子(缓冲区)有关的<strong>四种前后关系(还有其他前后关系)</strong>(1)女儿取走盘子中的苹果-&gt;爸爸向盘子中放苹果、(2)女儿取走盘子中的苹果-&gt;妈妈向盘子中放橘子、(3)儿子取走盘子中的橘子-&gt;妈妈向盘子中放橘子、(4)儿子取走盘子中的橘子-&gt;爸爸向盘子中放苹果；<br>可以将<strong>“前”和“后”</strong>抽象为<strong>两种事件</strong>，即<strong>盘子为空事件</strong>和<strong>放入水果事件</strong>，其中盘子为空事件由女儿或者儿子取走水果引发，放入水果事件由爸爸或者妈妈放入水果引发；<br><strong>上述的四种前后关系可以抽象为一种前后关系——盘子为空事件-&gt;放入水果事件</strong>，这样就可以用一个同步信号量plate来表示盘子是否为空了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210403144030.png" alt="image-20210403144029959"></p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>问题描述：设计一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽调一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一支烟并抽掉他，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(<strong>让三个抽烟者轮流地抽烟</strong>)</p><p>问题分析：可以将桌子抽象为容量为1的缓冲区，要互斥访问；由三个抽烟者所需物品可提供三种组合方式，组合一为纸和胶水，组合二为烟草和胶水，组合三为烟草和纸；桌子上有组合一-&gt;第一个抽烟者拿走东西，桌子上有组合二-&gt;第二个抽烟者拿走东西，桌子上有组合三-&gt;第三个抽烟者拿走东西，桌子上没有东西(抽烟者拿走东西，发出信号)-&gt;供应者往桌子上放下一个组合</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404100159.png" alt="image-20210404100159828"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore offer1&#x3D;0; &#x2F;&#x2F; 桌子上组合一的数量</span><br><span class="line">semaphore offer2&#x3D;0; &#x2F;&#x2F; 桌子上组合二的数量</span><br><span class="line">semaphore offer3&#x3D;0; &#x2F;&#x2F; 桌子上组合三的数量</span><br><span class="line">semaphore finish&#x3D;0; &#x2F;&#x2F; 抽烟是否完成</span><br><span class="line">int i&#x3D;0;            &#x2F;&#x2F; 用于实现“三个抽烟者轮流抽烟”</span><br><span class="line">&#x2F;&#x2F; 缓冲区容量为1，可以不设置互斥信号量</span><br><span class="line">provider() &#123;  &#x2F;&#x2F; 供应者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            将组合一放到桌子上;</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;</span><br><span class="line">            将组合二放到桌子上;</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;</span><br><span class="line">            将组合三放到桌子上;</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i&#x3D;(i+1)%3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1() &#123;   &#x2F;&#x2F; 抽烟者一进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        从桌子上拿走组合一；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2() &#123;   &#x2F;&#x2F; 抽烟者二进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌子上拿走组合二；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3() &#123;   &#x2F;&#x2F; 抽烟者三进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌子上拿走组合三；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置信号量数组——不确定这种是否可行，仅是看完哲学家进餐问题的解放方案之后的个人想法</span><br><span class="line">semaphore offer[3]&#x3D;&#123;0,0,0&#125;; &#x2F;&#x2F; 桌子上三种组合各自的数量</span><br><span class="line">semaphore finish&#x3D;0;         &#x2F;&#x2F; 抽烟是否完成</span><br><span class="line">int i&#x3D;0;                    &#x2F;&#x2F; 用于实现“三个抽烟者轮流抽烟”</span><br><span class="line">&#x2F;&#x2F; 缓冲区容量为1，可以不设置互斥信号量</span><br><span class="line">provider() &#123;  &#x2F;&#x2F; 供应者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            将组合一放到桌子上;</span><br><span class="line">            V(offer[0]);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;</span><br><span class="line">            将组合二放到桌子上;</span><br><span class="line">            V(offer[1]);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;</span><br><span class="line">            将组合三放到桌子上;</span><br><span class="line">            V(offer[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        i&#x3D;(i+1)%3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smokeri() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(i&#x3D;&#x3D;0)&#123;         &#x2F;&#x2F; 吸烟者一</span><br><span class="line">            P(offer[0]);</span><br><span class="line">            从桌子上拿走组合一；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;1)&#123;  &#x2F;&#x2F; 吸烟者二</span><br><span class="line">            P(offer[1]);</span><br><span class="line">            从桌子上拿走组合二；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125; else if(i&#x3D;&#x3D;2)&#123;  &#x2F;&#x2F; 吸烟者三</span><br><span class="line">            P(offer[2]);</span><br><span class="line">            从桌子上拿走组合三；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>吸烟者问题可以解决<strong>“可以生产多个产品的单生产者”</strong>问题：<br><strong>轮流</strong>让各个吸烟者吸烟必须<strong>轮流</strong>地在桌子上放上组合一、二、三，这里可以用<strong>一个整型变量i递增取模</strong>的方式实现这个<strong>轮流</strong>的过程；<br>如果改为<strong>随机</strong>让一个吸烟者吸烟的话，可以采用random的方式来决定每次是谁吸烟。</p></blockquote><p>若一个生产者要生产多种产品(或者说会引发多种前驱事件)，那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程(与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据)同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程和写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出</p><p>两类进程——写进程、读进程；互斥关系——写进程-写进程、写进程-读进程</p><p>写进程和任何进程都互斥，可设置一个<strong>互斥信号量rw</strong>，通过P(rw)和V(rw)操作来对共享文件进程“上锁”和“解锁”，既然各个读进程都需要同时访问，而读进程与写进程之间又必须互斥访问，那么可以<strong>让第一个访问文件的读进程“加锁”</strong>，<strong>让最后一个访问文件的读进程“解锁”</strong>，可以设置一个count来记录当前有几个读进程在访问文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore rw&#x3D;1;     &#x2F;&#x2F; 当前是否有进程在访问共享文件，实现互斥</span><br><span class="line">int count&#x3D;0;        &#x2F;&#x2F; 记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 用于保证对count变量的互斥访问</span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(rw);  &#x2F;&#x2F; 写之前“加锁”</span><br><span class="line">        写文件……</span><br><span class="line">        V(rw);  &#x2F;&#x2F; 写之后“解锁”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            P(rw);   &#x2F;&#x2F; 第一个读进程负责“加锁”</span><br><span class="line">        count++;     &#x2F;&#x2F; 访问文件的读进程数+1</span><br><span class="line">        V(mutex);</span><br><span class="line">        读文件……</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        count--;     &#x2F;&#x2F; 访问文件的读进程数-1</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            V(rw);   &#x2F;&#x2F; 最后一个读进程负责“解锁”</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这种方法存在的问题：只要有读进程在读，写进程就会被阻塞，可能“饿死”，违背了有限等待，这种算法中读进程优先，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了解决上述的“写进程可能会饿死”的情况，新增加一个互斥信号量w</span><br><span class="line">semaphore rw&#x3D;1;     &#x2F;&#x2F; 当前是否有进程在访问共享文件，实现互斥</span><br><span class="line">int count&#x3D;0;        &#x2F;&#x2F; 记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 用于保证对count变量的互斥访问</span><br><span class="line">semaphore w&#x3D;1;      &#x2F;&#x2F; 实现“写优先”(先来先服务，并不是真正的写优先</span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);  &#x2F;&#x2F; 写之前“加锁”</span><br><span class="line">        写文件……</span><br><span class="line">        V(rw);  &#x2F;&#x2F; 写之后“解锁”</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            P(rw);   &#x2F;&#x2F; 第一个读进程负责“加锁”</span><br><span class="line">        count++;     &#x2F;&#x2F; 访问文件的读进程数+1</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件……</span><br><span class="line">        P(mutex);    &#x2F;&#x2F; 读进程互斥访问count</span><br><span class="line">        count--;     &#x2F;&#x2F; 访问文件的读进程数-1</span><br><span class="line">        if(count&#x3D;&#x3D;0)</span><br><span class="line">            V(rw);   &#x2F;&#x2F; 最后一个读进程负责“解锁”</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也不是真正的写优先，而是相对公平的先来先服务原则</span><br><span class="line">&#x2F;&#x2F; 即写进程会将w上锁，使后面的连续不断的读进程暂时进入等待队列，写进程结束之后才会解锁，按照到达的顺序执行后续的进程，保证了先来的写进程不会被后来的读进程淹没</span><br></pre></td></tr></table></figure><blockquote><p>读者-写者问题为解决<strong>复杂的互斥问题</strong>提供了思路：<br>核心思想在于设置<strong>一个计数器count</strong>用来记录当前正在访问共享文件的读进程数，可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出同一进程的不同处理；<br>由于<strong>对count的检查和赋值不能一气呵成，故需要互斥信号量</strong>，从而避免多个读进程同时成为第一个读进程的情况；对于写进程饥饿的情况，可以设置一个互斥信号了来保证<strong>先来先服务</strong>的原则。</p></blockquote><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：一个圆桌上坐着5位哲学家，每两个哲学家之间的桌子上摆一根筷子，桌子中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人，只有当哲学家饥饿时，才试图拿起左、右两根筷子(<strong>一根一根拿起</strong>)，如果筷子已经在他人手上，则需要等待，饥饿的哲学家<strong>只有同时拿起两根筷子才可以开始进餐</strong>，当进餐完毕之后，放下筷子继续思考。</p><p>系统中有五个哲学家进程，5位哲学家与左右邻居对其中间的筷子的访问是互斥关系；每个哲学家进程需要同时持有<strong>两个临界资源</strong>才能开始吃饭，如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓；定义<strong>互斥信号量数组chopstick[5]={1,1,1,1,1}<strong>来实现5个筷子的互斥访问，并对哲学家进行编号</strong>0~4</strong>，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404111614.png" alt="image-20210404111614235"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照题目描述，似乎可以直接写出下述算法，但这种算法存在死锁的情况</span><br><span class="line">&#x2F;&#x2F; 当5个哲学家并发地拿起了左手边的筷子时，会进入死锁状态——所有哲学家都拥有自己左手边的筷子，所有哲学家右手边的筷子都被别人拿走了，没有任何一个哲学家拥有两根筷子，也就没有任何一个哲学家会释放资源，都无法吃放都无法思考，所有哲学家都循环等待右边的哲学放下筷子(哲学家进程进入阻塞状态)，系统进入死锁状态</span><br><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最多允许4名哲学家同时进餐"><a href="#最多允许4名哲学家同时进餐" class="headerlink" title="最多允许4名哲学家同时进餐"></a>最多允许4名哲学家同时进餐</h5><p>最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore max&#x3D;4;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        wait(max);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        signal(max);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="奇数号哲学家先左后右，偶数号哲学家先右后左"><a href="#奇数号哲学家先左后右，偶数号哲学家先右后左" class="headerlink" title="奇数号哲学家先左后右，偶数号哲学家先右后左"></a>奇数号哲学家先左后右，偶数号哲学家先右后左</h5><p>要求奇数号哲学家先拿左手边的筷子，再拿右手边的筷子，偶数号哲学家先拿右手边的筷子，再拿左手边的筷子；可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞，避免了占有一只筷子后等待另一只的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if (i%2&#x3D;&#x3D;1) &#123;</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AND信号量机制，同时拿两只筷子"><a href="#AND信号量机制，同时拿两只筷子" class="headerlink" title="AND信号量机制，同时拿两只筷子"></a>AND信号量机制，同时拿两只筷子</h5><p>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子，使用AND信号量机制(Swait和Ssignal)可以避免多个资源共享导致的死锁，即多个资源<strong>同时“上锁”</strong>或<strong>同时“解锁”</strong>，不会出现申请完一个资源之后因为另一个资源无法使用而进入阻塞状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        Swait(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">        吃饭……</span><br><span class="line">        Ssignal(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哲学家互斥地拿筷子"><a href="#哲学家互斥地拿筷子" class="headerlink" title="哲学家互斥地拿筷子"></a>哲学家互斥地拿筷子</h5><p>各哲学家拿筷子这件事必须互斥的执行，保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子；当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore mutex&#x3D;1;  &#x2F;&#x2F; 互斥地拿筷子</span><br><span class="line">Pi()&#123;               &#x2F;&#x2F; i号哲学家进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0-3号哲学家先左后右，4号哲学家先右后左"><a href="#0-3号哲学家先左后右，4号哲学家先右后左" class="headerlink" title="0~3号哲学家先左后右，4号哲学家先右后左"></a>0~3号哲学家先左后右，4号哲学家先右后左</h5><p>要求0~3号哲学家先拿左手边的筷子，再拿右手边的筷子，4号哲学家先拿右手边的筷子，再拿左手边的筷子；可以保证如果3号和4号哲学家或者4号和0号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞，避免了占有一只筷子后等待另一只的情况；即可以保证最起码五个哲学家中有一个能拿到两只筷子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]&#x3D;&#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if (i&#x3D;&#x3D;4) &#123;</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            P(chopstick[(i+1)%5]);</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭……</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哲学家进餐问题的关键在于<strong>解决进程死锁</strong>，这些进程之间仅存在互斥关系，而且每个进程都需要<strong>同时持有两个临界资源</strong>，因此存在<strong>死锁</strong>的隐患；当遇到需要<strong>同时持有多个临界资源</strong>的情况，可以参考哲学家进餐问题的解决方案，分析进程之间是否存在循环等待，是否会发生死锁</p></blockquote><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>引入管程的原因：信号量机制存在编写程序困难、易出错的问题；希望设计一种机制，<strong>让程序员写程序时不需要关注复杂的PV操作</strong>，让写代码更轻松</p><p>1973年，Brinch Hansen在程序设计语言(Pascal)中引入了“管程”——一种<strong>高级同步机制</strong></p><ul><li>管程是一种特殊的<strong>软件模块</strong>，组成部分如下：<ol><li>局部于管程的<strong>共享数据结构</strong>说明</li><li>对该数据结构进行操作的一组<strong>过程</strong>(可以理解为“函数”)</li><li>对局部于管程的共享数据<strong>设置初始值</strong>的语句</li><li>管程有一个名字</li></ol></li><li>管程的<strong>基本特征</strong>：<ol><li>局部于管程的数据只能被局部于管程的过程所访问<ul><li>管程中的数据只能通过管程的函数访问</li></ul></li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据<ul><li>进程必须通过管程的函数才能访问管程中的数据</li></ul></li><li>每次仅允许一个进程在管程内执行某个内部过程<ul><li>同一时间只有一个进程可以使用管程中的某个函数</li></ul></li></ol></li></ul><h4 id="用管程解决生产者消费者问题"><a href="#用管程解决生产者消费者问题" class="headerlink" title="用管程解决生产者消费者问题"></a>用管程解决生产者消费者问题</h4><p>引入管程的目的是为了<strong>更方便地实现进程互斥和同步</strong></p><ol><li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——即局部于管程的过程(可以理解为函数)，比如下述示例中的讲产品放入缓冲区的insert函数和从缓冲区中取出产品的remove函数</li><li>只有通过这些特定的“入口”才可以访问共享数据</li><li>管程中有很多“入口”，但<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>，如下述示例中各进程需要互斥地访问共享缓冲区，管程的这一特性即可保证同一时间段内最多只会有一个进程在访问缓冲区。(PS：这种互斥特性是由编译器负责实现的，程序员无需关心)</li><li>可以在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li></ol><p>程序员可以通过某种特殊的语法定义一个管程，之后其他程序员就可以使用这个管程提供的“入口”(<strong>封装的思想</strong>)很方便地使用实现进程同步/互斥了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下是类C的伪代码，非实际代码</span><br><span class="line">&#x2F;&#x2F; 管程</span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">  condition full, empty;    &#x2F;&#x2F; 条件变量用来实现同步(排队)</span><br><span class="line">  int count&#x3D;0;              &#x2F;&#x2F; 缓冲区内部的产品数量</span><br><span class="line">  &#x2F;&#x2F; 省去了对于缓冲区的定义，实际应用中需要定义</span><br><span class="line">  void insert(Item item) &#123;  &#x2F;&#x2F; 把产品item放入缓冲区</span><br><span class="line">    if(count&#x3D;&#x3D;N)</span><br><span class="line">      wait(full);</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    if(count&#x3D;&#x3D;1)</span><br><span class="line">      signal(empty);</span><br><span class="line">  &#125;</span><br><span class="line">  Item remove() &#123;           &#x2F;&#x2F; 从缓冲区中取出一个产品</span><br><span class="line">    if(count&#x3D;&#x3D;0)</span><br><span class="line">      wait(empty);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;N-1)</span><br><span class="line">      signal(full);</span><br><span class="line">    return remove_item();</span><br><span class="line">  &#125;</span><br><span class="line">end monitor;</span><br><span class="line">&#x2F;&#x2F; 生产者进程</span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item&#x3D;生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消费者进程</span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item&#x3D;ProducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java中类似于管程的机制"><a href="#Java中类似于管程的机制" class="headerlink" title="Java中类似于管程的机制"></a>Java中类似于管程的机制</h4><p>Java中，如果用<strong>关键字synchronized</strong>来描述一个函数，那么这个函数在同一时间段内只能被一个线程调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">monitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> Item[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404133849.png" alt="image-20210404133849669"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><ul><li>死锁：在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</strong>的现象。(发生死锁后若无外力干涉，这些进程都将无法向前推进)</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如SPF算法中若有源源不断的短进程到来，则长进程就一直得不到处理机，从而发生长进程饥饿</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑Bug导致的，有时是程序员故意设计的</li></ul><p>三者的共同点：都是<strong>进程无法顺利向前推进的现象</strong>(故意设计的死循环除外)</p><table><thead><tr><th></th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>死锁一定是<strong>循环等待对方手里的资源</strong>导致的，因此如果有死锁现象，那么<strong>至少有两个及以上的进程同时发生死锁</strong>，另外，发生死锁的进程一定处于<strong>阻塞态</strong></td></tr><tr><td>饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是<strong>阻塞态</strong>(如长期得不到I/O设备)，也可能是<strong>就绪态</strong>(长期得不到处理机)</td></tr><tr><td>死循环</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是<strong>运行态</strong>)，只不过无法像期待的那样顺利推进。</td></tr></tbody></table><ul><li><p>死锁和饥饿是由于操作系统分配资源的策略不合理导致的，死循环是由代码的错误导致的</p></li><li><p>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者(应用程序员)的问题</p></li><li><p>死锁的四个<strong>必要条件</strong>：</p><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这种可以同时让多个进程使用的资源是不会导致死锁的，因为进程不用阻塞等待这种资源</li><li>不剥夺条件：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ol></li></ul><p>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(<strong>循环等待是死锁的必要不充分条件</strong>)；如果同类资源数大于1，则即使有循环等待，也未必发生死锁，但如果系统中<strong>每类资源都只有一个</strong>，那循环等待就是死锁的<strong>充分必要条件</strong>了。</p><ul><li><p>什么时候会发生死锁：<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></p><ol><li>对资源的竞争。各进程对不可剥夺资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占用了资源R1、R2，之后进程P1又紧接着申请资源R2，进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li><li>信号量的使用不当。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能会发生死锁(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li></ol></li><li><p>死锁的处理策略：</p><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li><li>死锁的检测和接触。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施来接触死锁</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404141928.png" alt="image-20210404141928545"></p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>预防死锁：破坏死锁产生的四个必要条件中的一个或几个，只要其中有一个或几个条件不满足，就不会发生死锁</p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术，操作系统可以使用SPOOLing技术<strong>把独占设备在逻辑上改造为共享设备</strong>，例如将打印机改造为共享设备，实际上还是仅有一个打印机，但是要输出的内容会先被放入“输出进程”中，然后由输出进程响应了进程的“打印”这一请求，被响应的进程可以不必等待打印事件真正完成就继续执行，而各个进程需要打印的东西会由输出进程交由打印机来进行打印。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404142956.png" alt="image-20210404142734435"></p><p>缺点：并不是所有的资源都可以改造成可以共享使用的资源，并且为了系统安全，狠多地方还必须保护这种互斥性。因此<strong>很多时候都无法破坏互斥条件</strong></p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p><ul><li><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</p></li><li><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p></li><li><p>破坏不剥夺条件策略<strong>缺点</strong>：</p><ol><li>实现比较复杂；</li><li>释放已获得的资源可能造成前一段工作的失效。故而这种方法一般只适用于易保存和恢复状态的资源，如CPU；</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量；</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ol></li></ul><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</p><p>可以<strong>采用静态分配方法</strong>，即<strong>进程在运行前一次申请完它所需要的全部资源</strong>，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>缺点：有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有可能导致某些进程饥饿</p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可以<strong>采用顺序资源分配法</strong>，即首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。</p><p>原理分析：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已经持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。即在任何一个时刻，总有一个进程拥有的资源编号是最大的，那个进程申请之后的资源必然畅通无阻，也就不会出现所有进程都阻塞的死锁现象</p><ul><li>破坏循环等待条件策略<strong>缺点</strong>：<ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能会和编号递增顺序不一致，会导致资源浪费；因为占有资源的顺序是递增，当要先使用编号大的资源后使用编号小的资源时，在使用编号大的资源的过程中，编号小的资源是处于被占用却闲置的状态的，即资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404145804.png" alt="image-20210404145804635"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全序列：如果系统按照这种序列分配资源，则<strong>每个进程都能顺利完成</strong>，只要能找出一个安全序列，系统就是<strong>安全状态</strong>，<strong>安全序列可能有多个</strong></p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。当然，如果有进程<strong>提前归还了一些资源</strong>，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况</p><p>如果系统处于安全状态，<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能</strong>发生死锁(<strong>处于不安全状态未必就是发生了死锁，发生死锁时一定是处于不安全状态</strong>)</p><p><strong>银行家算法</strong>的核心思想：可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求；在进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>把<strong>单维</strong>的数字拓展为<strong>多维</strong>的向量，由专为银行系统设计的算法拓展为可以被用于操作系统中的银行家算法(操作系统中的资源种类极多，不像银行系统只有一种资源——钱)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404153242.png" alt="银行家算法实例"></p><table><thead><tr><th>Process</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td>P0</td><td>(7, 5, 3)</td><td>(0, 1, 0)</td><td>(7, 4, 3)</td><td>(3, 3, 2)</td></tr><tr><td>P1</td><td>(3, 2, 2)</td><td>(2, 0, 0)</td><td>(1, 2, 2)</td><td></td></tr><tr><td>P2</td><td>(9, 0, 2)</td><td>(3, 0, 2)</td><td>(6, 0, 0)</td><td></td></tr><tr><td>P3</td><td>(2, 2, 2)</td><td>(2, 1, 1)</td><td>(0, 1, 1)</td><td></td></tr><tr><td>P4</td><td>(4, 3, 3)</td><td>(0, 0, 2)</td><td>(4, 3, 1)</td><td></td></tr></tbody></table><table><thead><tr><th>Process</th><th>Available</th><th>Need</th><th>Allocation</th><th>Available+Allocation</th><th>Finish</th></tr></thead><tbody><tr><td>P1</td><td>(3, 3, 2)</td><td>(1, 2, 2)</td><td>(2, 0, 0)</td><td>(5, 3, 2)</td><td>true</td></tr><tr><td>P3</td><td>(5, 3, 2)</td><td>(0, 1, 1)</td><td>(2, 1, 1)</td><td>(7, 4, 3)</td><td>true</td></tr><tr><td>P4</td><td>(7, 4, 3)</td><td>(4, 3, 1)</td><td>(0, 0, 2)</td><td>(7, 4, 5)</td><td>true</td></tr><tr><td>P2</td><td>(7, 4, 5)</td><td>(6, 0, 0)</td><td>(3, 0, 2)</td><td>(10, 4, 7)</td><td>true</td></tr><tr><td>P0</td><td>(10, 4, 7)</td><td>(7, 4, 3)</td><td>(0, 1, 0)</td><td>(10, 5, 7)</td><td>true</td></tr></tbody></table><p>即P1-&gt;P3-&gt;P4-&gt;P2-&gt;P0也是一个安全序列(可以有多个安全序列)。</p><ul><li>数据结构：<ul><li>长度为m的一维数组Available表示还有多少可用资源</li><li>n*m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max-Allocation=Need矩阵表示各进程最多还需要多少资源</li></ul></li><li>银行家算法步骤：<ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性检查算法检查此次分配是否会导致系统进入不安全状态</li></ol></li><li>安全性检查算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列</li></ul><h3 id="死锁的检测和接触"><a href="#死锁的检测和接触" class="headerlink" title="死锁的检测和接触"></a>死锁的检测和接触</h3><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。这种情况下，系统应当提供两种算法：①死锁检测算法；②死锁解除算法</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ol><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><ul><li>对系统是否已经发生了死锁进行检测：<ol><li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已经进入死锁状态</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404155056.png" alt="image-20210404155056782"></p><ol><li>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利执行下去</li><li>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待的进程被激活，并顺序地执行下去</li><li>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程</li></ol><p>如果按照上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可以完全简化的</strong>，此时一定<strong>没有发生死锁</strong>，相当于能找到一个安全序列；如果<strong>不能消除所有边</strong>，那么此时就是已经发生了死锁；最终还连着边的那些进程就是处于死锁状态的进程</p><ul><li>求解资源分配图是否可以消除所有边，有两种方法：<ol><li>方案一：按照上述的求解顺序直接对资源分配图进行操作，执行完一个进程之后更新一次资源分配图，能消除所有边则不死锁，不能消除所有边则会死锁</li><li>方案二：对资源分配图进行分析，将其转化为银行家算法的形式，能求一个安全序列则不死锁，不能求出一个安全序列则会死锁</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404162240.png" alt="image-20210404162240022"></p><p>由上述示例(小规模问题)可知方案一十分快捷且直观，而方案二较为繁琐，但是当问题规模很大时，转化为银行家算法再处理会更为方便</p><ul><li>检测死锁的算法：<ol><li>在资源分配图中，找出既不阻塞又不孤点的进程Pi(即找出一条有向边与它相连，且该有向边对应资源的申请数小于等于该系统中已有空闲资源数量。如上述实例中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的结点，如上述示例中，P1是满足此条件的进程结点，于是消去P1的所有边</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。如上述示例中，消去P1之后，P2成为了非阻塞进程，根据1.中方法进行一系列简化之后，若能消除图中的所有边，则称改图是可以<strong>完全简化</strong>的</li></ol></li></ul><p>死锁定理：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，则此时系统<strong>死锁</strong></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。PS：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程才是死锁进程</strong>，即要先将资源分配图化简，再接触死锁</p><ul><li>解除死锁的<strong>主要方法</strong>：<ol><li>资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程，但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会更大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止就功亏一篑了，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ol></li><li>决定“对谁下手”：<ol><li>进程优先级——进程优先级低的</li><li>已经执行了多长时间——执行了时间短的</li><li>还要多久能完成——还需要时间长的</li><li>进程已经使用了多少资源——占用资源多的</li><li>进程是交互式的还是批处理式的——批处理式的</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20210404164443.png" alt="image-20210404164443163"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统实验-第一章-SQL语言</title>
      <link href="2021/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/"/>
      <url>2021/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自2021春季学期《数据库系统》课程的实验要求，具体来自《数据库系统实验指导教程(第二版)》</p><p>本片文章中使用的是SQL Server配合DataGrip，仅对DataGrip做一些基础使用的介绍，不赘述SQL Server安装过程</p></blockquote><h2 id="配置DataGrip"><a href="#配置DataGrip" class="headerlink" title="配置DataGrip"></a>配置DataGrip</h2><blockquote><p>这里介绍的是如何使用DataGrip连接SQL Server，而且DataGrip是一款付费软件(可以通过学生认证白嫖使用权)，如果使用的是SSMS连接SQL Server，那么可以直接跳过这部分</p></blockquote><h3 id="什么是DataGrip"><a href="#什么是DataGrip" class="headerlink" title="什么是DataGrip"></a>什么是DataGrip</h3><p>DataGrip是JetBrains公司为数据库开发的一款IDE，一开始其相应功能仅是作为大名鼎鼎的IDEA的插件，后来独立成为了一款IDE，理论上来说完全可以通过为IDEA添加插件来实现相应功能，但是我喜欢一款IDE仅做一方面的工作，所以我还是安装了DataGrip，既然是JetBrains公司出品的，那么补全功能就是他们的一贯作风，我是离不开自动补全了，顺别贴一下我使用的软件(红框中的都是JetBrains公司出品的)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331122521.png" alt="image-20210331122521597"></p><p>安装DataGrip有两种方法，一种是下载安装包安装，一种是使用JetBrains ToolBox安装，因为我使用学生认证白嫖了JetBrains全家桶，所以我使用JetBrains ToolBox进行相应的管理，这里不做安装过程的展示。</p><blockquote><p>DataGrip：<a href="https://www.jetbrains.com/datagrip/">https://www.jetbrains.com/datagrip/</a><br>JetBrains ToolBox：<a href="https://www.jetbrains.com/toolbox-app/">https://www.jetbrains.com/toolbox-app/</a></p></blockquote><h3 id="开启SQL-Server的TCP-IP协议"><a href="#开启SQL-Server的TCP-IP协议" class="headerlink" title="开启SQL Server的TCP/IP协议"></a>开启SQL Server的TCP/IP协议</h3><blockquote><p>使用DataGrip连接SQL Server需要其开启TCP/IP功能，因为DataGrip不同于SSMS，并不属于官方工具，需要通过TCP/IP连接</p></blockquote><p>打开SQL Server 2019 配置管理器(如果严格按照老师的要求应该是安装2016)，可以在开始菜单中找到，也可以通过”Win+Q”搜索找到，比如：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331123557.png" alt="image-20210331123557040"></p><p>然后依次点开”SQL Server网络配置”-&gt;”MSSQLSERVER的协议”-&gt;”TCP/IP”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331124748.png" alt="image-20210331124748076"></p><p>然后依次点开”SQL Server服务”-&gt;”SQL Server(MSSQLSERVER)”重启</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331125117.png" alt="image-20210331125117364"></p><h3 id="DataGrip连接SQL-Server"><a href="#DataGrip连接SQL-Server" class="headerlink" title="DataGrip连接SQL Server"></a>DataGrip连接SQL Server</h3><p>依次点击”File”-&gt;”New”-&gt;”Data Source”-&gt;”Microsoft SQL Server”(SQL Server在Data Source中的顺序不一定与我的一致，因为我已经添加过了，开头第一个不是的话往下翻看找找)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331125305.png" alt="image-20210331125305269"></p><p>然后填写信息即可，这里做一下简单的介绍：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331130122.png" alt="image-20210331130121845"></p><p>Test Connection成功示例：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331130154.png" alt="image-20210331130154139"></p><p>DataGrip主窗口，布局介绍大致如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331154813.png" alt="image-20210331154813362"></p><p>很多内容默认是不列出的，比如SQL Server数据库的默认SCHEMA是dbo，但是上述新建的TEST数据库中列出的SCHEMA居然一个也没有，这时候就需要手动使dboSCHEMA可见：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331155144.png" alt="image-20210331155144823"></p><p>这样新建表或者对表进行操作之后，表的信息就可以在左侧看到了。</p><h2 id="实验1-1——数据定义"><a href="#实验1-1——数据定义" class="headerlink" title="实验1.1——数据定义"></a>实验1.1——数据定义</h2><blockquote><p>实验目的：熟悉SQL的数据定义语言，能够熟练地使用SQL语句来创建和更改基本表，创建和取消索引</p></blockquote><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>使用CREATE语句创建基本表</li><li>更改基本表的定义，增加列，删除列，修改列的数据类型</li><li>创建表的升降序索引</li><li>取消表、表的索引或表的约束</li></ul><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)使用SQL语句创建关系数据库表：人员表PERSON(P#, Pname, Page, Pgender)，房间表ROOM(R#, Rname, Rarea)，表P-R(P#, R#, Date)。其中P#是表PERSON的主键，具有唯一性约束，Page具有约束：大于18；R#是表ROOM的主键，具有唯一性约束；表P-R中的P#，R#是外键。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">(</span><br><span class="line">    P#    <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Pname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Page  <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (P#),</span><br><span class="line">    <span class="keyword">CHECK</span> (Page <span class="operator">&gt;</span> <span class="number">18</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">(</span><br><span class="line">    R#    <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Rname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    Rarea <span class="type">FLOAT</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (R#)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PR</span><br><span class="line">(</span><br><span class="line">    P#   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    R#   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="type">Date</span> DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (P#, R#),</span><br><span class="line"><span class="comment">--     FOREIGN KEY (P#) REFERENCES PERSON ON DELETE CASCADE,</span></span><br><span class="line"><span class="comment">--     FOREIGN KEY (R#) REFERENCES ROOM ON DELETE CASCADE</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (P#) <span class="keyword">REFERENCES</span> PERSON,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (R#) <span class="keyword">REFERENCES</span> ROOM</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331161736.png" alt="image-20210331161736235"></p><p>(2)更改表PERSON，增加属性Rtype(类型是CHAR，长度为10)，取消Page大于18的约束。把表ROOM中的属性Rname的数据类型改为长度是30。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">    <span class="keyword">ADD</span> Ptype <span class="type">CHAR</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PERSON</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> CK__PERSON__Page__25869641;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Rname <span class="type">CHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331161948.png" alt="image-20210331161948051"></p><p>(3)删除表ROOM的一个属性Rarea。<br>(4)取消表PR。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ROOM</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> Rarea;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> PR;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162029.png" alt="image-20210331162029687"></p><p>(5)为ROOM表创建按R#降序排列的索引。<br>(6)为PERSON表创建按P#升序排列的索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ROOMINDEX <span class="keyword">ON</span> ROOM (R# <span class="keyword">DESC</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX PERSONINDEX <span class="keyword">ON</span> PERSON (P# <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162131.png" alt="image-20210331162131025"></p><p>(7)创建表PERSON的按Pname升序排列的唯一性索引。<br>(8)取消PERSON表P#升序索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX PERSONUNIQUE <span class="keyword">ON</span> PERSON (Pname <span class="keyword">ASC</span>);</span><br><span class="line"><span class="keyword">DROP</span> INDEX PERSON.PERSONINDEX;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331162235.png" alt="image-20210331162235807"></p><h3 id="自我实践"><a href="#自我实践" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)创建数据库表CUSTOMSERS(CID, CNAME, CITY, DISCNT)，数据库表AGENTS(AID, ANAME, CITY, PERCENT)，数据库表PRODUCTS(PID, PNAME)。其中CID，AID，PID分别是各表的主键，具有唯一性约束。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> CUSTOMSERS</span><br><span class="line">(</span><br><span class="line">    CID    <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    CNAME  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    CITY   <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    DISCNT <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (CID)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> AGENTS</span><br><span class="line">(</span><br><span class="line">    AID       <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    ANAME     <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    CITY      <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    [<span class="keyword">PERCENT</span>] <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (AID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">(</span><br><span class="line">    PID   <span class="type">CHAR</span>(<span class="number">8</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    PNAME <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (PID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170201.png" alt="image-20210331170201880"></p><p>(2)创建数据库表ORDERS(ORDNA, MONTH, CID, AID, PID, QTY, DOLLARS)。其中ORDNA是主键，具有唯一性约束；CID，AID，PID是外键，分别参照的是表CUSTOMSERS的CID字段，表AGENTS的AID字段，PRODUCTS的PID字段。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ORDERS</span><br><span class="line">(</span><br><span class="line">    ORDNA   <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    <span class="keyword">MONTH</span>   <span class="type">INT</span>,</span><br><span class="line">    CID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    AID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    PID     <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    QTY     <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    DOLLARS MONEY,</span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (ORDNA),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (CID) <span class="keyword">REFERENCES</span> CUSTOMSERS (CID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (AID) <span class="keyword">REFERENCES</span> AGENTS (AID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (PID) <span class="keyword">REFERENCES</span> PRODUCTS (PID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170241.png" alt="image-20210331170241663"></p><p>(3)增加数据库表PRODUCTS的三个属性列：CITY，QUANTITY，PRICE。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> CITY <span class="type">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> QUANTITY <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> PRODUCTS</span><br><span class="line">    <span class="keyword">ADD</span> PRICE MONEY;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170327.png" alt="image-20210331170327361"></p><p>(4)为以上四个表建立各自的按主键增序排列的索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX CUSINDEX <span class="keyword">ON</span> CUSTOMSERS (CID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX AGENTSINDEX <span class="keyword">ON</span> AGENTS (AID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX PROINDEX <span class="keyword">ON</span> PRODUCTS (PID);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX ORDERSINDEX <span class="keyword">ON</span> ORDERS (ORDNA);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170414.png" alt="image-20210331170413980"></p><p>(5)取消步骤(4)建立的四个索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX CUSTOMSERS.CUSINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX AGENTS.AGENTSINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX PRODUCTS.PROINDEX;</span><br><span class="line"><span class="keyword">DROP</span> INDEX ORDERS.ORDERSINDEX;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331170535.png" alt="image-20210331170535101"></p><h2 id="实验1-2——数据查询"><a href="#实验1-2——数据查询" class="headerlink" title="实验1.2——数据查询"></a>实验1.2——数据查询</h2><blockquote><p>实验目的：熟悉SQL语句的数据查询语言，能够使用SQL语句对数据库进行单表查询、连接查询、嵌套查询、集合查询和统计查询。通过实验理解在数据库表中的对数据的NULL值的处理。</p></blockquote><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>虽然直接写出SELECT语句也可以，但是为了直观的看出自己写的对不对，还是要先导入School数据库，一般情况下导入数据库时遇到的最多的问题就是“访问权限”问题，修改一下权限即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210331172611.png" alt="image-20210331172611053"></p><p>在DataGrip的console或者SSMS的查询中执行如下语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_attach_db <span class="variable">@dbname</span> <span class="operator">=</span> <span class="string">&#x27;School&#x27;</span>,</span><br><span class="line">     <span class="variable">@filename1</span> <span class="operator">=</span> N<span class="string">&#x27;D:\Study\2021-Spring\数据库系统\Experiment\实验数据库\School_Data.MDF&#x27;</span>,</span><br><span class="line">     <span class="variable">@filename2</span> <span class="operator">=</span> N<span class="string">&#x27;D:\Study\2021-Spring\数据库系统\Experiment\实验数据库\School_Log.LDF&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>其中：<ul><li>dbname即数据库名称，可以自己改</li><li>filename1和filename2分别是mdf和ldf文件的路径，替换为自己的路径即可</li></ul></li></ul><p>如果使用的是DataGrip，可能还需要使导入的数据库可见，参照前面的”配置DataGrip”中的介绍即可。</p><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><p>本节内容主要是对数据库进行查询操作，包括如下4类查询方式：</p><ol><li>单表查询<ul><li>查询的目标表达式为所有列、指定列或指定列的运算</li><li>使用DISTINCT保留字消除重复行</li><li>对查询结果排序和分组</li><li>集合分组使用集函数进行各项统计</li></ul></li><li>连接查询<ul><li>笛卡尔连接和等值连接</li><li>自连接</li><li>外连接</li><li>复合条件连接</li><li>多表连接</li></ul></li><li>嵌套查询<ul><li>通过实验验证对子查询的两个限制条件</li><li>体会相关子查询和不相关子查询的不同</li><li>考察4类谓词的用法，包括：<ul><li>第1类：IN，NOT IN</li><li>第2类：带有比较运算符的子查询</li><li>第3类：SOME, ANY或ALL谓词的子查询</li><li>第4类：带有EXISTS谓词的子查询</li></ul></li></ul></li><li>集合运算<ul><li>使用保留字UNION进行集合或运算</li><li>采用逻辑运算符AND或OR来实现集合交和减运算</li></ul></li></ol><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>以School数据库为例，在该数据库中存在4张表格，分别为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STUDENTS(sid, sname, email, grade)</span><br><span class="line">TEACHERS(tid, tname, email, salary)</span><br><span class="line">COURSES(cid, cname, <span class="keyword">hour</span>)</span><br><span class="line">CHOICES(<span class="keyword">no</span>, sid, tid, cid, score)</span><br></pre></td></tr></table></figure><p>在数据库中，存在这样的关系：学生可以选择课程。一个课程对应一个教师。在表CHOICES中保存学生的选课记录</p><p>(1)查询年级为2001的所有学生的名称，按编号升序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="number">2001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p>(2)查询学生的选课成绩合格的课程成绩，并把成绩换算为绩点(60分对应绩点为1，每增加1，绩点增加1)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score <span class="operator">-</span> <span class="number">60</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="comment">-- SELECT score - 59</span></span><br><span class="line"><span class="comment">-- FROM CHOICES</span></span><br><span class="line"><span class="comment">-- WHERE score &gt;= 60;</span></span><br></pre></td></tr></table></figure><p>(3)查询课时是48或64的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="keyword">IN</span> (<span class="number">48</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>(4)查询所有课程名称中含有data的课程编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="keyword">LIKE</span> <span class="string">&#x27;%data%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5)查询所有选课记录的课程号(不重复显示)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p>(6)统计所有老师的平均工资</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p>(7)查询所有学生的编号、姓名和平均成绩，按总平均成绩降序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, sname, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> STUDENTS.sid, sname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(score) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>(8)统计各个课程的选课人数和平均成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> sid) <span class="string">&#x27;COUNT-PEOPLE&#x27;</span>, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br></pre></td></tr></table></figure><p>(9)查询至少选修了三门课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid) <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>(10)查询编号为800009026的学生所选的全部课程的课程名和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname, score</span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.sid <span class="operator">=</span> <span class="string">&#x27;800009026&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(11)查询所有选了database的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;database&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid;</span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;database&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(12)求出选择了同一个课程的学生对</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid, SECOND.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">!=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> SECOND.cid;</span><br></pre></td></tr></table></figure><p>(13)求出至少被两名学生选修的课程编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> sid) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>(14)查询选修了编号为80009026的学生所选的某个课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800009026&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(15)查询学生的基本信息及选修课程编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.<span class="operator">*</span>, CHOICES.cid, CHOICES.score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> STUDENTS.sid, CHOICES.score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>(16)查询学号850955252的学生的姓名和选修的课程名称及成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname, cname, score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> <span class="string">&#x27;850955252&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid;</span><br></pre></td></tr></table></figure><p>(17)查询学号850955252的学生同年级的所有学生资料</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;850955252&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(18)查询所有的有选课的学生的详细信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> STUDENTS.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(19)查询没有学生选的课程的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(20)查询选修了课程名为C++的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> cid <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> cid</span><br><span class="line">        <span class="keyword">FROM</span> COURSES</span><br><span class="line">        <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;c++&#x27;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid;</span><br></pre></td></tr></table></figure><p>(21)找出选修课程成绩最差的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> score</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score)</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(22)找出和课程UML或课程C++的课时一样的课程名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span></span><br><span class="line">       <span class="keyword">OR</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> FIRST.cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES <span class="keyword">FIRST</span>,</span><br><span class="line">     COURSES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> (SECOND.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span> <span class="keyword">OR</span> SECOND.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> FIRST.hour <span class="operator">=</span> SECOND.hour;</span><br></pre></td></tr></table></figure><p>(23)查询所有选修编号10001的课程的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(24)查询选修了所有课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> COURSES</span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> CHOICES</span><br><span class="line">                <span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">                  <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>(25)利用集合运算，查询选修课程C++或课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合运算——UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> (COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span> <span class="keyword">OR</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(26)实现集合加运算，查询既选修课程C++又选修课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合加运算——INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合加运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">AND</span> SECOND.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(27)实现集合减运算，查询选修课程C++而没有选修课程Java的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用集合减运算——EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">    <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不使用集合减运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> FIRST.sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES <span class="keyword">FIRST</span>,</span><br><span class="line">     CHOICES <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.sid <span class="operator">=</span> SECOND.sid</span><br><span class="line">  <span class="keyword">AND</span> FIRST.cid <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> COURSES.cid</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">AND</span> SECOND.sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="自我实践-1"><a href="#自我实践-1" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)查询全部课程的详细记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(2)查询所有有选修课的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p>(3)查询课时&lt;88小时的课程的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">88</span>;</span><br></pre></td></tr></table></figure><p>(4)请找出总分超过400分的学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(score) <span class="operator">&gt;</span> <span class="number">400</span>;</span><br></pre></td></tr></table></figure><p>(5)查询课程的总数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(6)查询所有课程和选修该课程的学生总数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COURSES.<span class="operator">*</span>, <span class="built_in">COUNT</span>(sid) <span class="string">&#x27;COUNT-SID&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> COURSES.cid, cname, <span class="keyword">hour</span>;</span><br></pre></td></tr></table></figure><p>(7)查询选修成绩合格的课程超过两门的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(cid) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>(8)统计各个学生的选修课程数目和平均成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, <span class="built_in">COUNT</span>(cid) <span class="string">&#x27;COUNT-CID&#x27;</span>, <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CHOICES.sid;</span><br></pre></td></tr></table></figure><p>(9)查询选修Java的所有学生的编号及姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES,</span><br><span class="line">     STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(10)分别使用等值连接和谓词IN两种方式查询姓名为sssht的学生所选的课程的编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="operator">=</span> STUDENTS.sid</span><br><span class="line">  <span class="keyword">AND</span> sname <span class="operator">=</span> <span class="string">&#x27;sssht&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.sid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;sssht&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(11)查询其他课时比课程C++多的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(12)查询选修C++课程的成绩比姓名为znkoo的学生高的所有学生的编号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, STUDENTS.sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> CHOICES.score <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> score</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">         CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> STUDENTS.sname <span class="operator">=</span> <span class="string">&#x27;znkoo&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">      <span class="keyword">AND</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(13)找出和学生883794999或学生8509555252的年级一样的学生的姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;883794999&#x27;</span></span><br><span class="line">       <span class="keyword">OR</span> sid <span class="operator">=</span> <span class="string">&#x27;8509555252&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(14)查询没有选修Java的学生名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;JAVA&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(15)找出课时最少的课程的详细信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(<span class="keyword">hour</span>)</span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(16)查询工资最高的教师的编号和开设的课程号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CHOICES.tid, CHOICES.cid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     TEACHERS</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.tid <span class="operator">=</span> TEACHERS.tid</span><br><span class="line">  <span class="keyword">AND</span> TEACHERS.salary <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> TEACHERS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(17)找出选修课程ERP成绩最高的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;ERP&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score)</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;ERP&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(18)查询没有学生选修的课程的名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(19)找出讲授课程UML的教师讲授的所有课程名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> tid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> tid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES,</span><br><span class="line">         COURSES</span><br><span class="line">    <span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">      <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(20)查询选修了编号200102901的教师开设的所有课程的学生编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES X</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> CHOICES Y</span><br><span class="line">        <span class="keyword">WHERE</span> Y.tid <span class="operator">=</span> <span class="string">&#x27;200102901&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> CHOICES Z</span><br><span class="line">                <span class="keyword">WHERE</span> Z.sid <span class="operator">=</span> X.sid</span><br><span class="line">                  <span class="keyword">AND</span> Z.cid <span class="operator">=</span> Y.cid</span><br><span class="line">            )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>(21)查询选修课程Database的学生集合与选修课程UML的学生集合的并集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(22)实现集合交运算，查询既选修课程Database又选修课程UML的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(23)实现集合减运算，查询选修课程Database而没有选修课程UML的学生的编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;Database&#x27;</span></span><br><span class="line">    <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> sid</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="实验1-3——数据更新"><a href="#实验1-3——数据更新" class="headerlink" title="实验1.3——数据更新"></a>实验1.3——数据更新</h2><blockquote><p>实验目的：熟悉数据库的数据更新操作，能够使用SQL语句对数据库进程数据的插入、更新、删除操作</p></blockquote><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><p>本次实验中，主要内容是如何使用SQL语句对数据进行更新：</p><ul><li>使用INSERT INTO语句插入数据，包括插入一个元组或将子查询的结果插入到数据库中两种方式</li><li>使用SELECT INTO语句，产生一个新表并插入数据</li><li>使用UPDATE语句可以修改指定表中满足WHERE子句条件的元组，有三种修改的方式：修改一个元组，修改多个元组的值，带子查询的修改语句</li><li>使用DELETE语句删除数据：删除某一个元组的值，删除多个元组的值，带子查询的删除语句</li></ul><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE School;</span><br></pre></td></tr></table></figure><p>(1)使用SQL语句向STUDENTS表中插入元组<br>– (编号：700045678；名字：LiMing；EMAIL：<a href="mailto:&#76;&#x58;&#64;&#99;&#x64;&#101;&#x6d;&#103;&#46;&#99;&#x6f;&#x6d;">&#76;&#x58;&#64;&#99;&#x64;&#101;&#x6d;&#103;&#46;&#99;&#x6f;&#x6d;</a>；年级：1992</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> STUDENTS(SID, SNAME, EMAIL, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;700045678&#x27;</span>, <span class="string">&#x27;LiMing&#x27;</span>, <span class="string">&#x27;LX@cdemg.com&#x27;</span>, <span class="number">1992</span>);</span><br><span class="line"><span class="comment">-- 查询插入前和插入后的区别</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;700045678&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405094124.png" alt="image-20210405094123962"></p><p>(2)对每个课程，求学生的选课人数和学生的平均成绩，并把结果存入数据库。<br>– 使用SELECT INTO和INSERT INTO两种方法实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一步，建表——COURSEINFO_INSERT</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COURSEINFO_INSERT</span><br><span class="line">(</span><br><span class="line">    Cid       <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    Students  <span class="type">INT</span>,</span><br><span class="line">    Avg_score <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 第二步，使用INSERT INTO的方式</span></span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> COURSEINFO_INSERT(CID, STUDENTS, AVG_SCORE)</span><br><span class="line"><span class="keyword">SELECT</span> cid, <span class="built_in">COUNT</span>(sid), <span class="built_in">AVG</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br><span class="line"><span class="comment">-- 查询插入结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSEINFO_INSERT;</span><br><span class="line"><span class="comment">-- 使用SELECT INTO的方式</span></span><br><span class="line"><span class="keyword">SELECT</span> cid        <span class="keyword">AS</span> Cid,</span><br><span class="line">       <span class="built_in">COUNT</span>(sid) <span class="keyword">AS</span> Students,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">INTO</span> COURSEINFO_SELECT</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br><span class="line"><span class="comment">-- 查询插入结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSEINFO_SELECT;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405100406.png" alt="image-20210405100405951"></p><p>(3)在STUDENTS表中使用SQL语句将姓名为”LiMing”的学生的年级改为”2002”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> STUDENTS</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">2002</span></span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405100739.png" alt="image-20210405100739228"></p><p>(4)在TEACHERS表中使用SQL语句将所有教师的工资多加500元</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span>salary <span class="operator">+</span> <span class="number">500</span>;</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405101503.png" alt="image-20210405101503520"></p><p>(5)将姓名为zapyv的学生的课程”C”的成绩加上5分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CHOICES</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> STUDENTS <span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;zapyv&#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> cid <span class="operator">=</span> (<span class="keyword">SELECT</span> Cid <span class="keyword">FROM</span> COURSES <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询更新前和更新后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> STUDENTS.sid, sname, COURSES.Cid, cname, score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> sname <span class="operator">=</span> <span class="string">&#x27;zapyv&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102339.png" alt="image-20210405102339558"></p><p>(6)在STUDENTS表中使用SQL语句删除姓名为”LiMing”的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;LiMing&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102512.png" alt="image-20210405102512765"></p><p>(7)删除所有选修课程”Java”的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> (<span class="keyword">SELECT</span> cid</span><br><span class="line">             <span class="keyword">FROM</span> COURSES</span><br><span class="line">             <span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.<span class="operator">*</span>, cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210405102943.png" alt="image-20210405102943220"></p><p>(8)对COURSES表做删去时间&lt;48的元组的操作，并讨论该删除操作所受到的约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">48</span>;</span><br><span class="line"><span class="comment">-- 查询删除前和删除后的对比</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;</span> <span class="number">48</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2021-04-05 10:31:39] [23000][547] DELETE 语句与 REFERENCE 约束&quot;FK_CHOICES_COURSES&quot;冲突。该冲突发生于数据库&quot;School&quot;，表&quot;dbo.CHOICES&quot;, column &#39;cid&#39;。</span><br></pre></td></tr></table></figure><p>因为COURSES中的cid在CHOICES表中作为外键存在，所以与约束冲突，删除失败</p><h3 id="自我实践-2"><a href="#自我实践-2" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)向STUDENTS表中插入编号是’800022222’且姓名是”WangLan”的元组</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> STUDENTS(sid, sname)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;800022222&#x27;</span>, <span class="string">&#x27;WangLan&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(2)向TEACHERS表插入元组(‘200001000’, ‘LXL’, ‘s4zrck@pew.net’, ‘3024’)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> TEACHERS(TID, TNAME, EMAIL, SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;200001000&#x27;</span>, <span class="string">&#x27;LXL&#x27;</span>, <span class="string">&#x27;s4zrck@pew.net&#x27;</span>, <span class="string">&#x27;3024&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(3)将TEACHERS表中编号为’200010493’的老师的工资改为4000</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span><span class="number">4000</span></span><br><span class="line"><span class="keyword">WHERE</span> tid <span class="operator">=</span> <span class="string">&#x27;200010493&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(4)将TEACHERS表中所有工资小于2500的老师工资改为2500</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line"><span class="keyword">SET</span> salary<span class="operator">=</span><span class="number">2500</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">2500</span>;</span><br></pre></td></tr></table></figure><p>(5)将由编号为’200016731’的老师所授的课程全部改为由姓名为’rnupx’的老师讲授</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CHOICES</span><br><span class="line"><span class="keyword">SET</span> tid<span class="operator">=</span>(<span class="keyword">SELECT</span> tid <span class="keyword">FROM</span> TEACHERS <span class="keyword">WHERE</span> tname <span class="operator">=</span> <span class="string">&#x27;rnupx&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> tid <span class="operator">=</span> <span class="string">&#x27;200016731&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(6)更新编号为’800071780’的学生年级为2001</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> STUDENTS</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">2001</span></span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;800071780&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(7)删除没有学生选修的课程</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Cid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(8)删除年级高于1998的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="number">1998</span>;</span><br></pre></td></tr></table></figure><p>(9)删除没有选修课程的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">    <span class="keyword">FROM</span> CHOICES</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(10)删除成绩不及格的选课记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="实验1-4——视图"><a href="#实验1-4——视图" class="headerlink" title="实验1.4——视图"></a>实验1.4——视图</h2><blockquote><p>实验目的：熟悉SQL语言支持的有关视图的操作，能够熟练使用SQL语句来创建需要的视图，对视图进行查询和取消视图</p></blockquote><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>定义常见的视图形式，包括：<ul><li>行列子集视图</li><li>WITH CHECK OPTION视图</li><li>基于多个基表的视图</li><li>基于视图的视图</li><li>带表达式的视图</li><li>分组视图</li></ul></li><li>通过实验考察WITH CHECK OPTION这一语句在视图定义后产生的影响，包括对修改操作、删除操作、插入操作的影响</li><li>讨论视图的数据更新情况，对子行列视图进行数据更新</li><li>使用DROP语句删除一个视图，由该视图导出的其他视图定义仍在数据字典中，但已不能使用，必须显式删除。同样的原因，删除基表时，由该基表导出的所有视图定义都必须显式删除</li></ol><h3 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)创建一个行列子集视图，给出选课成绩合格的学生的编号，所选课程号和该课程成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Qualified</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083446.png" alt="image-20210414083445992"></p><p>(2)创建基于多个基表的视图，这个视图由学生姓名和其所选修的课程名及讲授该课程的教师姓名构成</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SCT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, cname, tname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     TEACHERS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br><span class="line">  <span class="keyword">AND</span> TEACHERS.tid <span class="operator">=</span> CHOICES.tid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083327.png" alt="image-20210414083327445"></p><p>(3)创建带表达式的视图，由学生姓名、所选课程名和所有课程成绩都比原来多5分这几个属性组成</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ExpressionVIEW</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, cname, score <span class="operator">+</span> <span class="number">5</span> <span class="keyword">AS</span> SCORE</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     COURSES,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid</span><br><span class="line">  <span class="keyword">AND</span> COURSES.cid <span class="operator">=</span> CHOICES.cid</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083748.png" alt="image-20210414083748742"></p><p>(4)创建分组视图，将学生的学号及其平均成绩定义为一个视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> GroupingVIEW</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083843.png" alt="image-20210414083842937"></p><p>(5)创建一个基于视图的视图，基于(1)中建立的视图，定义一个包含学生编号，学生所选课数目和平均成绩的视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BASEDONVIWE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid,</span><br><span class="line">       <span class="built_in">COUNT</span>(cid) <span class="keyword">AS</span> Count_cid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> Avg_score</span><br><span class="line"><span class="keyword">FROM</span> Qualified</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414083950.png" alt="image-20210414083950141"></p><p>(6)查询所有选修课程Software Engineering的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> SCT</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;Software Engineering&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084014.png" alt="image-20210414084014100"></p><p>(7)插入元组(600000000, 823069829, 10010, 59)到视图CS中<br>– 若是在视图的定义中存在WITH CHECK OPTION子句对插入操作有什么影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, sid, cid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> CS(<span class="keyword">NO</span>, SID, CID, SCORE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;600000000&#x27;</span>, <span class="string">&#x27;823069829&#x27;</span>, <span class="string">&#x27;10010&#x27;</span>, <span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>含有WITH CHECK OPTION会进行检查，由于待插入元组的Score为59不及格，故插入失败</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414090019.png" alt="image-20210414084124700"></p><p>(8)将视图CS(包含WITH CHECK OPTION)中，所有课程编号为10010的课程的成绩都减去5分。<br>– 这个操作数据库是否会正确执行，为什么？<br>– 如果加上5分(原来95分以上的不变)呢？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">-</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>减去5分的操作不会正确执行，因为CS具有WITH CHECK OPTION检查，部分元组减去5分后会检查出错，不再及格</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> CS</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;=</span> <span class="number">95</span>;</span><br></pre></td></tr></table></figure><p>增加5分可以正确执行，因为增加5分这项操作不会触碰WITH CHECK OPTION的检查</p><p>(9)在视图CS(包含WITH CHECK OPTION)中，删除编号为804529880学生的记录，会产生什么结果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> CS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;804529880&#x27;</span>;</span><br><span class="line"><span class="comment">-- 由于视图不保存数据内容，而是保存类似于“索引”的东西，所以删除操作是作用在原本的CHOICES表中，即在CHOICES表中，学号为804529880的学生的选课记录均会被删除</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;804529880&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(10)取消视图SCT和视图CS</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> SCT;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> CS;</span><br><span class="line"><span class="comment">-- 自己定义的第(1)中的名字是Qualified(及格)，相当于CS，而BASEDONVIEW视图基于此视图，需要显式删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> Qualified;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BASEDONVIWE;</span><br><span class="line"><span class="comment">-- 顺便删除其他的视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> ExpressionVIEW;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> GroupingVIEW;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084215.png" alt="image-20210414084215852"></p><h3 id="自我实践-3"><a href="#自我实践-3" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)定义选课信息和课程名称的视图VIEWC</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VIEWC</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> CHOICES.<span class="operator">*</span>, cname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid;</span><br></pre></td></tr></table></figure><p>(2)定义学生姓名和选课信息的视图VIEWS</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不知道为啥，VIEWS报错，需要加[VIEWS]</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> [VIEWS]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, CHOICES.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS,</span><br><span class="line">     CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> STUDENTS.sid <span class="operator">=</span> CHOICES.sid;</span><br></pre></td></tr></table></figure><p>(3)定义年级低于1998的学生的视图S1(SID, SNANE, GRADE)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sid, sname, grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;</span> <span class="number">1998</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>(4)查询姓名为”uxjof”的学生的选课信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> [VIEWS]</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5)查询选修课程”UML”的学生的编号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> VIEWC</span><br><span class="line"><span class="keyword">WHERE</span> cname <span class="operator">=</span> <span class="string">&#x27;UML&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(6)向视图S1插入记录(‘60000001’, ‘Lily’, 2001)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;60000001&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="number">2001</span>);</span><br></pre></td></tr></table></figure><p>(7)定义包括更新和插入约束的视图S1，尝试向视图插入记录(‘60000001’, ‘Lily’, 1997)<br>– 删除所有年级为1999的学生记录，讨论更新和插入约束带来的影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S1(SID, SNAME, GRADE)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;60000001&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="number">1997</span>);</span><br><span class="line"><span class="comment">-- 因为已经在(6)中插入过学号为&#x27;60000001&#x27;的信息，由于UNIQUE约束，无法插入</span></span><br><span class="line"><span class="comment">-- 去除原本的学号为&#x27;60000001&#x27;的元组信息后，由于WITH CHECK OPTION约束，1997年级比1998高，无法插入</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> S1</span><br><span class="line"><span class="keyword">WHERE</span> GRADE <span class="operator">=</span> <span class="number">1999</span>;</span><br><span class="line"><span class="comment">-- 删除失败，且由于视图的性质，删除操作针对的是原表STUDENTS，而STUDENTS中sid是表CHOICES的外键，发生REFERENCE冲突</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="number">1999</span>;</span><br></pre></td></tr></table></figure><p>(8)在视图VIEWS中将姓名为’uxjof’的学生的选课成绩都加上5分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [VIEWS]</span><br><span class="line"><span class="keyword">SET</span> score<span class="operator">=</span>score <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> [VIEWS]</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="operator">=</span> <span class="string">&#x27;uxjof&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(9)取消以上建立的所有视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [VIEWS];</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> VIEWC;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> S1;</span><br></pre></td></tr></table></figure><h2 id="实验1-5——数据控制"><a href="#实验1-5——数据控制" class="headerlink" title="实验1.5——数据控制"></a>实验1.5——数据控制</h2><blockquote><p>实验目的：熟悉SQL的数据控制功能，能够使用SQL语句来向用户授予和回收权限</p></blockquote><h3 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h3><ol><li>使用GRANT语句对用户授权，对单个用户和多个用户授权，或使用保留字PUBLIC对所有用户授权。对不同的操作对象包括数据库、视图、基本表等进行不同权限的授权</li><li>使用WITH GRANT OPTION子句授予用户传播该权限的权利</li><li>在授权时发生循环授权，考察DBS能否发现这个错误。如果不能，结合取消权限操作，查看DBS对循环授权的控制</li><li>使用REVOKE子句收回授权，取消授权的级联反应</li></ol><h3 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>在数据库school中建立三个用户USER1，USER2和USER3，它们在数据库中的角色是PUBLIC。按以下要求，分别以管理员身份或这三个用户的身份登录到数据库中，进行操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER1 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER2 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> USER3 <span class="keyword">WITHOUT</span> LOGIN;</span><br><span class="line"><span class="comment">-- 一些基础语句：</span></span><br><span class="line"><span class="comment">-- 1.查看所有用户</span></span><br><span class="line"><span class="keyword">exec</span> sp_helpuser;</span><br><span class="line"><span class="comment">-- 2.切换到指定用户</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.切换回数据库管理员-REVERT-好像是撤销指令</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="comment">-- 4.查看当前用户名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">SELECT</span> SUSER_NAME();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414084430.png" alt="image-20210414084429943"></p><p>(1)授予所有用户对表COURSES的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(2)授予USER1对表STUDENTS插入和更新的权限，但不授予删除权限，并且授予USER1传播这两个权限的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(3)允许USER2在表CHOICES中插入元组，更新SCORE列，可以选取除了SID以外的所有列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>, <span class="comment">/* 在CHOICES中插入元组 */</span></span><br><span class="line">    <span class="keyword">UPDATE</span> (score) <span class="comment">/* 在CHOICES中更新SCORE列 */</span></span><br><span class="line">    <span class="keyword">ON</span> CHOICES</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br><span class="line"><span class="comment">-- 创建视图，此视图仅没有sid</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CHOICE_NO_SID(<span class="keyword">no</span>, cid, tid, score)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, cid, tid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="comment">/* 对USER2授予查询上述新建的视图的权限 */</span></span><br><span class="line">    <span class="keyword">ON</span> CHOICE_NO_SID</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085128.png" alt="image-20210414085128273"></p><p>(4)USER1授予USER2对表STUDENTS插入和更新的权限，并且授予USER2传播插入操作的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>; <span class="comment">/* 切换为USER1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* 对USER2授予更新STUDENTS的权限，不可传播 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="comment">/* 对USER2授予插入STUDENTS的权限，可传播 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(5)收回USER1对表COURSES查询的授权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">FROM</span> USER1;</span><br></pre></td></tr></table></figure><p>(6)由上面(2)和(4)的授权，再由USER2对USER3授予表STUDENTS插入和更新的权限，并且授予USER3传播插入操作的权利。<br>– 这时候，如果由USER3对USER1授予表STUDENTS的插入和更新权限是否能够成功？<br>– 如果能够成功，那么如果由USER2取消对USER3的授权，对USER1会有什么影响？<br>– 如果再由DBA取消USER1的权限，对USER2有什么影响？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* USER2不具有更新SUTDENTS的权限，授权失败 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER3;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> <span class="comment">/* USER3给USER1授予STUDENTS的插入权限成功 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER3</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这时候，如果由USER3对USER1授予表STUDENTS的插入和更新权限是否能够成功？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER3&#x27;</span>; <span class="comment">/* 切换为USER3 */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span> <span class="comment">/* USER3不具有更新SUTDENTS的权限 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> USER1;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果能够成功，那么如果由USER2取消对USER3的授权，对USER1会有什么影响？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="comment">/* 取消对USER3的授权 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER3 CASCADE;</span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>; <span class="comment">/* 切换为USER1 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (SID, SNAME, EMAIL, GRADE) <span class="comment">/* 测试INSERT */</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;TEST-USER1&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="number">2021</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;TEST-USER1&#x27;</span>; <span class="comment">/* 插入成功，并不会影响USER1 */</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085700.png" alt="image-20210414085700166"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果再由DBA取消USER1的权限，对USER2有什么影响？</span></span><br><span class="line">REVERT; <span class="comment">/* 回到超级用户 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> , <span class="keyword">UPDATE</span> <span class="comment">/* 取消对USER1的授权 */</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>; <span class="comment">/* 切换为USER2 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (SID, SNAME, EMAIL, GRADE) <span class="comment">/* 测试INSERT */</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;TEST-USER2&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="string">&#x27;TEST&#x27;</span>, <span class="number">2021</span>);</span><br><span class="line"><span class="comment">-- USER2也不再具有对STUDENTS的插入权限</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414085806.png" alt="image-20210414085806673"></p><h3 id="自我实践-4"><a href="#自我实践-4" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)授予所有用户对表STUDENTS的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(2)授予所有用户对表COURSES的查询和更新权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span></span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">TO</span> [PUBLIC];</span><br></pre></td></tr></table></figure><p>(3)授予USER1对表TEACHERS的查询，更新工资的权限，且允许USER1可以传播这些权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> (salary)</span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER1</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(4)授予USER2对表CHOICES的查询，更新成绩的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> (score)</span><br><span class="line">    <span class="keyword">ON</span> CHOICES</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p>(5)授予USER2对表TEACHERS的除了工资以外的所有信息的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> TEACHERS_NO_SALARY(TID, TNAME, EMAIL)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> tid, tname, email</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS_NO_SALARY</span><br><span class="line">    <span class="keyword">TO</span> USER2;</span><br></pre></td></tr></table></figure><p>(6)由USER1授予USER2对表TEACHERS的查询权限和传播此项权限的权利</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(7)由USER2授予USER3对表TEACHERS的查询权限和传播此项权限的权利。<br>– 再由USER3授予USER2上述权限，这样的SQL语句能否成功得到执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER3</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="comment">-- 再由USER3授予USER2上述权限，可以执行</span></span><br><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER3&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">TO</span> USER2</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(8)取消USER1对表STUDENTS的查询权限，考虑由USER2的身份对表STUDENTS进行查询，操作能否成功？为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> STUDENTS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br><span class="line"><span class="comment">-- 操作可以成功，因为对表STUDENTS的查询权限是授予所有用户的，用户之间此权限无相关性</span></span><br></pre></td></tr></table></figure><p>题目应该改为——取消USER1对表TEACHERS的查询权限，考虑由USER2的身份对表TEACHERS进行查询，操作能否成功？为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">ON</span> TEACHERS</span><br><span class="line">    <span class="keyword">FROM</span> USER1 CASCADE;</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">AS</span> <span class="keyword">USER</span> <span class="operator">=</span><span class="string">&#x27;USER2&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br><span class="line"><span class="comment">-- 此时操作不成功，因为权限被级联删除，USER2的对TEACHERS表的查询权限是由USER1授予的，回收USER1的权限的时候，USER2的权限被自动回收</span></span><br></pre></td></tr></table></figure><p>(9)取消USER1和USER2的关于COURSES的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVERT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES</span><br><span class="line">    <span class="keyword">ON</span> COURSES</span><br><span class="line">    <span class="keyword">FROM</span> USER1, USER2;</span><br></pre></td></tr></table></figure><h2 id="实验1-6——空值和空集的处理"><a href="#实验1-6——空值和空集的处理" class="headerlink" title="实验1.6——空值和空集的处理"></a>实验1.6——空值和空集的处理</h2><blockquote><p>实验目的：认识NULL值在数据库中的特殊含义，了解空值和空集对于数据库的数据查询操作，特别是空值在条件表达式中与其他的算术运算符或者逻辑运算符的运算中，空集作为嵌套查询的子查询的返回结果时候的特殊性，能够熟练使用SQL语句来进行与空值、空集相关的操作</p></blockquote><h3 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h3><p>通过实验验证在SQL Server对NULL的处理，包括：</p><ol><li>再查询的目标表达式中包含空值的运算</li><li>在查询条件中控制与比较运算符的运算结果</li><li>使用”IS NULL”和”IS NOT NULL”来判断元组该列是否为空值</li><li>对存在取空值的列按值进行ORDER BY排序</li><li>使用保留字DISTINCT对空值的处理，区分数据库的多种取值与现实中的多种取值的不同</li><li>使用GROUP BY对存在取空值的属性值进行分组</li><li>结合分组考察控制对各个集合函数的影响，特别注意对COUNT(*)和COUNT(列名)的不同影响</li><li>考察结果集市空集时，各个集函数的处理情况</li><li>验证嵌套查询中返回空集的情况下与各个谓词的运算结果</li><li>进行与空值有关的等值连接运算</li></ol><h3 id="实验步骤-5"><a href="#实验步骤-5" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>(1)查询所有选课记录的成绩并将其转换为五分制(满分为5分，合格为3分)，注意SCORE取NULL的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score, score <span class="operator">/</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093054.png" alt="image-20210414093054312"></p><p>(2)查询选修编号为10028的课程的学生的人数，其中成绩合格的的学生人数，不合格的学生人数，讨论NULL值的特殊含义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(sid)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">-- 选修了课程号为10028的学生总人数6042</span></span><br><span class="line"><span class="comment">-- 其中及格的人数为4812</span></span><br><span class="line"><span class="comment">-- 其中不及格的人数为755</span></span><br><span class="line"><span class="comment">-- 其中成绩为NULL的人数为475</span></span><br><span class="line"><span class="comment">-- 如果将成绩为NULL视为不及格，则查询语句应如下：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(sid)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> (score <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line">    <span class="keyword">OR</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- 在CHOICES的定义中，score是可以取空值的，NULL&gt;=60和NULL&lt;60都不是TRUE</span></span><br></pre></td></tr></table></figure><p>(3)通过实验检验在使用ORDER BY进行排序时，取NULL的项是否出现在结果中？如果有，在什么位置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 实际测试中，取值为NULL的项会出现在结果中，升序(ASC)排序时在开头，降序(DESC)排序时在末尾</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093118.png" alt="image-20210414093118323"></p><p>(4)在上面的查询的过程中如果加上保留字DISTINCT会有什么效果呢</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 使用DISTINCT时，若查询项仅有一项，那么所有的NULL会被视为相同的值</span></span><br><span class="line"><span class="comment">-- 比如SELECT score时会罗列所有的NULL，而SELECT DISTINCT score仅罗列一个NULL</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093152.png" alt="image-20210414093152686"></p><p>(5)通过实验说明使用分组GROUP BY对取值为NULL的项的处理</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="string">&#x27;10028&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 可知GROUP BY中取NULL的被视为一个分组</span></span><br></pre></td></tr></table></figure><p>(6)结合分组，使用集合函数求每个同学的平均分，总的选课记录，最高成绩，最低成绩，总成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(cid) <span class="string">&#x27;COUNT-COURSE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(score) <span class="string">&#x27;SUM-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(score);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093516.png" alt="image-20210414093434674"></p><p>(7)查询成绩小于0的选课记录，统计总数，平均分，最大值和最小值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)   <span class="string">&#x27;COUNT-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-RECORD&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-RECORD&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414093928.png" alt="image-20210414093927972"></p><p>(8)采用嵌套查询的方式，利用比较运算符合谓词ALL的结合来查询表COURSES中最少的课时。<br>– 假设数据库中只有一个记录时，使用前面的方法会得到什么结果，为什么？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- (1)自己的想法</span></span><br><span class="line"><span class="comment">-- 数据库中只有一个记录时，若这个记录的hour不为空，则展示这个记录的hour；若hour为空，则返回空集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (2)书上的示例</span></span><br><span class="line"><span class="comment">-- 当只有一个记录时，逻辑上来说怎么都返回空集，但是DBS做了特殊处理？</span></span><br><span class="line"><span class="comment">-- hour值不为NULL时会返回这个记录；hour值为NULL时返回空集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES C1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">hour</span></span><br><span class="line">    <span class="keyword">FROM</span> COURSES C2</span><br><span class="line">    <span class="keyword">WHERE</span> C1.cid <span class="operator">!=</span> C2.cid</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立一个只有一个记录的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> C_TEMP</span><br><span class="line">(</span><br><span class="line">    CID  <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">HOUR</span> <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C_TEMP(CID, <span class="keyword">HOUR</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP</span><br><span class="line"><span class="keyword">WHERE</span> CID <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> C_TEMP(CID, <span class="keyword">HOUR</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;10001&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">-- (1)自己的思路</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">HOUR</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">HOUR</span></span><br><span class="line">    <span class="keyword">FROM</span> C_TEMP C2</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (2)书上的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> C_TEMP C1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">HOUR</span> <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">HOUR</span></span><br><span class="line">    <span class="keyword">FROM</span> C_TEMP C2</span><br><span class="line">    <span class="keyword">WHERE</span> C1.CID <span class="operator">!=</span> C2.CID</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(9)创建一个学生表S(NO, SID, SNAME)，教师表T(NO, TID, TNAME)作为实验用的表<br>– 其中，NO分别是这两个表的主键，其他键允许为空；NO为整型，其他字段为字符串型<br>– 向S中插入元组(1, ‘0129871001’, ‘王小明’),(2, ‘0129871002’, ‘李兰’),(3, ‘0129871005’, NULL),(4, ‘0129871004’, ‘关红’)<br>– 向T中插入元组(1, ‘100189’, ‘王小明’),(2, ‘100180’, 李小),(3, ‘100121’, NULL),(4, ‘100128’, NULL)<br>– 对这两个表作对姓名的等值连接运算，找出既是老师又是学生的人员的学生编号和教师编号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> S</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NO</span>    <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    SID   <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    SNAME <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">NO</span>    <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    TID   <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    TNAME <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> S(<span class="keyword">NO</span>, SID, SNAME)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;0129871001&#x27;</span>, N<span class="string">&#x27;王小明&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;0129871002&#x27;</span>, N<span class="string">&#x27;李兰&#x27;</span>),</span><br><span class="line">       (<span class="number">3</span>, <span class="string">&#x27;0129871005&#x27;</span>, <span class="keyword">NULL</span>),</span><br><span class="line">       (<span class="number">4</span>, <span class="string">&#x27;0129871004&#x27;</span>, N<span class="string">&#x27;关红&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T(<span class="keyword">NO</span>, TID, TNAME)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;100189&#x27;</span>, N<span class="string">&#x27;王小明&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;100180&#x27;</span>, N<span class="string">&#x27;李小&#x27;</span>),</span><br><span class="line">       (<span class="number">3</span>, <span class="string">&#x27;100121&#x27;</span>, <span class="keyword">NULL</span>),</span><br><span class="line">       (<span class="number">4</span>, <span class="string">&#x27;100128&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">SELECT</span> SNAME, SID, TID</span><br><span class="line"><span class="keyword">FROM</span> S,</span><br><span class="line">     T</span><br><span class="line"><span class="keyword">WHERE</span> S.SNAME <span class="operator">=</span> T.TNAME;</span><br><span class="line"><span class="comment">-- 等值连接使用的运算符是等号，NULL不得TRUE</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-SQL%E8%AF%AD%E8%A8%80/20210414094131.png" alt="image-20210414094131014"></p><h3 id="自我实践-5"><a href="#自我实践-5" class="headerlink" title="自我实践"></a>自我实践</h3><p>(1)查询所有课程记录的上课学时(数据库中为每星期学时)，以一个学期十八个星期计算每个课程的总学时，注意HOUR取NULL值的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, <span class="keyword">hour</span> <span class="operator">*</span> <span class="number">18</span> <span class="string">&#x27;ALL-HOUR&#x27;</span>, <span class="keyword">hour</span></span><br><span class="line"><span class="keyword">FROM</span> COURSES;</span><br></pre></td></tr></table></figure><p>(2)通过查询选修课程C++的学生的人数，其中成绩合格的学生人数，不合格的学生人数，讨论NULL值的特殊含义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>(3)查询选修课程C++的学生的编号和成绩，使用ORDER BY按成绩进行排序时，取NULL的项是否出现在结果中？如果有，在什么位置？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 会出现，视为最小值，升序开头，降序结尾</span></span><br></pre></td></tr></table></figure><p>(4)在上面的查询的过程中，如果加上保留字DISTINCT会有什么效果呢？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES,</span><br><span class="line">     COURSES</span><br><span class="line"><span class="keyword">WHERE</span> CHOICES.cid <span class="operator">=</span> COURSES.cid</span><br><span class="line">  <span class="keyword">AND</span> cname <span class="operator">=</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 由于查询的是“编号和成绩”，而不是单独的成绩，当且仅当两个元组的“编号”和“成绩”都相同(两个NULL视为相同)时，才会发生变化</span></span><br></pre></td></tr></table></figure><p>(5)按年级对所有的学生进行分组，能得到多少个组？与现实的情况有什么不同</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="string">&#x27;COUNT-PEOPLE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br><span class="line"><span class="comment">-- 能得到15个组，NULL的被视为了一组</span></span><br></pre></td></tr></table></figure><p>(6)结合分组，使用集合函数求每个课程选修的学生的平均分，总的选课记录数，最高成绩，最低成绩，讨论考察取空值的项对集合函数的作用的影响</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,</span><br><span class="line">       <span class="built_in">AVG</span>(score) <span class="string">&#x27;AVG-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>)   <span class="string">&#x27;COUNT-PEOPLE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MAX</span>(score) <span class="string">&#x27;MAX-SCORE&#x27;</span>,</span><br><span class="line">       <span class="built_in">MIN</span>(score) <span class="string">&#x27;MIN-SCORE&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br></pre></td></tr></table></figure><p>(7)采用嵌套查询的方式，利用比较运算符和谓词ALL的结合来查询表STUDENTS中最晚入学的学生年级。<br>– 当存在GRADE取空值的项时，考虑可能出现的情况，并解释原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 由于GRADE中存在空值，所以ALL中包含空值，任何一个grade&gt;=ALL都无法得到TRUE，所以得到的结果为空</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> grade</span><br><span class="line">    <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 对子查询中进行IS NOT NULL约束之后得到最晚的年级——2004</span></span><br></pre></td></tr></table></figure><p>(8)将操作步骤中的表的数据进行更新，<br>– 使得表S中，NO为2和3的记录的SID列取NULL值，<br>– T表的NO为4的记录的TID取NULL值，NO为3的TID取0129871005<br>– 然后，对这两个表按T.TID=S.SID作等值连接运算，找出编号相同的学生和教师的姓名，并分析原因</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> S</span><br><span class="line"><span class="keyword">SET</span> SID<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="keyword">IN</span> (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> TID <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> TID<span class="operator">=</span><span class="number">01298710005</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NO</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> S.SID, SNAME, TNAME</span><br><span class="line"><span class="keyword">FROM</span> S,</span><br><span class="line">     T</span><br><span class="line"><span class="keyword">WHERE</span> S.SID <span class="operator">=</span> T.TID</span><br><span class="line"><span class="comment">-- 查询结果为空集，因为等值连接的运算符是等号，对于NULL=NULL来说取值不为TRUE</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 数据库系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-第一章-计算机系统概述</title>
      <link href="2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容来自王道考研的《操作系统考研复习指导》实体书，以及王道的B站官号所上传的<a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统网课</a>。</p></blockquote><h2 id="操作系统的概念、功能和目标"><a href="#操作系统的概念、功能和目标" class="headerlink" title="操作系统的概念、功能和目标"></a>操作系统的概念、功能和目标</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328130119.png" alt="image-20210328130118951"></p><p>操作系统(Operating System, OS)：控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong></p><ul><li><p>操作系统的角色：</p><ol><li>作为系统资源的管理者</li><li>作为用户与计算机硬件之间的接口</li><li>作为最接近硬件的层次</li></ol></li><li><p>操作系统作为<strong>系统资源的管理者</strong>(这些资源包括软件、硬件、文件等)</p><ol><li>提供的功能：<ol><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ol></li><li>目标：安全、高效</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328131225.png" alt="系统资源管理者图解实例"></p><ul><li>操作系统作为<strong>用户与计算机硬件之间的接口</strong>，要为其上层的用户、应用程序提供简单易用的服务<ol><li>提供的功能：<ol><li>命令接口：允许用户<strong>直接</strong>使用<ol><li>联机命令接口——说一句做一句</li><li>脱机命令接口——说一堆做一堆</li></ol></li><li>程序接口：允许用户通过程序<strong>间接</strong>使用——系统调用</li><li>GUI(图形用户界面, Graphical User Interface)：现代操作系统中最流行的图形用户接口；用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令、参数</li></ol></li><li>目标：方便用户使用</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328132321.png" alt="image-20210328132321801"></p><ul><li>操作系统作为<strong>最接近硬件的层次</strong>，需要在纯硬件的基础上<ol><li>提供的功能和目标：实现对硬件机器的拓展</li></ol></li></ul><ol><li>裸机：没有任何软件支持的计算机<ol><li>在裸机上安装操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ol></li><li>扩充机器(虚拟机)：覆盖了软件的机器</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328133227.png" alt="image-20210328133227457"></p><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ul><li>操作系统的特征：其中并发和共享是两个<strong>最基本的特征</strong>，两者互为存在条件<ul><li>并发、共享、虚拟、异步</li></ul></li></ul><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><ul><li>并发：计算机系统中同时存在着多个运行着的程序<ul><li>并发：两个或多个事件在<strong>同一时间间隔内</strong>发生——宏观上同时发生，微观上交替发生</li><li>并行(与并发进行对比)：两个或多个事件在<strong>同一时刻同时</strong>发生</li></ul></li></ul><p>一个<strong>单核</strong>处理器(CPU)<strong>同一时刻只能执行一个程序</strong>，因此操作系统会负责协调多个程序交替执行(这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行)。事实上，操作系统就是伴随着<strong>多道程序技术</strong>出现的，因此，操作系统和程序并发是一起诞生的。即便现在的CPU大都是多核处理器，但是操作系统的并发性依然必不可少，因为计算机往往有高于核心数的程序需要同时工作，例如打开Windows的资源管理器，可以发现正在运行的程序/进程要远远多于CPU的核心数。</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><ul><li>共享：即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用<ul><li>互斥共享：虽然可以提供给多个进程使用，但是一个时间段内<strong>只允许一个进程</strong>访问该资源<ul><li>例如使用QQ和微信视频聊天——摄像头资源就是互斥资源，同一时间只能分配给一个进程，QQ和微信视频聊天</li></ul></li><li>同时共享：允许一个时间段内<strong>多个进程同时</strong>(宏观同时，微观交替进行，即<strong>微观分时共享</strong>)对它们进行访问<ul><li>例如使用QQ和微信发送文件——宏观上两者是同时读取并发送文件，微观上交替访问硬盘资源，此时的硬盘资源属于可以同时共享的系统资源</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328140650.png" alt="image-20210328140649972"></p><h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><ul><li><p>虚拟：把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)实际存在，逻辑上对应物(后者)是用户感受到的</p><ul><li>空分复用技术：如虚拟存储器技术</li><li>时分复用技术：如虚拟处理器技术</li></ul></li><li><p>背景知识：一个程序需要<strong>放入内存</strong>并<strong>分配CPU</strong>才能执行</p></li><li><p>假设同时运行多个程序，如GTA5(需4GB内存)、QQ(256MB)、网易云音乐(256MB)等(上述仅是举例，非实际内存要求)，而<strong>电脑内存假设只有4GB</strong>。那么这些程序同时运行需要的内存远大于4GB，为什么还可以在电脑上上同时运行：</p><ul><li>使用了<strong>虚拟存储器技术</strong>。实际只有4GB，但是在用户看来似乎远远大于4GB(虚拟技术中的“空分复用技术”)</li></ul></li><li><p>假设在某<strong>单核CPU的计算机</strong>中同时运行多个程序，既然一个程序需要被分配CPU才能正常执行，为什么单核CPU的电脑能同时运行多个程序：</p><ul><li>使用了<strong>虚拟处理器技术</strong>。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务(虚拟技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务)</li></ul></li></ul><p>显然：如果失去了并发性，那么一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性就谈不上虚拟性</strong></p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</p><p>当某个互斥系统资源需要被多个程序使用时，若这个资源被某个程序占用，其他程序需要使用这个资源时只能等待占用中的程序释放这个资源，即其他程序会进入阻塞状态，停顿下来，获得这个资源之后才可以再次进入执行状态</p><p>显然：如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。因此，<strong>系统只有拥有并发性，才有可能导致异步性</strong></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328143005.png" alt="image-20210328143005236"></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><ol><li>手工操作阶段<ol><li>缺点：用户独占全机、人机速度矛盾(CPU处理速度快，I/O慢，人工I/O更慢)——资源利用率极低</li></ol></li><li>单道批处理系统：引入<strong>脱机I/O技术</strong>(用磁带完成)，并由<strong>监督程序</strong>(操作系统的雏形)负责控制作业的输入输出<ol><li>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li>缺点：<ol><li>内存中仅能有<strong>一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序</li><li>CPU有大量的时间是在<strong>等待I/O</strong>完成(CPU处理速度快，I/O慢)</li><li>即资源利用率依然很低</li></ol></li></ol></li><li>多道批处理系统：每次往内存中输入多道程序，各个程序并发执行。<strong>操作系统正式诞生</strong>，并引入了中断技术，由操作系统负责管理这些程序的运行<ol><li>优点：<ol><li>多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。</li><li><strong>资源利用率大幅提升</strong>，CPU和其他资源保持“忙碌”状态(不同程序的I/O和计算阶段并发，无需等待某个程序彻底执行完毕)，系统吞吐量增大</li></ol></li><li>缺点：<ol><li>用户响应时间长，<strong>没有人机交互功能</strong>(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行)</li></ol></li></ol></li><li>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户/作业服务，各个用户可通过<strong>终端</strong>与计算机进行<strong>交互</strong><ol><li>优点：<ol><li>用户请求立可以被即使响应，<strong>解决了人机交互问题</strong></li><li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li></ol></li><li>缺点：不能优先处理一些紧急任务<ol><li>操作系统对各个用户/作业是完全公平的，循环地为每个用户/作业服务一个时间片，<strong>不区分任务的紧急性</strong></li></ol></li></ol></li><li>实时操作系统：计算机系统接收到外部信号后<strong>及时</strong>进行处理，并且要在<strong>严格的时限</strong>内处理完事件——及时性和可靠性<ol><li>分类：<ol><li>硬实时系统：必须在<strong>绝对严格的规定时间内</strong>完成处理——如导弹控制系统、自动驾驶系统</li><li>软实时系统：能接受<strong>偶尔违反</strong>时间规定——如12306火车订票系统</li></ol></li><li>优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队</li></ol></li><li>其他操作系统(了解即可)<ol><li>网络操作系统：伴随计算机网络的发展而诞生的操作系统，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信</strong>。(如Windows NT就是一个典型的网络操作系统，网站服务器就可以使用)</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong></li><li>个人计算机系统：如Win10、MacOS、Linux系统</li></ol></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328150044.png" alt="image-20210328150044425"></p><h2 id="操作系统的运行机制与体系结构"><a href="#操作系统的运行机制与体系结构" class="headerlink" title="操作系统的运行机制与体系结构"></a>操作系统的运行机制与体系结构</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328150431.png" alt="image-20210328150431061"></p><ul><li><p>指令：处理器(CPU)能够识别、执行的最基本命令</p><ul><li>特权指令：<strong>不允许用户程序使用</strong>；如内存清零指令</li><li>非特权指令：如普通的运算指令</li></ul></li><li><p>处理器状态：用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。例如以0为用户态，以1为核心态(仅是举例，非真正状态标识)</p><ul><li>核心态(管态)：<strong>特权指令</strong>、非特权指令都可执行</li><li>用户态(目态)：此时CPU只能执行非特权指令</li></ul></li><li><p>用户态与核心态的切换：(<strong>中断见下文的中断与异常</strong>)</p><ul><li>用户态–&gt;核心态：通过<strong>中断</strong>实现，并且<strong>中断是唯一途径</strong></li><li>核心态–&gt;用户态：通过<strong>执行一个个特权指令</strong>，将<strong>程序状态字(PSW)的标志位</strong>设置为用户态</li></ul></li><li><p>程序：</p><ul><li>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，<strong>运行在核心态</strong></li><li>应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328151508.png" alt="计算机系统的层次结构(操作系统划分)"></p><p>内核：计算机配置上的<strong>底层软件</strong>，是操作系统最基本、最核心的部分<br><strong>内核程序</strong>：实现操作系统内核功能的程序</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328151733.png" alt="操作系统的内核"></p><ul><li><p>操作系统的体系结构：</p><ul><li>微内核：只把<strong>最基本的功能</strong>保留在内核<ul><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li><li>举例：例如在“计算机系统的层次结构”示意图中，微内核可以是仅负责时钟管理、中断处理、原语这一层最基本功能的内核</li></ul></li><li>大内核：将操作系统的<strong>主要功能模块</strong>都作为系统内核，<strong>运行在核心态</strong><ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li><li>举例：例如在“计算机系统的层次结构”示意图中，大内核可以是不仅负责最基本功能那一层，还负责进程管理、存储器管理、设备管理等功能的内核</li></ul></li></ul></li><li><p>对于内核的类比</p><ul><li>内核：企业的管理层，负责一些重要的工作。只有<strong>管理层才能执行特权指令</strong>，普通员工只能执行非特权指令。用户态、核心态之间的<strong>状态切换</strong>相当于普通员工和管理层之间的<strong>工作交接</strong></li><li>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。<ul><li>优点：效率高——管理层处理大部分使，无需大量交接</li><li>缺点：组织混乱，难以维护——管理层分工不明确</li></ul></li><li>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。<ul><li>优点：组织结构清晰，方便维护——专人专事，遇到事件找特定的人即可</li><li>缺点：效率低——管理层和普通员工之间需要不断交接</li></ul></li></ul></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328153632.png" alt="image-20210328153632378"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>为了解决由于处理速度快、I/O速度慢而导致<strong>各程序只能串行执行的情况下，系统资源利用率低</strong>的问题，人们发明了操作系统作为计算机的管理者，引入<strong>中断机制</strong>，实现了多道程序的并发执行</p><ul><li>中断的特点：<ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol></li><li>发生了中断，就意味着需要操作系统的介入，开展管理工作(中断的<strong>本质</strong>)。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断</strong>可以使CPU从用户态转为核心态，<strong>使操作系统获得计算机的控制权</strong>。有了中断，才能实现多道程序并发执行</li></ul><blockquote><p>中断是用户态切换为核心态的唯一途径</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328155936.png" alt="中断的分类(一)"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328160106.png" alt="中断的分类(二)"></p><ul><li>外中断的处理：<ol><li>执行完每个指令之后，CPU都要检查当前是否有<strong>外部中断信号</strong></li><li>如果检测到外部中断信号，则需要<strong>保护被中断进程的CPU环境</strong>(如程序状态字PSW、程序计数器PC、各种通用寄存器)</li><li>根据<strong>中断信号类型</strong>转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol></li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328160656.png" alt="image-20210328160656578"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用：操作系统<strong>提供给应用程序(程序员/编程人员)使用的接口</strong>，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此<strong>系统调用的相关处理</strong>需要在<strong>核心态</strong>下进行</p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出请求服务请求，由操作系统代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328164331.png" alt="image-20210328164331282"></p><ol><li>普通应用程序：可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及<ol><li>涉及系统调用的库函数：如创建一个新文件、读写文件</li><li>不涉及系统调用的库函数：如取绝对值、算术运算</li></ol></li><li>编程语言：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便</li><li>操作系统：向上提供系统调用</li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328165724.png" alt="image-20210328165724300"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20210328171017.png" alt="image-20210328170440288"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Ubuntu Pastebin分享文本</title>
      <link href="2021/03/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/"/>
      <url>2021/03/14/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<ul><li>适用场景：<ul><li>接收方与发送方都可以联网；</li><li>单个文本内容较多且不想通过QQ、微信等方式发送文件<ul><li>至少我很不喜欢别人把一大串文本复制到聊天框再发送过来的情况</li><li>再比如Linux系统下，虽然有QQ、微信的民间移植版但不稳定</li></ul></li></ul></li></ul><blockquote><p>Ubuntu Pastebin网址：<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></p></blockquote><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p>This site is intended for use as a short-term exchange of pasted information between parties. All submitted data is considered public information. Submitted data is not guaranteed to be permanent, and may be removed at any time. Please do not set up programs to send data to this site in an automated fashion; it is intended to be used directly by humans.</p><blockquote><p>本网站旨在作为双方之间粘贴信息的短期交流。所有提交的数据都被视为公开信息。提交的数据不保证是永久性的，可以随时删除。请不要设置程序以自动方式将数据发送到此站点；它是供人类直接使用的。</p></blockquote><ul><li>优点：<ul><li>工具本身免费，使用这个网站分享再多内容都无需付费</li><li>操作方式简单，无任何反人类要求</li></ul></li><li>缺点：<ul><li>必须联网(但其他文本分享方式也基本都需要联网)，无法访问外网(相对于局域网)时无法使用</li><li>分享的文本内容所有人只要拥有这个链接就可以访问，即”公开信息”(但一般用这个网站也不会分享啥重要/隐私内容，个人建议仅临时分享代码)</li><li>一次只可以分享一个文件的内容，如果想分享一整个项目，还是老老实实把项目压缩成一个压缩包，然后用蓝奏云或者坚果云吧</li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>进入<a href="https://paste.ubuntu.com/">Ubuntu Pastebin</a>网站，依次填写或选择需要添加的内容：</p><ul><li>Poster：发送者的名字，此处不可为空，可以随意取个名字</li><li>Syntax：文本的格式，一般使用的时候都是代码文本，选择对应的代码名字即可，比如这里以**C++**为例</li><li>Expiration：有效期，这里的这个有效期是近似的有效期，并不是确定的时间，一般给别人发链接都是即发即用，为了不占用过多资源，选择最少的<strong>a day</strong>即可。</li><li>Content：文本内容，将需要发送的文本内容复制粘贴到此处即可。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/20210314212900.png" alt="填写信息"></p><p>发送完毕之后会自动进入如图所示页面，现在需要做的就是把网址拷贝下来发送给你想分享的人，这样他打开这个网址时看到的和你现在看到的是完全一致的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/%E4%BD%BF%E7%94%A8UbuntuPastebin%E5%88%86%E4%BA%AB%E6%96%87%E6%9C%AC/20210314213131.png" alt="发送之后的页面"></p><p>文本内容可以直接复制，也可以将其下载下来(选择下载的话需要登录Ubuntu)，我一般选择复制粘贴内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Ubuntu Pastebin是一个良心网站，适合轻量使用分享一个或几个文本文件；</li><li>如果有多文件需求可以考虑打包压缩之后使用蓝奏云；</li><li>如果有重度文件分享需求可以考虑使用坚果云等付费应用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装并使用WSL(Windows-Subsystem-Linux)</title>
      <link href="2021/03/13/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/"/>
      <url>2021/03/13/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>WSL官方文档：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></p></blockquote><h2 id="什么是WSL"><a href="#什么是WSL" class="headerlink" title="什么是WSL"></a>什么是WSL</h2><p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</p><ul><li>在 Microsoft Store 中选择你偏好的 GNU/Linux 分发版。</li><li>运行常用的命令行软件工具（例如 grep、sed、awk）或其他 ELF-64 二进制文件。</li><li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：<ul><li>工具：vim、emacs、tmux</li><li>语言：NodeJS、Javascript、Python、Ruby、C/ C++、C# 与 F#、Rust、Go 等。</li><li>服务：SSHD、MySQL、Apache、lighttpd、MongoDB、PostgreSQL。</li></ul></li><li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li><li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li><li>在 Windows 上调用 GNU/Linux 应用程序。</li></ul><p>按照我的理解，WSL本质上就是一个虚拟机(这样描述不准确)，但是相较于VMWare Workstation或者VirtualBox创建的虚拟机来说，它更兼容Windows，性能更好(特指WSL2)，但是不提供GUI界面，所以如果想使用带图形界面的Linux，还是老老实实双系统或者装一个正经的虚拟机吧。</p><blockquote><p>WSL和WSL2在本质上不是一个东西，但是鄙人才疏学浅，不是很明白其中的区别，所以本文中所有两者比较的观点都有很强的主观性，本人目前使用的是WSL2</p></blockquote><h2 id="启用WSL和虚拟机平台功能"><a href="#启用WSL和虚拟机平台功能" class="headerlink" title="启用WSL和虚拟机平台功能"></a>启用WSL和虚拟机平台功能</h2><ul><li>适用于Linux的Windows子系统：此功能必须开启</li><li>虚拟机平台：如果要使用WSL2的话，需开启此功能</li></ul><h3 id="方法一：在控制面板开启相应功能"><a href="#方法一：在控制面板开启相应功能" class="headerlink" title="方法一：在控制面板开启相应功能"></a>方法一：在控制面板开启相应功能</h3><p>Win+Q打开搜索框，输入”控制面板”以打开控制面板；在控制面板窗口点击”程序”，之后点击”启用或关闭Windows功能”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313202627.png" alt="控制面板"></p><p>在Windows功能页下拉到最下面，点击”适用于Linux的Windows子系统”和”虚拟机平台”后点击确定。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313202745.png" alt="开启相应功能"></p><p>在cmd下执行如下语句，若输出开端为如图所示，则说明WSL启用成功：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313203347.png" alt="wsl --help"></p><h3 id="方法二：在Powershell中开启相应功能"><a href="#方法二：在Powershell中开启相应功能" class="headerlink" title="方法二：在Powershell中开启相应功能"></a>方法二：在Powershell中开启相应功能</h3><p>以管理员身份打开Powershell并执行下述命令：(第一条是开启WSL，第二条是开启WSL2需要的虚拟机平台功能)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><blockquote><p>功能成功开启之后需要重启计算机！！！</p></blockquote><h2 id="升级到WSL2"><a href="#升级到WSL2" class="headerlink" title="升级到WSL2"></a>升级到WSL2</h2><p>WSL与WSL2的功能比较表如图所示，可以看出除了<strong>跨操作系统文件系统的性能</strong>外，WSL2体系结构在多个方面比WSL1更具优势，学习和使用Linux的情况下，<strong>如果没有必须在Linux中访问Windows文件系统的需求</strong>，使用WSL2都是更好的选择，且WSL2的性能更好并提供100%的系统调用兼容性。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313205148.png" alt="image-20210313205148537"></p><p>下载并安装<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于x64计算机的WSL2Linux内核更新包</a>，安装时会提示你提供提升的权限，选择”是”以批准此安装。</p><p>安装完成之后，在cmd执行如下语句，将WSL2设置为默认版本：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="安装Linux发行版"><a href="#安装Linux发行版" class="headerlink" title="安装Linux发行版"></a>安装Linux发行版</h2><p>打开<a href="https://aka.ms/wslstore">Microsoft Store</a>，选择偏好的Linux发行版。这里列出的并不是所有的可用的Linux发行版，不满足于这几个发行版可以前去查看WSL官方文档，此处我使用的是<a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Ubuntu 20.04 LTS</a>。</p><p>首次启动新安装的Linux发行版时，将打开一个控制台窗口，系统会要求等待一段时间，以便文件解压缩并存储到电脑上，未来的启动时间会很快。</p><p>新安装的Linux发行版会要求创建用户账户(非root)和密码，此用户名和密码拥有以下属性：</p><ul><li>此用户名和密码特定于安装的每个单独的 Linux 分发版，与 Windows 用户名无关。</li><li>创建用户名和密码后，该帐户将是分发版的默认用户，并将在启动时自动登录。</li><li>此帐户将被视为 Linux 管理员，能够运行 sudo (Super User Do) 管理命令。</li><li>在适用于 Linux 的 Windows 子系统上运行的每个 Linux 分发版都有其自身的 Linux 用户帐户和密码。 每当添加分发版、重新安装或重置时，都必须配置一个 Linux 用户帐户。</li></ul><p>安装结束后的Ubuntu 20.04 LTS窗口如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313205035.png" alt="image-20210313205035743"></p><p>在此窗口下使用”exit”可以退出窗口，但是WSL会在后台运行，彻底关闭的方式是在Powershell下使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>查询wsl运行状态需使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl --list -verbose # 完整命令</span><br><span class="line">wsl -l -v           # 简写</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210213.png" alt="image-20210313210213095"></p><h2 id="通过其他方式登录到WSL"><a href="#通过其他方式登录到WSL" class="headerlink" title="通过其他方式登录到WSL"></a>通过其他方式登录到WSL</h2><p>如果觉着Ubuntu的默认终端窗口有些丑的话，可以使用其他方式登录到WSL(其实就是我自己习惯下面这俩工具了)。</p><h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p>在Windows Terminal窗口点击如图所示位置可以直接进入WSL(需等待其启动)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210406.png" alt="image-20210313210406062"></p><p>在Windows Terminal窗口下输入wsl也可直接进入：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313210810.png" alt="image-20210313210810636"></p><p>需要注意的是，这两种方式进入WSL的默认路径都不是**/home/username<strong>，而是Windows系统的用户文件夹的挂载位置</strong>/mnt/c/Users/username**，执行操作时需注意。</p><h3 id="VS-Code-Remote-WSL"><a href="#VS-Code-Remote-WSL" class="headerlink" title="VS Code - Remote WSL"></a>VS Code - Remote WSL</h3><p>安装Remote WSL插件，在插件栏搜索即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313211202.png" alt="image-20210313211201935"></p><p>安装好之后侧边栏会多出一个”远程资源管理器图标”，点击之后选择”WSL Targets”，在点击如图所示位置(会自动搜寻本机中拥有的WSL主机)，就可以在VS Code中访问WSL了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8WSL(Windows-Subsystem-Linux)/20210313211259.png" alt="image-20210313211259502"></p><h2 id="配置Ubuntu"><a href="#配置Ubuntu" class="headerlink" title="配置Ubuntu"></a>配置Ubuntu</h2><h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><p>初始镜像源是官方源，在国内访问会比较慢，我之前用的是清华源，结果install gcc的时候提示有个包找不到，所以就换成华为源了。</p><p>如果之前没有换过镜像源，那么可以直接使用下列命令进行换源(第一条是备份，第二条是换源)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i <span class="string">&quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">&quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>如果之前换过源了，可以将下列内容保存为”/etc/apt/sources.list”(以免被说夹带私货，sources.list里的内容我一点都没删，完全是上述指令使用之后的结果)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># See http:&#x2F;&#x2F;help.ubuntu.com&#x2F;community&#x2F;UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal universe</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to use the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide useful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#39;s</span><br><span class="line">## &#39;partner&#39; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu users.</span><br><span class="line"># deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu focal partner</span><br><span class="line"># deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu focal partner</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security universe</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;ubuntu&#x2F; focal-security multiverse</span><br></pre></td></tr></table></figure><p>换好源之后update、upgrade一下，舒服多了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell是否更换视自己习惯而定，我主要是喜欢zsh的补全功能，然后习惯用ohmyzsh的主题了(我知道ohmyzsh在资源占用方面好像有诟病，但日常使用区别并不大)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh -y   <span class="comment">#安装zsh</span></span><br><span class="line">chsh -s /bin/zsh username <span class="comment">#修改用户的默认终端为zsh</span></span><br><span class="line"><span class="comment">#下载并安装 oh-my-zsh</span></span><br><span class="line">wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><p>修改”/home/username/.zshrc”中的ZSH_THEME为”duellj”：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;duellj&quot;</span><br></pre></td></tr></table></figure><p>在.zshrc文件末尾追加如下内容，这样就不会出现末尾的空行显示成%的情况了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 去除末尾的百分号</span><br><span class="line">setopt PROMPT_CR</span><br><span class="line">setopt PROMPT_SP</span><br><span class="line">export PROMPT_EOL_MARK&#x3D;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数记录</title>
      <link href="2021/02/21/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/21/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用来记录使用Python的过程中遇到的一些函数用法，以免以后再次遇到的时候又忘掉需要现找</p></blockquote><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h4 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h4><p>返回表示当前工作目录的字符串</p><h4 id="os-listdir-path-’-’"><a href="#os-listdir-path-’-’" class="headerlink" title="os.listdir(path=’.’)"></a>os.listdir(path=’.’)</h4><p>返回一个列表，包含path中所有文件与目录的名称，按任意顺序排列</p><h4 id="os-mkdir-path"><a href="#os-mkdir-path" class="headerlink" title="os.mkdir(path)"></a>os.mkdir(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(path, mode=<span class="number">0o777</span>, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>创建一个名为path的目录，如果目录已经存在则会抛出FileExistsError异常</p><h4 id="os-makedirs-path"><a href="#os-makedirs-path" class="headerlink" title="os.makedirs(path)"></a>os.makedirs(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(path, mode=<span class="number">0o777</span>, exist_ok=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>递归目录创建函数，自动创建到达最后一级目录所需要的中间目录</p><h4 id="os-remove-path"><a href="#os-remove-path" class="headerlink" title="os.remove(path)"></a>os.remove(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(path, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>移除(删除)文件path。如果path是目录，则抛出IsADirectoryError异常</p><h4 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path)"></a>os.rmdir(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir(path, *, dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>移除(删除)目录path。如果目录不存在则抛出FileNotFoundError异常，若目录不为空则抛出OSError异常。</p><blockquote><p>删除非空目录需要使用shutil.rmtree(src)函数</p></blockquote><h4 id="os-rename-src-dst"><a href="#os-rename-src-dst" class="headerlink" title="os.rename(src, dst)"></a>os.rename(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(src, dst, *, src_dir_fd=<span class="literal">None</span>, dst_dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将文件或目录src重命名为dst，如果dst已存在，则操作失败并抛出OSError子类异常(Windows下抛出FileExistsError异常)。</p><h4 id="os-replace-src-dst"><a href="#os-replace-src-dst" class="headerlink" title="os.replace(src, dst)"></a>os.replace(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.replace(src, dst, *, src_dir_fd=<span class="literal">None</span>, dst_dir_fd=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将文件或目录src重命名为dst。如果dst是目录，将抛出OSError异常。如果dst已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。</p><h4 id="os-walk-top"><a href="#os-walk-top" class="headerlink" title="os.walk(top)"></a>os.walk(top)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># os.walk的经典用法：对以root_path为根的每个目录进行遍历</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(root_path):</span><br><span class="line">    <span class="keyword">for</span> dir_name <span class="keyword">in</span> dirs:</span><br><span class="line">        dir_path = os.path.join(root, dir_name)</span><br><span class="line">        <span class="comment"># 只将空文件夹填入all_path，非空文件夹会由内部文件路径填入all_path</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.listdir(dir_path):</span><br><span class="line">            all_path.append(dir_path)</span><br><span class="line">    <span class="keyword">for</span> basename <span class="keyword">in</span> files:</span><br><span class="line">        all_path.append(os.path.join(root, basename))</span><br></pre></td></tr></table></figure><p>生成目录树中的文件名，方式是自上而下或自下而上浏览目录树。对于以top为根的目录树中的每个目录(包括top本身)，都会生成一个三元组(dirpath, dirnames, filenames)</p><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><h4 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path)"></a>os.path.abspath(path)</h4><p>返回路径path的绝对路径(标准化的)</p><h4 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h4><p>返回路径path的基本名称(文件名)</p><p>例如“C:/dir1/dir2/filename”返回“filename”</p><h4 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h4><p>返回路径path的目录名称(路径名称)</p><p>例如“C:/dir1/dir2/filename”返回“C:/dir1/dir2”</p><h4 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path)"></a>os.path.exists(path)</h4><p>如果路径path指向一个已存在的路径或已打开的文件描述符，返回True；对于失效的符号链接，返回False。</p><p>基本上可以理解为路径path若存在则返回True，否则返回False</p><h4 id="os-path-isabs-path"><a href="#os-path-isabs-path" class="headerlink" title="os.path.isabs(path)"></a>os.path.isabs(path)</h4><p>如果路径path是一个绝对路径，则返回True</p><h4 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path)"></a>os.path.isfile(path)</h4><p>如果路径path是一个现有的常规文件，则返回True</p><h4 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path)"></a>os.path.isdir(path)</h4><p>如果路径path是一个现有的目录(文件夹)，则返回True</p><h4 id="os-path-join-path-paths"><a href="#os-path-join-path-paths" class="headerlink" title="os.path.join(path, *paths)"></a>os.path.join(path, *paths)</h4><p>合理地拼接一个或多个路径部分，拼接部分使用os.sep(目录分隔符)连接。</p><p>例如拼接目录和文件名：os.path.join(“C:/dir1”, “filename”)的结果是”C:/dir1/dilename”</p><h4 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path)"></a>os.path.split(path)</h4><p>将路径path拆分为一对，即(head, tail)，可以理解为head=os.path.dirname(path) tail=os.path.basename(path)；os.path.join(head, tail)=path</p><p>os.path.split(path)的返回值是tuple(元组)类型</p><h4 id="os-path-splitext-path"><a href="#os-path-splitext-path" class="headerlink" title="os.path.splitext(path)"></a>os.path.splitext(path)</h4><p>将路径path拆分为一对，即(root, ext)，使root+ext==path，其中ext为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如splitext(‘.cshrc’)返回(‘.cshrc’, ‘’)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root, ext = os.path.splitext(path)</span><br></pre></td></tr></table></figure><h2 id="Zipfile"><a href="#Zipfile" class="headerlink" title="Zipfile"></a>Zipfile</h2><h3 id="zipfile-ZipFile"><a href="#zipfile-ZipFile" class="headerlink" title="zipfile.ZipFile"></a>zipfile.ZipFile</h3><h4 id="zipfile-ZipFile-file-mode-’r’"><a href="#zipfile-ZipFile-file-mode-’r’" class="headerlink" title="zipfile.ZipFile(file, mode=’r’)"></a>zipfile.ZipFile(file, mode=’r’)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zipfile.ZipFile(file, mode=<span class="string">&#x27;r&#x27;</span>, compression=ZIP_STORED, allowZip64=<span class="literal">True</span>, compresslevel=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>打开一个ZIP文件，file是指向文件的路径(字符串)，“r”是读取这个ZIP文件，“w”是写入这个ZIP文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(filepath, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="keyword">as</span> zipfile_example:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="zipfile-ZipFile-write"><a href="#zipfile-ZipFile-write" class="headerlink" title="zipfile.ZipFile.write"></a>zipfile.ZipFile.write</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zipfile.ZipFile.write(filename, arcname=<span class="literal">None</span>, compress_type=<span class="literal">None</span>, compresslevel=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将名为filename的文件写入归档，给予的归档名为arcname。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dirname = os.path.dirname(filename)</span><br><span class="line">zipfile.ZipFile.write(filename, filename.replace(dirname, <span class="string">&#x27;&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="OpenCC"><a href="#OpenCC" class="headerlink" title="OpenCC"></a>OpenCC</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install OpenCC</span><br></pre></td></tr></table></figure><h3 id="基础用法-opencc"><a href="#基础用法-opencc" class="headerlink" title="基础用法 - opencc"></a>基础用法 - opencc</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line">converter = opencc.OpenCC(<span class="string">&#x27;t2s.json&#x27;</span>)</span><br><span class="line">converter.convert(<span class="string">&#x27;漢字&#x27;</span>) <span class="comment"># 汉字</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-opencc"><a href="#配置文件-opencc" class="headerlink" title="配置文件 - opencc"></a>配置文件 - opencc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s2t.json - Simplified Chinese to Traditional Chinese - 简-&gt;繁</span><br><span class="line">t2s.json - Traditional Chinese to Simplified Chinese - 繁-&gt;简</span><br><span class="line">s2tw.json - Simplified Chinese to Traditional Chinese (Taiwan Standard) - 简-&gt;繁(台湾)</span><br><span class="line">tw2s.json - Traditional Chinese (Taiwan Standard) to Simplified Chinese - 繁(台湾)-&gt;简</span><br><span class="line">s2hk.json -  Simplified Chinese to Traditional Chinese (Hong Kong variant) - 简-&gt;繁(香港)</span><br><span class="line">hk2s.json - Traditional Chinese (Hong Kong variant) to Simplified Chinese - 繁(香港)-&gt;简</span><br></pre></td></tr></table></figure><h2 id="Hashlib"><a href="#Hashlib" class="headerlink" title="Hashlib"></a>Hashlib</h2><h3 id="基础用法-hashlib"><a href="#基础用法-hashlib" class="headerlink" title="基础用法 - hashlib"></a>基础用法 - hashlib</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">m = hashlib.sha256()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(src_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src:</span><br><span class="line">  src_data = src.read(<span class="number">2048</span>)</span><br><span class="line">  <span class="keyword">while</span> src_data:</span><br><span class="line">    m.update(src_data)</span><br><span class="line">    src_data = src.read(<span class="number">2048</span>)</span><br><span class="line">hash_result = m.hexdigest() </span><br></pre></td></tr></table></figure><h3 id="函数说明-hashlib"><a href="#函数说明-hashlib" class="headerlink" title="函数说明 - hashlib"></a>函数说明 - hashlib</h3><h4 id="hashlib-sha256"><a href="#hashlib-sha256" class="headerlink" title="hashlib.sha256()"></a>hashlib.sha256()</h4><p>选取hash校验类型，常用的有hashlib.md5()、hashlib.sha256()、hashlib.sha512()等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = hashlib.sha256()  <span class="comment"># m是一个实例</span></span><br></pre></td></tr></table></figure><h4 id="m-update-data"><a href="#m-update-data" class="headerlink" title="m.update(data)"></a>m.update(data)</h4><p>使用data更新hash校验，data需要是二进制字节，不支持字符串对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m.update(<span class="string">b&#x27;Hello World!&#x27;</span>) <span class="comment"># 字符串转化为二进制字节</span></span><br></pre></td></tr></table></figure><p>重复调用相当于单词调用并传入所有参数的拼接结果，即：<br>m.update(a);m.update(b)等价于m.update(a+b)</p><h4 id="m-hexdigest"><a href="#m-hexdigest" class="headerlink" title="m.hexdigest()"></a>m.hexdigest()</h4><p>返回当前已传给update()方法的数据摘要，以两倍长度字符串对象的形式返回，仅包含十六进制数码。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h3><table><thead><tr><th>mode</th><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>读取模式</td><td>打开的文件不存在则抛出FileNotFoundError异常</td></tr><tr><td>w</td><td>写入模式</td><td>打开的文件不存在则自动新建；存在则先清空</td></tr><tr><td>x</td><td>新建模式</td><td>打开的文件存在则抛出FileExistsError异常</td></tr><tr><td>a</td><td>追加模式</td><td>打开的文件不存在则自动新建；在文件尾部追加内容</td></tr><tr><td>+</td><td>读写模式</td><td>在模式中附带’+’将允许同时读取和写入</td></tr><tr><td>b</td><td>二进制模式</td><td>在模式中附带’b’代表此次的读/写以二进制形式进行</td></tr></tbody></table><h3 id="基础用法-io"><a href="#基础用法-io" class="headerlink" title="基础用法 - io"></a>基础用法 - io</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(src_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> src:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="io-open"><a href="#io-open" class="headerlink" title="io.open()"></a>io.open()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.<span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li>file - 文件名</li><li>mode - 读写模式</li><li>encoding - 编码类型<ul><li>encoding = ‘utf-8’</li><li>encoding = ‘gbk’</li><li>encoding = ‘unicode’</li></ul></li></ul><blockquote><p>下面的<strong>file</strong>前缀指open()出来的对象</p></blockquote><h4 id="file-read-size-1"><a href="#file-read-size-1" class="headerlink" title="file.read(size=-1)"></a>file.read(size=-1)</h4><p>从流中读取并返回最多size个字节，若未指定size则将读取到EOF</p><h4 id="file-readline-size-1"><a href="#file-readline-size-1" class="headerlink" title="file.readline(size=-1)"></a>file.readline(size=-1)</h4><p>从流中读取并返回一行，如果指定了size，将至多读取size个字节</p><h4 id="file-readlines-hint-1"><a href="#file-readlines-hint-1" class="headerlink" title="file.readlines(hint=-1)"></a>file.readlines(hint=-1)</h4><p>从流中读取并返回多行的列表，如果指定了hint，将至多读取hint行</p><h4 id="file-write-str"><a href="#file-write-str" class="headerlink" title="file.write(str)"></a>file.write(str)</h4><p>将str字符串写入到file中</p><h4 id="file-writelines-list"><a href="#file-writelines-list" class="headerlink" title="file.writelines(list)"></a>file.writelines(list)</h4><p>将list列表逐个写入到file中</p><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><h3 id="基础用法-urllib-parse"><a href="#基础用法-urllib-parse" class="headerlink" title="基础用法 - urllib.parse"></a>基础用法 - urllib.parse</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> parse</span><br><span class="line">target_str = parse.quote(src_str) <span class="comment"># 字符串中的特殊字符转义</span></span><br><span class="line">src_str = parse.unquote(target_str) <span class="comment"># 转义回特殊字符</span></span><br></pre></td></tr></table></figure><h3 id="urllib-parse"><a href="#urllib-parse" class="headerlink" title="urllib.parse"></a>urllib.parse</h3><h4 id="urllib-parse-quote-string"><a href="#urllib-parse-quote-string" class="headerlink" title="urllib.parse.quote(string)"></a>urllib.parse.quote(string)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.parse.quote(string, safe=<span class="string">&#x27;/&#x27;</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>把字符串string进行转义，除了A-Z、a-z、0-1、’/‘等都需要转义</p><h4 id="urllib-parse-unquote-string"><a href="#urllib-parse-unquote-string" class="headerlink" title="urllib.parse.unquote(string)"></a>urllib.parse.unquote(string)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.parse.unquote(string, encoding=<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;replace&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Replace %xx escapes by their single-character equivalent.</p><p>把转义过的字符转义回原来的字符</p><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><h3 id="基础用法-shutil"><a href="#基础用法-shutil" class="headerlink" title="基础用法 - shutil"></a>基础用法 - shutil</h3><h4 id="shutil-copy-src-dst"><a href="#shutil-copy-src-dst" class="headerlink" title="shutil.copy(src, dst)"></a>shutil.copy(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst, *, follow_symlinks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>将文件src拷贝到文件或目录dst。src和dst应为字符串。如果dst指定了一个目录，文件将使用src中的基准文件名拷贝到dst。返回新创建文件所对应的路径。</p><p>copy()会拷贝文件数据和文件的权限模式(参见os.chmod())。其他元数据，例如文件的创建和修改时间不会被保留。要保留所有原有的元数据，改用copy2()。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如 - 将path_src保存到path_dst，重命名为_config.yml</span></span><br><span class="line">path_src = <span class="string">r&#x27;_config.butterfly.yml&#x27;</span></span><br><span class="line">path_dst = <span class="string">r&#x27;C:/Users/LeoK77/Desktop/_config.yml&#x27;</span></span><br><span class="line">shutil.copy(path_src, path_dst)</span><br><span class="line"><span class="comment"># 例如 - 将path_src保存到path_dst目录下，保存为path_dst/_config.butterfly.yml</span></span><br><span class="line">path_src = <span class="string">r&#x27;_config.butterfly.yml&#x27;</span></span><br><span class="line">path_dst = <span class="string">r&#x27;C:/Users/LeoK77/Desktop&#x27;</span></span><br><span class="line">shutil.copy(path_src, path_dst)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Python%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/20210305100958.png" alt="image-20210305100957939"></p><h4 id="shutil-copy2-src-dst"><a href="#shutil-copy2-src-dst" class="headerlink" title="shutil.copy2(src, dst)"></a>shutil.copy2(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copy2(src, dst, *, follow_symlinks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>类似于shutil.copy()，但是会尝试尽量保留所有元数据</p><h4 id="shutil-copytree-src-dst"><a href="#shutil-copytree-src-dst" class="headerlink" title="shutil.copytree(src, dst)"></a>shutil.copytree(src, dst)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2, ignore_dangling_symlinks=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>递归拷贝以src为根路径的整个目录树，返回目标目录。名为dst的目标目录不必已存在；它本身和还不存在的父目录都将被自动创建。</p><p>目录的权限和时间信息将通过copystat()来拷贝，单独的文件将使用shutil.copy2()来拷贝。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exception shutil.Error</span><br><span class="line"><span class="comment"># copytree引发的异常是一个三元组 —— (srcname, dstname, exception)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个ignore示例(建议用ignore_patterns()函数，见下一项)</span></span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span>(<span class="params">path, names</span>):</span></span><br><span class="line">    logging.info(<span class="string">&#x27;Working in %s&#x27;</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h4 id="shutil-ignore-patterns-patterns"><a href="#shutil-ignore-patterns-patterns" class="headerlink" title="shutil.ignore_patterns(*patterns)"></a>shutil.ignore_patterns(*patterns)</h4><p>这是一个工厂函数，被用作copytree()的ignore可调用对象参数，以忽略那些所提供的glob风格的patterns之一的文件和目录。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">&#x27;*.pyc&#x27;</span>, <span class="string">&#x27;tmp*&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="shutil-rmtree-path"><a href="#shutil-rmtree-path" class="headerlink" title="shutil.rmtree(path)"></a>shutil.rmtree(path)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>删除一个完整的目录树；path必须指向一个目录（但不能是一个目录的符号链接）。 如果ignore_errors为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由onerror所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p><blockquote><p>删除单个文件需要使用os.remove(path)，删除空目录可以使用os.rmdir(path)</p></blockquote><h4 id="shutil-move-src-dst-copy-function-copy2"><a href="#shutil-move-src-dst-copy-function-copy2" class="headerlink" title="shutil.move(src, dst, copy_function=copy2)"></a>shutil.move(src, dst, copy_function=copy2)</h4><p>递归地将一个文件或目录(src)移动到另一个位置(dst)并返回目标位置</p><p>如果目标是已存在的目录，则src会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于os.rename()的语义。</p>]]></content>
      
      
      <categories>
          
          <category> Python学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+GitHubPages搭建个人博客</title>
      <link href="2021/02/09/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/02/09/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown(或其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。搭配GitHub Pages服务可以获得专属的个人博客。</p><p>以下内容以Win10系统为例：</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>安装Node.js可以直接安装本体，也可以使用nvs、nvm等工具进行多版本管理，这里我使用的是Hexo推荐的nvs进行版本管理。</p><p>nvs的安装请参照其官网教程，这里只给出使用方法。</p><blockquote><p>nvs官网：<a href="https://github.com/jasongin/nvs">https://GitHub.com/jasongin/nvs</a></p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nvs       #如果有输出则说明已经可用，按ESC退出</span><br><span class="line">#如果裸连node的官方库速度不慢，那么就不添加华为镜像源源</span><br><span class="line">nvs remote node-huawei https://repo.huaweicloud.com/nodejs/ #添加华为云镜像源到nvs中</span><br><span class="line">nvs       #运行nvs，选择“Download another version”，找到你刚才添加的“node-huawei”，然后选择版本</span><br><span class="line">#推荐安装Node12的最新版，因为使用Node14的时候可能搭配一些主题会报Warning，虽然影响不大，但是看着心里不舒服</span><br><span class="line">nvs ls    #列出安装的版本</span><br><span class="line">#找到你刚才安装的node12版本，复制完整名字(我这里以在华为源下载的Node12为例)</span><br><span class="line">nvs link node-huawei/<span class="number">12</span>.<span class="number">20</span>.<span class="number">1</span>/x64  #将Node12设置为默认版本</span><br><span class="line">nvs use node-huawei/<span class="number">12</span>.<span class="number">20</span>.<span class="number">1</span>/x64   #启用Node12</span><br></pre></td></tr></table></figure><p>设置Node.js12为默认环境：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105626.png" alt="image-20210209102532992"></p><p>“node/14.15.4/x64 (Fermium)”运行Hexo(使用主题Butterfly)时报的warning如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105629.png" alt="image-20210209100524704"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/  #设置为华为云仓库镜像源</span><br><span class="line">npm config list     #查看设置是否成功</span><br><span class="line">npm i hexo-cli -g   #全局安装hexo</span><br></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><blockquote><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105632.png" alt="image-20210209104714570"></p><p>如果访问官网的下载速度过慢，可以从各大镜像网站下载，比如华为开源镜像站：</p><blockquote><p>华为开源镜像站 Git for Windows ：<a href="https://repo.huaweicloud.com/git-for-windows/">https://repo.huaweicloud.com/git-for-windows/</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209105635.png" alt="image-20210209105002268"></p><p>安装步骤不做演示。</p><h2 id="本地搭建Hexo博客"><a href="#本地搭建Hexo博客" class="headerlink" title="本地搭建Hexo博客"></a>本地搭建Hexo博客</h2><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>新建一个文件夹来作为你的本地Hexo博客，你的所有Hexo博客内容都应该存放在这个文件夹中。</p><p>比如我新建了一个名为“Hexo-Test”的文件夹，那么我的所有博客内容都在这个文件夹里。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110110.png" alt="image-20210209110110769"></p><p>打开Windows终端，通过“cd”指令到达这个文件夹；或者在这个文件夹中摁着SHIFT再右键，选择“在此处打开PowerShell窗口”。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init   #初始化Hexo博客，这个文件夹需要是空文件夹</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110643.png" alt="image-20210209110643678"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install  # 安装依赖</span><br><span class="line">hexo s       #本地运行hexo博客</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110809.png" alt="image-20210209110809527"></p><p>如图所示，本地访问端口是<a href="http://localhost:4000/">http://localhost:4000</a>，运行时在浏览器打开这个网址，就可以查看Hexo博客了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209110928.png" alt="image-20210209110927913"></p><h3 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h3><p>以下仅列出几个我认为有必要改的_config.yml文件中的内容：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span>       <span class="comment">#博客标题</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment">#博客作者，改成自己名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span>      <span class="comment">#博客语言，中文是 zh-CN</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://leok77.github.io</span>   <span class="comment">#你要发布到哪儿，比如我用GitHubPages，就是这个网址，把“leok77”修改为你的用户名即可</span></span><br><span class="line"><span class="comment"># THEME</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>  <span class="comment">#这个是默认主题，可以自己换个好看/高效的主题</span></span><br></pre></td></tr></table></figure><h3 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h3><h4 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h4><blockquote><p>GitHub：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a><br>主题首页：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p></blockquote><p>美化效果很好的一个主题，功能集成也比较完善，我现在使用的就是这个主题(然而我追求简洁又懒，所以把绚丽的动画效果都关了)，主题首页有相应的配置教程，真的是“手把手”教你怎么把这个主题配置好，总之就是非常棒。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112138.png" alt="image-20210209112137677"></p><p>我在使用的时候是将配置文件另存到了博客根目录，这样在升级主题的时候就不需要担心自己的配置文件被默认文件覆盖了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210321101154.png" alt="image-20210321101153977"></p><h5 id="适用于Butterfly的繁体转换脚本"><a href="#适用于Butterfly的繁体转换脚本" class="headerlink" title="适用于Butterfly的繁体转换脚本"></a>适用于Butterfly的繁体转换脚本</h5><p>因为Butterfly的配置文件默认是繁体字，而我使用简体字，所以我需要将其转换为简体字之后才可以更好的阅读和使用，这里用的是开源的openCC库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> opencc <span class="keyword">import</span> OpenCC  <span class="comment"># opencc开源简繁转换</span></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> path_analysis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tradition_to_simple</span>(<span class="params">filename=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># 转换为绝对路径</span></span><br><span class="line">    abspath_src = os.path.abspath(filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! FILE ** &#x27;</span> + abspath_src + <span class="string">&#x27; ** NOT EXIST&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    abspath_dst = path_analysis.get_abspath_dst(abspath_src)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式是繁体转化为简体</span></span><br><span class="line">    converter = OpenCC(<span class="string">&#x27;t2s.json&#x27;</span>)</span><br><span class="line">    <span class="comment"># 逐行转化并写入到目标文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(abspath_dst, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> dst:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath_src, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> src:</span><br><span class="line">            <span class="keyword">for</span> sentence <span class="keyword">in</span> src:</span><br><span class="line">                dst.write(converter.convert(sentence))</span><br><span class="line"></span><br><span class="line">    path_analysis.replace_or_not(abspath_src, abspath_dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Hexo主题Butterfly配置文件简体化</span></span><br><span class="line">    <span class="comment"># 主题本身默认配置文件路径：&quot;博客文件夹/node_mpdules/hexo-theme-butterfly/_config.yml&quot;</span></span><br><span class="line">    filename =  <span class="string">r&#x27;C:\Users\LeoK77\Documents\WorkSpace\Blog-Hexo-LeoK77\node_modules\hexo-theme-butterfly\_config.yml&#x27;</span></span><br><span class="line">    tradition_to_simple(filename)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Matery"><a href="#Matery" class="headerlink" title="Matery"></a>Matery</h4><blockquote><p>GitHub：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a><br>主题首页：<a href="https://blinkfox.github.io/">https://blinkfox.github.io/</a></p></blockquote><p>美化效果好，有较为详细的教程，但是我没弄明白那个头部的“彩虹换色”怎么关，导致我放的壁纸在动态换色下显得特别呆，所以就没继续用这个主题。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112507.png" alt="image-20210209112507105"></p><h4 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h4><blockquote><p>GitHub：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a><br>主题旧版首页：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a><br>主题首页：<a href="https://theme-next.org/">https://theme-next.org/</a></p></blockquote><p>如果你去搜Hexo的教程或者视频，那么他们推荐的主题很可能就是NexT，这是一个十分简约的主题，但是提供极多的插件，这也就意味着高度定制性，你只需要安装你想要的功能，无论是简约还是绚丽美化，NexT都可以做到。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209112730.png" alt="image-20210209112730265"></p><h2 id="推送Hexo博客到GitHub"><a href="#推送Hexo博客到GitHub" class="headerlink" title="推送Hexo博客到GitHub"></a>推送Hexo博客到GitHub</h2><h3 id="新建GitHub库"><a href="#新建GitHub库" class="headerlink" title="新建GitHub库"></a>新建GitHub库</h3><p>需要在自己的GitHub中新建一个“username.github.io”的public仓库，比如我的用户名是leok77，那么我的仓库是“leok77.github.io”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210209113852.png" alt="image-20210209113852130"></p><h3 id="推送到GitHub"><a href="#推送到GitHub" class="headerlink" title="推送到GitHub"></a>推送到GitHub</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git --save    #安装hexo-deployer-git插件</span><br></pre></td></tr></table></figure><p>配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span>     <span class="comment">#方式</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#分支 - 都呼吁分支名改为 main</span></span><br><span class="line">  <span class="comment">#同时推送到多个仓库</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://gitee.com/username/username.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>推送到GitHub：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean    #清除旧内容</span><br><span class="line">hexo g        #创建新网页</span><br><span class="line">hexo d        #推送到GitHub</span><br></pre></td></tr></table></figure><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h3><p>在Hexo博客文件夹下打开命令行，执行”hexo new title”命令，其中title是你想起的博客名字。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20210321092626.png" alt="image-20210321092626437"></p><p>然后根据输出提示的博文地址前去打开编辑即可，我使用的Markdown编辑器是<strong>VSCode</strong>和<strong>Typora</strong>；至于Markdown语法我就不赘述了，一搜一大把。</p><h3 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h3><p>如果你希望自己的博文文件在生成时就带着自己自定义的内容，那么可以通过修改默认模板文件来解决。</p><p>进入”博客文件夹/scaffolds”目录，先将”post.md”文件备份一下，比如我这里将它另存为了”post_default”，以后想退回到默认post文件时可以直接替换。</p><p>下面是我的模板文件，相比源模板增加的内容并不多，但是较为实用：</p><ul><li>title：我在创建文章的时候<strong>title</strong>其实是<strong>categories/title</strong></li><li>author：作者名字</li><li>categories：分类 - 设置为default是为了这一栏不会因为是空的而被放到最后</li><li>tags：标签 - 设置为default同理</li><li>description：描述，这里我设置为 categories/title ，与我gitee的图床仓库地址对应</li><li>cover：这个是Butterfly主题带的封面图片</li><li>date：创建日期</li><li>updated：更新日期，如果不设置更新日期的话，那么之后更换设备的时候，文章更新日期就会全变成最新日期了</li></ul><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">author: LeoK77</span><br><span class="line">categories: default</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    -</span> default</span><br><span class="line">description: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br></pre></td></tr></table></figure><p>设置后再使用hexo new的时候，就不用自己手动添加这些内容了，依次修改对应项即可。</p><h3 id="草稿文件夹"><a href="#草稿文件夹" class="headerlink" title="草稿文件夹"></a>草稿文件夹</h3><blockquote><p>是否存在有的博文先写好而有的博文还没写完的情况？而又不想等到最后一起发布？那么这时候就需要草稿文件夹了。</p></blockquote><p>在”博客文件夹/source/“目录下新建”_drafts”文件夹，将还不想发布的放到这个文件夹内即可，这样在推送博文的时候只需要控制好哪些在”_posts”(要发布)和哪些在”_drafts”(草稿文件夹，不发布)即可。</p><p>如果想使用命令进行控制的话，可以参见<a href="https://hexo.io/zh-cn/docs/writing#%E8%8D%89%E7%A8%BF">hexo文档</a>，但我习惯自己手动换了(之前用hexo-admin插件替换控制草稿的时候，我的博文文件总是会第一行被它干掉，搞的我很不爽，就不用命令了，还是自己手动换不会出错)。</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><blockquote><p>插入图片我有写一篇博文单独讲述如何使用Gitee作为图床，这里我就不做赘述了，想看的话可以去看那篇文章。</p></blockquote><p>博文链接：<a href="https://leok77.github.io/2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/">使用Gitee+PicGo搭建图床</a></p><p>如果想使用资源文件夹(相对路径，图片存储在GitHub上)的话，可以参加<a href="https://hexo.io/zh-cn/docs/asset-folders">Hexo文档</a>，我这里也不赘述了。但是需要注意的是图片存储在GitHub的情况下可能会导致访问速度慢，我就是因为图片加载特别慢才使用Gitee当免费图床，有预算的话可以考虑下七牛云、阿里云、腾讯云等的对象云存储，可惜我知道的时候已经不能白嫖了，所以我选择白嫖Gitee(暴论)。</p>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行基础</title>
      <link href="2021/02/08/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/"/>
      <url>2021/02/08/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux命令基础知识"><a href="#Linux命令基础知识" class="headerlink" title="Linux命令基础知识"></a>Linux命令基础知识</h2><p>GUI：Graphical User Interface - 图形用户界面<br>CUI：Command Line Interface - 命令行界面</p><h3 id="Linux命令语法格式"><a href="#Linux命令语法格式" class="headerlink" title="Linux命令语法格式"></a>Linux命令语法格式</h3><p>命令格式：命令 [-选项] [参数]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line">ls -a /etc  <span class="comment">#列出“/etc”文件夹下的所有文件</span></span><br><span class="line"><span class="comment">#“选项”分为“简化选项&#x27;-&#x27;”和“完整选项&#x27;--&#x27;”，如“-a”等价与“--all”</span></span><br></pre></td></tr></table></figure><h3 id="Linux命令行操作技巧"><a href="#Linux命令行操作技巧" class="headerlink" title="Linux命令行操作技巧"></a>Linux命令行操作技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#光标</span><br><span class="line">Home      #移动光标到本行开头</span><br><span class="line">Ctrl + A  #移动光标到行首</span><br><span class="line">Ctrl + E  #移动光标到行尾</span><br><span class="line">Ctrl + C  #终止当前程序</span><br><span class="line">Ctrl + L  #清理屏幕显示</span><br></pre></td></tr></table></figure><h3 id="Linux命令分类"><a href="#Linux命令分类" class="headerlink" title="Linux命令分类"></a>Linux命令分类</h3><table><thead><tr><th>分类</th><th>命令</th></tr></thead><tbody><tr><td>登录和电源管理</td><td>login、shutdown、halt、reboot、install、exit、last等</td></tr><tr><td>文件处理</td><td>file、mkdir、grep、dd、find、mv、ls、diff、cat、ln等</td></tr><tr><td>系统管理</td><td>df、top、free、quote、at、ip、kill、crontab等</td></tr><tr><td>网络操作</td><td>ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup等</td></tr><tr><td>系统安全</td><td>passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who等</td></tr><tr><td>其他</td><td>tar、unzip、gunzip、unarj、motools、man等</td></tr></tbody></table><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="登录命令"><a href="#登录命令" class="headerlink" title="登录命令"></a>登录命令</h3><h4 id="login"><a href="#login" class="headerlink" title="login"></a>login</h4><p>作用：登录系统。<br>权限：所有用户。</p><p>Linux是多用户操作系统，可以同时接受多个用户登录，允许一个用户多次登录。每个虚拟控制台可以看作一个独立工作站，工作台之间可以切换。虚拟控制台的切换可以通过按下“Alt”键及功能键(通常是F1~F6)来实现。</p><p>虚拟控制台的好处：一个程序出错造成系统死锁时，可以切换到其他虚拟控制台工作，关闭这个程序。</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>作用：显示近期用户或终端的登录情况。管理员可以通过last查看该程序的log，获知谁曾经或企图连接系统。<br>权限：所有用户。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>作用：退出系统，没有参数，运行后退出系统进入登录界面。<br>权限：所有用户。</p><h3 id="电源管理命令"><a href="#电源管理命令" class="headerlink" title="电源管理命令"></a>电源管理命令</h3><h4 id="shutdow"><a href="#shutdow" class="headerlink" title="shutdow"></a>shutdow</h4><p>作用：关闭计算机。<br>权限：超级用户。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown [-t seconds] [option] time [message]</span><br><span class="line">-t seconds   <span class="comment">#在改变到其他运行级别之前，告诉init程序多久后关机</span></span><br><span class="line">-r           <span class="comment">#关机后打开电源(重启)</span></span><br><span class="line">-h           <span class="comment">#关机后关闭电源</span></span><br><span class="line">-F           <span class="comment">#在重启计算机时强迫fsck</span></span><br><span class="line"><span class="comment">#fsck(File System Check)命令用于检查与修复Linux档案系统，可以同时检查一个或多个Linux档案系统。</span></span><br><span class="line">time          <span class="comment">#设定关机前的时间</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">message       <span class="comment">#传送给使用者的警告讯息</span></span><br></pre></td></tr></table></figure><p>系统关机前使用shutdown命令，系统管理员会通知所有登录的用户系统将要关闭，并且login指令会被冻结，即新的用户不能再登录</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>作用：关闭系统。<br>权限：超级用户。</p><p>halt执行时，杀死应用进程，执行sync(将存于buffer中的资料强制写入硬盘中)系统调用，文件系统读写操作完成后停止内核。若系统运行级别为0或6，则关闭系统；否则以shutdown指令(shutdown -h)取代。</p><p>sync命令：强制将内存缓冲区中的数据立即写入磁盘<br>fsck命令：检查并试图修复文件系统中的错误<br>超级块位于块组最前面，描述文件系统整体信息的数据结构<br>/var/log/wtmp是一个二进制文件，记录每个用户的登录次数和持续时间等信息</p><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>作用：重新启动计算机。<br>权限：系统管理者。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-n  <span class="comment">#保存数据后重启</span></span><br><span class="line">-w  <span class="comment">#不重启，仅记录写入到/var/log/wtmp文件中</span></span><br><span class="line">-d  <span class="comment">#不把记录写入到/var/log/wtmp文件中</span></span><br><span class="line">-i  <span class="comment">#关闭网络设置后再重启</span></span><br></pre></td></tr></table></figure><h3 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h3><h4 id="Linux文件目录结构"><a href="#Linux文件目录结构" class="headerlink" title="Linux文件目录结构"></a>Linux文件目录结构</h4><p>Linux系统中一切皆文件，其文件目录结构是树形， “/” 是根目录</p><table><thead><tr><th>文件目录</th><th>解释</th></tr></thead><tbody><tr><td>/bin</td><td>bin是Binary的缩写，存放最常用的命令</td></tr><tr><td>/boot</td><td>启动Linux时的一些核心文件，包括连接文件和镜像文件</td></tr><tr><td>/dev</td><td>Device的缩写，存放外部设备。</td></tr><tr><td>/etc</td><td>存放所有系统管理所需要的配置文件和子目录</td></tr><tr><td>/home</td><td>用户主目录</td></tr><tr><td>/lib</td><td>存放系统最基本的动态连接共享库</td></tr><tr><td>/media</td><td>Linux系统自动识别设备之后，挂载到这个目录下</td></tr><tr><td>/mnt</td><td>让用户临时挂载别的文件系统</td></tr><tr><td>/opt</td><td>给主机额外安装软件的目录</td></tr><tr><td>/proc</td><td>系统内存映射的虚拟目录，获取系统信息</td></tr><tr><td>/root</td><td>系统管理员/超级权限者的用户主目录</td></tr><tr><td>/run</td><td>临时文件系统，存储系统启动以来的信息。若有/var/run目录，则指向/run</td></tr><tr><td>/sbin</td><td>存放系统管理员的系统管理程序</td></tr><tr><td>/srv</td><td>存放一些服务启动后需要提取的数据</td></tr><tr><td>/sys</td><td>Linux2.6内核后，新出现文件系统sysfs</td></tr><tr><td>/tmp</td><td>用来存放一些临时文件</td></tr><tr><td>/usr</td><td>用户的应用程序和文件</td></tr><tr><td>/var</td><td>将经常被修改的目录存在这个目录下，包括各种日志文件</td></tr></tbody></table><h4 id="Linux文件路径"><a href="#Linux文件路径" class="headerlink" title="Linux文件路径"></a>Linux文件路径</h4><p>绝对路径：从/(根目录)开始的<br>相对路径：相对当前所在目录来说的路径</p><h4 id="Linux文件命令"><a href="#Linux文件命令" class="headerlink" title="Linux文件命令"></a>Linux文件命令</h4><h5 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h5><p>作用：打印当前的工作目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> -L  <span class="comment">#目录连接链接时，输出连接路径</span></span><br><span class="line"><span class="built_in">pwd</span> -P  <span class="comment">#输出物理路径</span></span><br></pre></td></tr></table></figure><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><p>作用：改变当前工作目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..   <span class="comment">#进入上一层目录</span></span><br><span class="line"><span class="built_in">cd</span> .    <span class="comment">#进入当前目录</span></span><br><span class="line"><span class="built_in">cd</span>      <span class="comment">#回到家目录</span></span><br><span class="line"><span class="built_in">cd</span> ~    <span class="comment">#回到家目录</span></span><br><span class="line"><span class="built_in">cd</span> -    <span class="comment">#进入前一个目录，两个目录之间快速切换</span></span><br></pre></td></tr></table></figure><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>作用：列出目录的内容或者文件的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls              <span class="comment">#列出当前目录下所有文件和目录(隐藏文件除外)</span></span><br><span class="line">ls -l           <span class="comment">#显示详细信息</span></span><br><span class="line">ls -l /         <span class="comment">#列出指定目录内容</span></span><br><span class="line">ls -l /bin/bash <span class="comment">#列出指定文件信息</span></span><br><span class="line">ls -l f1 f2     <span class="comment">#同时列出多个文件信息</span></span><br><span class="line">ls -ld /        <span class="comment">#列出指定目录信息</span></span><br><span class="line">ls -lh          <span class="comment">#-h用人类易读的格式显示大小信息</span></span><br><span class="line">ls -a           <span class="comment">#显示隐藏的文件和目录——包括.和..</span></span><br><span class="line">ls -t           <span class="comment">#按时间排序</span></span><br><span class="line">ls -S           <span class="comment">#按大小排序</span></span><br><span class="line">ls -X           <span class="comment">#按拓展名排序</span></span><br><span class="line">ls -1           <span class="comment">#一行显示一个文件</span></span><br></pre></td></tr></table></figure><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>作用：创建目录，若目录已存在则报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p dir1/dir2/dir3 <span class="comment">#若dir1、dir2不存在则一并创建</span></span><br><span class="line">mkdir -pv dir1/dir2     <span class="comment">#显示创建的过程</span></span><br></pre></td></tr></table></figure><h5 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h5><p>作用：创建空文件、修改文件时间戳</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch file      <span class="comment">#把file的时间戳改为当前时间</span></span><br><span class="line">touch -d <span class="string">&quot;2021-02-08 19:14:10&quot;</span> file <span class="comment">#把file的时间戳改为指定时间</span></span><br></pre></td></tr></table></figure><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>作用：复制文件或者目录  —— 高危命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp f1 f2      <span class="comment">#把文件f1复制一份，命名为f2</span></span><br><span class="line">cp f1 d1/     <span class="comment">#把文件f1复制到目录d1下</span></span><br><span class="line">cp f1 f2 d1/  <span class="comment">#把文件f1、f2复制到目录d1下</span></span><br><span class="line">cp -a f1 f2   <span class="comment">#-a保留源文件属性</span></span><br><span class="line">cp -i f1 f2   <span class="comment">#覆盖f2之前需要用户确认</span></span><br><span class="line">cp -r d1 d2   <span class="comment">#把目录d1复制一份，命名为d2</span></span><br><span class="line">cp -rv d1 d2  <span class="comment">#-v显示过程</span></span><br><span class="line">cp -rf d1 d2  <span class="comment">#无法打开已经存在的目标文件时删除目标文件然后重试</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把一个目录下众多子目录中的html文件全部复制出来，放到目录/data/html中</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">exec</span> cp &#123;&#125; /date/html/ \;    <span class="comment">#方法一，分号不能去掉</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> | xargs cp -t /data/html/     <span class="comment">#方法二，xargs及-t减少cp进程数</span></span><br></pre></td></tr></table></figure><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><p>作用：移动文件或者目录  —— 高危命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv f1 f2      <span class="comment">#将f1重命名为f2</span></span><br><span class="line">mv -b f1 f2   <span class="comment">#若f2已存在，则先备份文件</span></span><br><span class="line">mv -f f1 f2   <span class="comment">#若f2已存在，则直接覆盖</span></span><br><span class="line">mv -i f1 f2   <span class="comment">#若f2已存在，则询问是否覆盖</span></span><br></pre></td></tr></table></figure><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>作用：删除文件或者目录  —— 高危命令</p><p>注意：<strong>没有撤销删除操作</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f dir     <span class="comment">#忽略不存在的文件，不给出提示</span></span><br><span class="line">rm -r dir     <span class="comment">#递归删除dir下所有文件和目录</span></span><br><span class="line">rm -i dir     <span class="comment">#删除前询问</span></span><br><span class="line">rm -v dir     <span class="comment">#显示删除步骤</span></span><br><span class="line">rm -rf dir    <span class="comment">#递归删除且无需确认</span></span><br></pre></td></tr></table></figure><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><p>作用：读取文件的全部内容、将几个文件合并为一个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat file        <span class="comment">#读取file全部内容</span></span><br><span class="line">cat -A file     <span class="comment">#显示不可打印字符</span></span><br><span class="line">cat f1 f2 &gt; f2  <span class="comment">#将f1和f2的内容合并到f3</span></span><br></pre></td></tr></table></figure><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><p>作用：显示文件的开头内容，默认显示开头10行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head file       <span class="comment">#显示file开头内容</span></span><br><span class="line">head -n 3 file  <span class="comment">#显示file前3行</span></span><br><span class="line">head -c 3 file  <span class="comment">#显示file前3字节</span></span><br><span class="line">head -n -3 file <span class="comment">#显示file除了最后3行的所有内容</span></span><br></pre></td></tr></table></figure><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><p>作用：读取文件的尾部内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -n 3 file  <span class="comment">#显示file最后三行</span></span><br><span class="line">tail -n +3 file <span class="comment">#显示第三行到最后的所有内容</span></span><br><span class="line">tail -f file    <span class="comment">#跟踪file尾部变化显示</span></span><br><span class="line"><span class="comment">#后台ping，通过tail显示实时的ping信息</span></span><br><span class="line">ping cn.bing.com &gt; ping.log &amp;</span><br><span class="line">tail -f ping.log</span><br></pre></td></tr></table></figure><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>作用：以一页一页的方式逐页阅读文件内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter - 向下n行，默认是1行</span><br><span class="line">Ctrl+F - 向下滚动一屏</span><br><span class="line">SPACE - 向下滚动一屏</span><br><span class="line">Ctrl+B - 向上滚动一屏</span><br><span class="line">&#x3D; - 输出当前行的行号</span><br><span class="line">V - 调用vi编辑器</span><br><span class="line">!命令 - 调用shell命令并执行</span><br><span class="line">q - 退出more</span><br></pre></td></tr></table></figure><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><p>作用：读取内容，分屏显示，可以随意浏览文件，查看之前不加载整文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;string - 向下搜索string</span><br><span class="line">?string - 向上搜索string</span><br><span class="line">Q - 退出less</span><br><span class="line">SPACE - 滚动一页</span><br><span class="line">Enter - 滚动一行</span><br><span class="line">h - 显示帮助界面</span><br></pre></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>作用：在指定目录下查找文件</p><p>find [path…] [expression]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -name <span class="string">&quot;*book*&quot;</span>       <span class="comment">#查找名字包含book的文件</span></span><br><span class="line">find -user openEuler      <span class="comment">#查找所属用户是openEuler的文件</span></span><br><span class="line">find -empty               <span class="comment">#查找空文件及目录</span></span><br><span class="line">find -empty -delete       <span class="comment">#查找空文件并删除</span></span><br><span class="line">find -size 0              <span class="comment">#查找大小为0的文件</span></span><br><span class="line">find /etc -name <span class="string">&quot;*.html&quot;</span>  <span class="comment">#在/etc目录下查找.html类型的文件</span></span><br><span class="line">find -mtime +7            <span class="comment">#查找更改时间是7日以前的文件</span></span><br><span class="line">find -mtime -7            <span class="comment">#查找更改时间是7日之内的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">type</span> d    <span class="comment">#查找文件类型是目录的文件</span></span><br><span class="line">find -<span class="built_in">type</span> c    <span class="comment">#查找文件类型是字型装置文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> b    <span class="comment">#查找文件类型是区块装置文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> p    <span class="comment">#查找文件类型是具名贮存的文件</span></span><br><span class="line">find -<span class="built_in">type</span> f    <span class="comment">#查找文件类型是一般文件的文件</span></span><br><span class="line">find -<span class="built_in">type</span> l    <span class="comment">#查找文件类型是符号连结的文件</span></span><br></pre></td></tr></table></figure><h5 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h5><p>作用：快速的查找文件系统内是否有指定的文件<br>原理：先建立一个文件名及路径的数据库，查找时去这个数据库内查询<br>使用：使用之前要先updatedb一下来生成数据库，一般定时执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate openEuler    <span class="comment">#查找文件名中包含openEuler的文件</span></span><br><span class="line">locate /etc/sh      <span class="comment">#查找/etc目录下以sh开头的文件</span></span><br></pre></td></tr></table></figure><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p>作用：在PATH所指定的目录中查找可执行文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">cd</span>        <span class="comment">#查找cd命令文件</span></span><br><span class="line"><span class="built_in">which</span> -a <span class="built_in">cd</span>     <span class="comment">#列出所有cd文件</span></span><br><span class="line"><span class="built_in">which</span> cp mv rm  <span class="comment">#查找多个文件</span></span><br></pre></td></tr></table></figure><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p>作用：对单个文件或目录进行压缩或解压缩的命令，执行之后只有源文件或压缩后的文件，是对文件在原本位置压缩，压缩一个目录后是目录下的所有文件都变成了filename.gz。</p><p>gzip [option] [filename]</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -d file      <span class="comment">#压缩file为file.gz</span></span><br><span class="line">gzip -f file      <span class="comment">#强行压缩file</span></span><br><span class="line">gzip -l file.gz   <span class="comment">#列出file.zip中的文件相关信息</span></span><br><span class="line">gzip -r dir       <span class="comment">#递归压缩dir</span></span><br><span class="line">gzip -rv dir      <span class="comment">#-v显示指令执行过程</span></span><br></pre></td></tr></table></figure><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><p>作用：打包文件，把多个文件打到一个包里，方便数据移动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cf dir.tar dir      <span class="comment">#把dir目录及其所有内容打包</span></span><br><span class="line">tar tf dir.tar          <span class="comment">#列出dir.tar下所有内容</span></span><br><span class="line">tar xf dir.tar          <span class="comment">#解包dir.tar到当前目录</span></span><br><span class="line">tar xf dir.tar -C /tmp  <span class="comment">#解包dir.tar到当前目录的/tmp目录下</span></span><br><span class="line">tar czf dir.tar.gz dir  <span class="comment">#打包dir并使用gzip压缩</span></span><br></pre></td></tr></table></figure><h5 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h5><p>作用：创建链接文件</p><p>软链接(symbolic link)：以路径形式存在(快捷方式)；删除源文件后链接失效；可以对目录进行链接；可以跨文件系统<br>硬链接(hard link)：以文件副本形式存在，不占用实际空间；删除源文件后影响；不可以对目录链接；不可以跨文件系统</p><p>ln适用场景：多个不同目录需要同一文件的场景，只需要某一固定目录放置该文件，其他目录ln命令设置link该文件，不必重复占用磁盘空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不带参数情况下默认创建硬链接</span></span><br><span class="line">ln sourcefile targetfile    <span class="comment">#创建硬链接</span></span><br><span class="line">ln -s sourcefile targetfile <span class="comment">#创建软链接</span></span><br></pre></td></tr></table></figure><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><table><thead><tr><th>序号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>使用者在shell中可以操作的指令或程序</td></tr><tr><td>2</td><td>系统核心可调用的函数与工具等</td></tr><tr><td>3</td><td>常用的函数(function)和函数库(library)</td></tr><tr><td>4</td><td>设备文档的说明，通常是/dev下的文件</td></tr><tr><td>5</td><td>文件格式和约定</td></tr><tr><td>6</td><td>游戏(games)</td></tr><tr><td>7</td><td>杂项(包括宏和惯例)</td></tr><tr><td>8</td><td>系统管理命令(通常仅适用于root用户)</td></tr><tr><td>9</td><td>内核例程(非标准)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man sleep       <span class="comment">#查看sleep命令手册</span></span><br><span class="line">man 3 sleep     <span class="comment">#查看sleep命令库函数</span></span><br><span class="line"><span class="comment">#查找名字包含keyword的man文档</span></span><br><span class="line">man -k keyword</span><br><span class="line">find /usr/share/man -iname <span class="string">&quot;*keyword*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">pwd</span>      <span class="comment">#pwd命令的详细讲解</span></span><br><span class="line"><span class="built_in">help</span> -d <span class="built_in">pwd</span>   <span class="comment">#pwd命令简短主题描述</span></span><br><span class="line"><span class="built_in">help</span> -s <span class="built_in">pwd</span>   <span class="comment">#pwd命令简短语法描述</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Gitee+PicGo搭建图床</title>
      <link href="2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>2021/02/07/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然Hexo可以设置相对路径引用存储图片，但是这样会把图片存储到Github上，而碍于国内对于Github的访问速度，博客中的图片加载起来十分的慢，而穷孩子用不起对象云存储，小型图床又怕跑路，所以把主意打到了Gitee身上</p></blockquote><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><p>如果没有Gitee账号的话自行注册一个，这里就不演示账号注册了。</p><blockquote><p>Gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p></blockquote><h3 id="新建图床仓库"><a href="#新建图床仓库" class="headerlink" title="新建图床仓库"></a>新建图床仓库</h3><h4 id="新建Public仓库"><a href="#新建Public仓库" class="headerlink" title="新建Public仓库"></a>新建Public仓库</h4><p>在Gitee主页左下角可以找到新建仓库按钮，点击之后即可新建一个开源(public)仓库，因为要制作的Hexo博客图床是希望所有人访问你的博客的时候都可以看到图片，如果设置为私有仓库别人就无法访问图片了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151233.png" alt="image-20210207152744099"></p><p>建议勾选“使用Readme文件初始化这个仓库”，因为PicGo在上传图片的时候需要Gitee中已经有相应的分支了，如果不初始化仓库，那么默认的“master”分支是不存在的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151242.png" alt="image-20210207152652438"></p><h4 id="修改分支名-可选项"><a href="#修改分支名-可选项" class="headerlink" title="修改分支名(可选项)"></a>修改分支名(可选项)</h4><p>如果你没有把仓库分支名更改为“main”的习惯，那么“新建图床仓库”这一部分就已经做完了，如果你希望你的仓库分支名是“main”，那么请继续操作。</p><p>仓库新建完毕之后会自动转到仓库页面，在这里点击如图所示位置的“分支”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151303.png" alt="image-20210207153332398"></p><p>在新弹出的分支设置窗口点击右侧的“新建分支”，分支名填“main”，然后将“main”分支设置为默认分支并删除“master”分支。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151305.png" alt="image-20210207153707974"></p><h3 id="设置私人令牌"><a href="#设置私人令牌" class="headerlink" title="设置私人令牌"></a>设置私人令牌</h3><p>点击网页右上角的头像，然后点击弹出的“设置”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151308.png" alt="image-20210207153737996"></p><p>下滑找到左侧的安全设置，并选择“私人令牌”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151311.png" alt="image-20210207153854720"></p><p>点击网页右上角的“新建私人令牌”，然后设置私人令牌的描述及权限，权限只给如图所示的这两个就可以了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151314.png" alt="image-20210207154031460"></p><p>如图所示区域就是你的私人令牌，使用PicGo上传图片到Gitee仓库中需要使用，<strong>此页面关闭后，Gitee就不会再显示私人令牌，自己复制下来保存好</strong>。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151317.png" alt="image-20210207154238116"></p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>PicGo需要Node.js，使用Hexo的都安装了Node.js了吧</p><blockquote><p>Node.js官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a><br>NVS(Node Version Switcher)：<a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a><br>PicGo官网：<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a><br>PicGo Github：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p></blockquote><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>无论是从官网下载PicGo还是从Github主页进去下载，最后都是要在Github上下载PicGo的Release，我此处下载的是“2.2.2”版本，并不是因为我2，而是因为这个是最新的稳定版，首页的“2.3.0-beta.4”是beta版，虽然功能更强大，但是beta不稳定啊，万一出了问题挂了不就不好了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151321.png" alt="image-20210207154920720"></p><p>下载下来之后安装win10程序的安装过程走的就行了，不做演示。</p><h3 id="安装picgo-plugin-github-plus插件"><a href="#安装picgo-plugin-github-plus插件" class="headerlink" title="安装picgo-plugin-github-plus插件"></a>安装picgo-plugin-github-plus插件</h3><p>打开PicGo主面板，按照如图所示顺序安装“github-plus”插件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151325.png" alt="image-20210207155559207"></p><p>安装成功之后重启应用。在系统托盘区域，右键PicGo的图标，然后点击重启应用，重启后他是默认在托盘区域的，需要手动点一下，然后就出来了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151328.png" alt="image-20210207155713915"></p><p>设置GithubPlus图床：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo &#x3D; username&#x2F;repository_name #用户名&#x2F;仓库名</span><br><span class="line">branch &#x3D; main                   #分支名字，如果前面没设置，那么这里用master即可</span><br><span class="line">token &#x3D; 私人令牌                #你前面设置的Gitee的私人令牌</span><br><span class="line">path &#x3D;                          #图片存储路径，如果不设置的话就会存储到主目录，建议分类</span><br><span class="line">origin &#x3D; gitee                  #选择gitee才会传到gitee</span><br></pre></td></tr></table></figure><p>如图所示区域就是我的“repo”——“leok77/blog-img-test”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151332.png" alt="image-20210207160704736"></p><p>设置path的好处就是图片存储的位置在文件夹里，而不是全都存在主目录，这样当自己手贱同一张图片多次上传，或者要修改某一篇博文的内容的时候，可以通过找对应文件夹，而不是看着全部的主目录两眼一抹黑。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151335.png" alt="image-20210207161022952"></p><p>我设置里的repo和我前面提的repo不完全一致是因为这里设置中的是我一在用的图床仓库，前面那是我为了演示新建的仓库，懒得换了(懒癌晚期)。记得将“GithubPlus”设置为默认。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151339.png" alt="image-20210207160104869"></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><blockquote><p>Typora官网：<a href="https://typora.io/">https://typora.io/</a></p></blockquote><p>我现在写博客是通过VSCode(我知道VSCode也有PicGo插件，但是我还没搞明白怎么让他传到Gitee上)，而博客中插入图片以及看Markdown都是通过Typora，因为Typora用来做阅读器十分的舒服，以及插入图片的时候可以配合PicGo直接上传，没有人想每次插入图片的时候，都打开PicGo——上传图片——等待连接——粘贴到博文中吧。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210208151343.png" alt="image-20210207162300664"></p><p>这样设置好之后，无论你是把图片直接拖动到Typora中，还是把Snipaste截图后的图片粘贴到Typora中，他都会自动帮你自动调用PicGo上传图片，并直接转化为可用的图片连接。</p><h2 id="Python脚本修改url字符转置"><a href="#Python脚本修改url字符转置" class="headerlink" title="Python脚本修改url字符转置"></a>Python脚本修改url字符转置</h2><blockquote><p>可能是我的设置原因或者更新了PicGo的原因，之前使用的时候生成的图片url默认就是中文，但是现在变成了特殊字符转置之后的，也就是我的图片连接变成了一串”%NN”串，虽然这样兼容的编辑器多了，但是影响可读性，索性写了个脚本转置回中文，写完博客后运行一下再发布，美滋滋。</p></blockquote><p>其中的”get_all_path”和”get_abspath_dst”本来是另一个脚本里面的，这里为了方便就放在一个文件里面了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得root_path目录下的所有文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_path</span>(<span class="params">root_path=<span class="string">&#x27;&#x27;</span>, all_path=<span class="literal">None</span></span>):</span></span><br><span class="line">    root_path = os.path.abspath(root_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root_path):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + root_path + <span class="string">&#x27; ** NOT EXIST!!&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> all_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        all_path = []</span><br><span class="line">    <span class="comment"># 如果是 文件 或者是 空文件夹，直接添加到all_path中</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(root_path) <span class="keyword">or</span> (<span class="keyword">not</span> os.listdir(root_path)):</span><br><span class="line">        all_path.append(root_path)</span><br><span class="line">    <span class="comment"># 如果是 非空文件夹 则遍历添加文件夹内部内容</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># os.walk的经典用法：对以root_path为根的每个目录进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(root_path):</span><br><span class="line">            <span class="keyword">for</span> dir_name <span class="keyword">in</span> dirs:</span><br><span class="line">                dir_path = os.path.join(root, dir_name)</span><br><span class="line">                <span class="comment"># 只将空文件夹填入all_path，非空文件夹会由内部文件路径填入all_path</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.listdir(dir_path):</span><br><span class="line">                    all_path.append(dir_path)</span><br><span class="line">            <span class="keyword">for</span> basename <span class="keyword">in</span> files:</span><br><span class="line">                all_path.append(os.path.join(root, basename))</span><br><span class="line">    <span class="keyword">return</span> all_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 abspath_dst ，在源文件名后面加日期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_abspath_dst</span>(<span class="params">abspath_src=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    abspath_src = os.path.abspath(abspath_src)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + abspath_src + <span class="string">&#x27;** NOT  EXIST!&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    root, ext = os.path.splitext(abspath_src)</span><br><span class="line">    abspath_dst = root + datetime.datetime.now().strftime(<span class="string">&#x27;-%Y-%m-%d-%H-%M-%S&#x27;</span>) + ext</span><br><span class="line">    <span class="keyword">return</span> abspath_dst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_escape_to_chinese</span>(<span class="params">filename=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    abspath_src = os.path.abspath(filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(abspath_src):</span><br><span class="line">        print(<span class="string">&#x27;ERROR! ** &#x27;</span> + abspath_src + <span class="string">&#x27; ** NOT EXIST!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    abspath_dst = get_abspath_dst(abspath_src)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(abspath_src)</span></span><br><span class="line">    <span class="comment"># print(abspath_dst)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(abspath_src, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(abspath_dst, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> dst_file:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> src_file.readlines():</span><br><span class="line">                <span class="keyword">if</span> line.find(<span class="string">&#x27;http&#x27;</span>):</span><br><span class="line">                    dst_file.write(parse.unquote(line))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dst_file.write(line)</span><br><span class="line"></span><br><span class="line">    os.replace(abspath_dst, abspath_src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 博文所在文件夹 &quot;博客文件夹/source/_posts&quot;</span></span><br><span class="line">    <span class="comment"># 如果要将草稿文件夹一并处理，使用 &quot;博客文件夹/source&quot; 即可</span></span><br><span class="line">    root_path = <span class="string">r&#x27;C:/Users/LeoK77/Documents/WorkSpace/Blog-Hexo-LeoK77/source/_posts&#x27;</span></span><br><span class="line">    <span class="comment"># 获取目录下的所有文件路径</span></span><br><span class="line">    root_paths = get_all_path(root_path)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> root_paths:</span><br><span class="line">        basename, ext = os.path.splitext(path)</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">&#x27;.md&#x27;</span>:</span><br><span class="line">            <span class="comment"># 对 &quot;.md&quot; 即Markdown类型的文件进行url转置，变回中文字符</span></span><br><span class="line">            url_escape_to_chinese(path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：因为我本身就没想过要在gitee图床里带空格，所以我这里没考虑不转置空格的情况，而Markdown里一个内含空格的链接是会被断开的，所以如果有需求的话可以自己改一下</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用也很简单，将上述python代码保存为一个python文件，然后写完博文之后python跑一下即可；我这里将跑的代码保存为了一个bat文件放在桌面上，这样我只需要双击它就可以了。</p><ol><li>cd &quot;C:\Users\LeoK77\Documents\WorkSpace\PyCharm-Projects\ToolBox\&quot;<ol><li>上述代码在我电脑里储存在这个位置，由于我使用的时候是两个文件，并不像上面结合在了一起，所以我需要cd 到这个路径再跑代码</li></ol></li><li>python.exe .\urlEscape_by_urllib.py<ol><li>python运行即可</li></ol></li><li>pause<ol><li>这个是为了让窗口停顿一下，我好知道有没有出问题，不然窗口一闪而过，我不知道执行结果是好的还是坏的</li></ol></li></ol><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &quot;C:\Users\LeoK77\Documents\WorkSpace\PyCharm-Projects\ToolBox\&quot; &amp;&amp; python.exe .\urlEscape_by_urllib.py &amp;&amp; <span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8Gitee+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/20210321095746.png" alt="image-20210321095745810"></p>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统的开发环境搭建</title>
      <link href="2021/02/07/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2021/02/07/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并不是所有的IDE都自带编译器，比如JetBrains家的CLion，虽然特别好用，但是Build时使用的编译器是需要自己配置(其实也不麻烦)，Win10平台不像Linux或MacOS可以直接一条命令安装，这里分享一下我电脑中的开发环境是如何搭建的以及个人比较推荐的IDE</p></blockquote><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><blockquote><p>既然是讨论Win10系统，那么我认为这里的C/C++的IDE可以分为两类，一类是Visual Studio；另一类就是其他IDE(使用TDM-GCC或其他类GCC编译器，而不是使用VS的编译器)</p></blockquote><h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><p>“巨硬”家的宇宙第一IDE，Win10环境下最强大的IDE没有之一(虽然我好像只有学C#的时候一直用他)，但是有些过于前卫——默认情况下写C程序的时候，scanf等函数是被禁用的(有安全漏洞)，需要自己关闭安全性检查，VS2015的时候可直接在创建项目的时候关闭，后来就需要自己设置了。</p><p>“scanf”函数报错如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152529.png" alt="image-20210207131119120"></p><h4 id="解决方法一-单文件"><a href="#解决方法一-单文件" class="headerlink" title="解决方法一 - 单文件"></a>解决方法一 - 单文件</h4><p>在要使用“scanf”等函数的文件首部添加如下语句：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152531.png" alt="image-20210207132051922"></p><h4 id="解决方法二-整个项目"><a href="#解决方法二-整个项目" class="headerlink" title="解决方法二 - 整个项目"></a>解决方法二 - 整个项目</h4><p>如果整个项目都是C语言项目，又不想用“scanf_s”替换“scanf”，那么可以在项目属性中添加规则，或者直接禁用SDL。</p><p>方法一、将“_CRT_SECURE_NO_WARNINGS”添加到预处理器中</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152534.png" alt="image-20210207132716500"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152537.png" alt="image-20210207132557514"></p><p>方法二、直接关闭“SDL检查”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152540.png" alt="image-20210207132904636"></p><h3 id="其他IDE及编译器"><a href="#其他IDE及编译器" class="headerlink" title="其他IDE及编译器"></a>其他IDE及编译器</h3><blockquote><p>除了第一个TDM-GCC是编译器外，后面的CLion、Code::Blocks都是IDE</p></blockquote><h4 id="编译器-TDM-GCC"><a href="#编译器-TDM-GCC" class="headerlink" title="编译器-TDM-GCC"></a>编译器-TDM-GCC</h4><blockquote><p>Windows系统下没有原生的GCC，所以需要MinGW、MinGW64、TDM-GCC之类的环境。<br>这里以TDM-GCC为例，主要是TDM-GCC的安装简单粗暴且没啥幺蛾子，并不是说MinGW(有些老)、MinGW64(托管在sourceforge让人眼花缭乱，不能一眼让人搞明白咋下载安装)</p></blockquote><p>TDM-GCC is a compiler suite for Microsoft Windows. It is a commonly recommended compiler in many books, both for beginners and more experienced programmers.<br>译文：TDM-GCC时一款适用于微软Windows系统的编译器。他在很多书中被广泛提及，对于初学者和进阶的程序员都十分的友好。  </p><blockquote><p>以上内容摘自TDM-GCC Wiki：<a href="https://en.wikipedia.org/wiki/TDM-GCC">https://en.wikipedia.org/wiki/TDM-GCC</a></p></blockquote><p>下载TDM-GCC直接去他的官网，点击官网首页的发行版，例如现在最新的发行版是“TDM-GCC 9.2.0 release”，点击之后可以看到下载按钮，选择“tdm64-gcc-9.2.0.exe”进行下载。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152555.png" alt="20210207122915"></p><blockquote><p>TDM-GCC官网：<a href="https://jmeubank.github.io/tdm-gcc/">https://jmeubank.github.io/tdm-gcc/</a></p></blockquote><p>下载下来的“tdm64-gcc-9.2.0.exe”本质上是一个管理器，你可以使用它管理电脑中的TDM-GCC。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152558.png" alt="20210207123052"></p><p>而且TDM-GCC会自动配置环境变量，在cmd下输入”gcc –version”，有如图所示内容就说明安装成功了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316204757.png" alt="image-20210316204757626"></p><h4 id="CLion——JetBrains的C-C-IDE"><a href="#CLion——JetBrains的C-C-IDE" class="headerlink" title="CLion——JetBrains的C/C++ IDE"></a>CLion——JetBrains的C/C++ IDE</h4><blockquote><p>CLion本身不带编译器，支持MinGW(MinGW、MinGW64、TDM-GCC(个人推荐))、Visual Studio、、CygWin等编译器(虽然部分不是编译器，但这里为了好表示，以上几个都视为编译器)，需要单独安装。</p></blockquote><p>如果你使用过IDEA(Java)或者PyCharm(Python)，那么你一定知道JetBrains(不知道的话我就当你知道了，总之就是一个公司的同系列产品)，CLion就是JetBrains旗下的一款专为C/C++开发的IDE，快捷键与IDEA基本一致，代码补全功能可以用“丧心病狂”来形容，十分的强大，至少我习惯了JetBrians家的IDE之后，用其他的环境写代码没有代码补全的情况下我感觉十分难受。</p><p>只可惜这款IDE不是免费的，且没有社区版，但是不要气馁，对于学生用户可以申请免费许可证(需要有教育邮箱，高校学生咨询学长或者老师，我们学校是一入校就分配了教育邮箱的)，只要用他写的程序不是用于商业用途，就可以随便用。</p><p>配置编译器：(Customize-&gt;All settings-&gt;)settings-&gt;Build-&gt;Toolchains，然后如图所示(虽然截图时我默认还是VS，但我现在只用TDM-GCC了)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152600.png" alt="20210207123343"></p><blockquote><p>JetBrains官网：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a><br>CLion：<a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a><br>JetBrains学生认证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a></p></blockquote><h4 id="VSCode——配合C-C-及Code-Runner插件"><a href="#VSCode——配合C-C-及Code-Runner插件" class="headerlink" title="VSCode——配合C/C++及Code Runner插件"></a>VSCode——配合C/C++及Code Runner插件</h4><p>严格意义上来说VSCode似乎算不上一个IDE，但是它安装插件之后又好像是个IDE，但对于我(目前)来说他本质上只是一个文本编辑器以及SSH工具，当且仅当我实在是不想建个项目或者懒得打开CLion的时候我会用VSCode跑一些测试代码。</p><p>我知道有很多带佬会教如何详细的配置VSCode如何成为一个特别好用的C/C++IDE，但是我只是浅尝辄止，所以我只安装C/C++、Code Runner插件以及装好TDM-GCC就够了，当然我这样做不适合写项目，但是我写项目还真不用VSCode。</p><p>在设置里配置好”在终端运行”(先按下”Ctrl+,”，然后输入”Code-runner: Run In Terminal”，将如图所示的地方打钩)，这个选项默认是false，如果不启用的话那么在运行程序时是无法输入内容的，因为默认是如下面第二图所示在”输出窗口(只读编辑器)”下运行的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316211023.png" alt="image-20210316211023124"></p><p>默认在输出窗口执行程序，按照上述设置好”Code-runner: Run In Terminal”后就可以在终端中输入输出了，我就不再单独截图演示了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316210420.png" alt="image-20210316210420383"></p><h4 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code::Blocks"></a>Code::Blocks</h4><p>Code::Blocks是一个开放源码的全功能的跨平台C/C++集成开发环境。Code::Blocks是开放源码软件。Code::Blocks由纯粹的C++语言开发完成，它使用了著名的图形界面库wxWidgets(3.x)版。对于追求完美的C++程序员，再也不必忍受Eclipse的缓慢。</p><blockquote><p>以上内容摘自CodeBlocks百度百科：<a href="https://baike.baidu.com/item/Code::Blocks/2131200">https://baike.baidu.com/item/Code::Blocks/2131200</a></p></blockquote><p>硬挑缺点的话那就是他没有中文版(有民间汉化，但是使用民间汉化之后有时会导致代码自动补全功能失灵的状况)，很多人推荐的IDE，我们学校机房电脑的上默认的IDE就有他。</p><blockquote><p>Code::Blocks官网：<a href="http://www.codeblocks.org/">http://www.codeblocks.org/</a></p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><blockquote><p>Python官网：<a href="https://www.python.org/">https://www.python.org/</a></p></blockquote><h3 id="下载Python"><a href="#下载Python" class="headerlink" title="下载Python"></a>下载Python</h3><p>下载Python可以通过微软应用商店、Python官网以及各大镜像源。我使用的是在Python官网下载。</p><blockquote><p>安装的时候建议选择”Add Python to PATH”，不然还得自己手动添加到PATH</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316211824.png" alt="image-20210316211824546"></p><h4 id="Python官网"><a href="#Python官网" class="headerlink" title="Python官网"></a>Python官网</h4><blockquote><p>Python - Windows：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p></blockquote><p>以Python 3.7.9 为例，我下载的时候会选择“x86_64”即64位，“executable installer”版，安装时不需要额外下载内容。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152604.png" alt="image-20210207190601060"></p><h4 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h4><p>以华为云为例，进入进入华为云的Python镜像源，找到要安装的Python版本，如Python3.7.9，则点击3.7.9，选择详细版本，对于华为云镜像源选择“python-3.7.9.exe”。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152607.png" alt="image-20210207191126236"></p><blockquote><p>华为云 - Python：<a href="https://repo.huaweicloud.com/python/">https://repo.huaweicloud.com/python/</a></p></blockquote><h4 id="Windows应用商店"><a href="#Windows应用商店" class="headerlink" title="Windows应用商店"></a>Windows应用商店</h4><p>一般情况下，除非系统只允许安装应用商店的程序，或者实在是懒得去官网/镜像源下载，我不会从这儿下载python。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152609.png" alt="image-20210207190208372"></p><h3 id="pip切换为国内源"><a href="#pip切换为国内源" class="headerlink" title="pip切换为国内源"></a>pip切换为国内源</h3><h4 id="pip-config-命令-此方法需要-pip-V-gt-10-0-0"><a href="#pip-config-命令-此方法需要-pip-V-gt-10-0-0" class="headerlink" title="pip config 命令 - 此方法需要 pip -V &gt;= 10.0.0"></a>pip config 命令 - 此方法需要 pip -V &gt;= 10.0.0</h4><p>虽然说要求“pip -V &gt;= 10.0.0”，看起来好像门槛有些高，但是目前pip版本已经到“21.0.1”了</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152613.png" alt="image-20210207203833204"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install pip -U  #通过默认源升级pip</span><br><span class="line">#通过TUNA清华源更新pip</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br><span class="line">#设置pip的默认源为TUNA清华源</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">#设置pip的默认源为华为云</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="IDE——PyCharm"><a href="#IDE——PyCharm" class="headerlink" title="IDE——PyCharm"></a>IDE——PyCharm</h3><blockquote><p>虽然Python自带的IDLE好像功能就够用了，但是谁会嫌弃更好用的IDE(PyCharm)呢</p></blockquote><p>只需要知道PyCharm很好用就够了，而且PyCharm有可以免费使用的社区版(不涉及商业行为，学生还可以用教育邮箱申请使用专业版)，无论是项目管理还是代码补全等一系列小工具，JetBrains家的IDE永远都是首屈一指的。</p><blockquote><p>JetBrains官网：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a><br>CLion：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a><br>JetBrains学生认证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a></p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>感觉Java的要求没那么多，很多教程都说Win10里Java需要配置环境变量才能使用，但实际上只要没有在cmd里用Java的要求，没必要加环境变量。而且实测安装jre8他会自动配置好环境变量。</p><p>当电脑中有多个Java环境的时候，只要在IDE里选对应的Java环境就好了，这是跟路径有关的，而不是“唯一性”。环境变量实际上就是省去了输入父路径的功夫，如果使用的时候输入父路径，那么就相当于有这个环境变量了。</p><p>而“电脑中只可以有一个Java”，是只可以有一个“java.exe”在环境变量里，如果我既把“Java8”的路径添进入了，又把“Java11”的路径填进去了，那么这两个“java.exe”在执行的时候就冲突了，无法识别具体是哪个了。</p><p>比如我的电脑中，我将“C:\Program Files (x86)\Common Files\Oracle\Java\javapath”添加到了环境变量里，那么这个目录下的“java.exe”我就可以直接引用了。这时候，我是直接以“java”的形式调用，还是以“&amp; ‘C:\Program Files (x86)\Common Files\Oracle\Java\javapath\java.exe’”的形式(因为路径中有空格，所以看起来不太一样)调用这个“java.exe”，实际使用上是完全一致的，只是一个方便一个不方便罢了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152616.png" alt="image-20210207202022066"></p><h3 id="Java版本选择"><a href="#Java版本选择" class="headerlink" title="Java版本选择"></a>Java版本选择</h3><h4 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h4><p>很多项目都是采用Java8作为主要的Java，这是因为Java8相较于其他版本来说比较“老”，却一直被维护，所以他经久不衰，是目前来说的首选的“稳定版”，至于学习Java的话可以用新版，因为新版中有新的特性，Java8虽然稳定但是作为老版本来说总有被淘汰的一天。(我环境变量里是Java8是因为我MC服务器用Java8，别的不吹，就是稳定，虽然用Java15的时候也没遇到过崩的情况)</p><blockquote><p>Java8：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p></blockquote><h4 id="Java-新版本"><a href="#Java-新版本" class="headerlink" title="Java - 新版本"></a>Java - 新版本</h4><blockquote><p><a href="https://www.oracle.com/java/technologies/java-se-glance.html">https://www.oracle.com/java/technologies/java-se-glance.html</a></p></blockquote><h3 id="Java多版本问题"><a href="#Java多版本问题" class="headerlink" title="Java多版本问题"></a>Java多版本问题</h3><p>前面已经提到了JDK在安装的时候是会自动添加到环境变量里的，当电脑里有多个Java环境的时候，只需要把自己想要使用的那个Java环境调动到最前面就可以了(命令行里使用”java”命令的时候是在环境变量里从头开始找，找到第一个包含”Java”的就直接用，不考虑后面的)。</p><p>比如在如图所示的情况下，我在cmd下”java -version”的结果就是jdk15的结果，而如果我把jdk8放在第一个，那么就是默认jdk8了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316212859.png" alt="image-20210316212859639"></p><p>如图所示这两个路径里面的”javapth”目录下的”java.exe、javac.exe、javew.exe、jshell.exe”在我的理解下本质上是指向安装的jdk目录下的链接，所以完全可以自己建一个文件夹，然后在这个文件夹里创建自己想用的jdk的这四个应用程序的链接，然后把这个文件夹添加到环境变量PATH的首位，这样就可以直接调用自己想用的jdk了。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>其实我本人并没有写过Node.js的项目，但是用的Hexo、PicGo等软件需要使用Node.js。而Hexo使用新版的Node.js的时候会出现一些Warning，虽然影响不大，但是使用的时候终端全是Warning着实让人恼火，所以我需要使用旧版的Node.js，以免我以后需要学习这门语言的时候环境受到影响，所以我使用NVS(Node Version Swithcer)来管理我电脑中的Node.js。</p><h3 id="直接安装Node-js"><a href="#直接安装Node-js" class="headerlink" title="直接安装Node.js"></a>直接安装Node.js</h3><blockquote><p>Node.js官网：<a href="https://nodejs.org/">https://nodejs.org</a><br>Node.js - 淘宝镜像：<a href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a><br>Node.js - 华为云：<a href="https://repo.huaweicloud.com/nodejs/">https://repo.huaweicloud.com/nodejs/</a></p></blockquote><h3 id="NVS-Node-Version-Switcher——Node版本管理"><a href="#NVS-Node-Version-Switcher——Node版本管理" class="headerlink" title="NVS - Node Version Switcher——Node版本管理"></a>NVS - Node Version Switcher——Node版本管理</h3><p>NVS是Github上的一个开源项目，允许电脑中存在多个Node.js环境，并在使用时决定选择哪个作为默认环境，下载、安装及使用方法请参考官方文档，其实不用记住太多的命令，在终端里输入“nvs”就可以以一种友好的方式通过“nvs”管理不同版本的Node.js了，但是部分命令确实是仅仅用“nvs”无法解决的。</p><blockquote><p>NVS - Github：<a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a></p></blockquote><p>下面是我认为较为常用或者需要进行设置的地方：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nvs           #不带参数运行，有交互界面</span><br><span class="line">nvs remote    #查看nvs下载时使用的仓库</span><br><span class="line">nvs remote node-taobao https://npm.taobao.org/mirrors/node  #添加淘宝镜像源到nvs中</span><br><span class="line">nvs remote node-huawei https://repo.huaweicloud.com/nodejs/ #添加华为云镜像源到nvs中</span><br><span class="line">nvs add <span class="number">12</span>    #安装Node.js <span class="number">12</span></span><br><span class="line">nvs use <span class="number">12</span>    #使用Node.js <span class="number">12</span></span><br><span class="line">nvs link <span class="number">12</span>   #将Node.js <span class="number">12</span>设置为默认的Node.js</span><br><span class="line">#设置为默认的版本之后需要再nvs use <span class="number">12</span>一下</span><br><span class="line">nvs ls        #查看nvs安装的Node.js版本、正在用的版本、默认的版本</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152620.png" alt="image-20210207140942926"></p><h3 id="NPM国内源"><a href="#NPM国内源" class="headerlink" title="NPM国内源"></a>NPM国内源</h3><p>npm的默认下载仓库是<a href="https://registry.npmjs.org/">https://registry.npmjs.org</a>，访问速度不是那么的快，国内用户没有科学上网工具的话可以切换为淘宝仓库镜像源或者华为云镜像源等国内镜像源。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org   #设置为淘宝仓库镜像源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/  #设置为华为云仓库镜像源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org        #切换回默认源</span><br><span class="line">npm config list   #查看设置是否成功</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210208152624.png" alt="image-20210207174829067"></p><h3 id="npm-check管理包"><a href="#npm-check管理包" class="headerlink" title="npm-check管理包"></a>npm-check管理包</h3><p>对于我来说使用Node.js时，我没了解npm怎么才能十分优雅的查看自己正在使用的包有没有可以升级的，所以我安装了npn-check用来检测包是否有可用升级。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npm-check -g --save # 全局安装 npm-check</span><br><span class="line">npm-check -u # 在使用node.js的地方进行检查</span><br></pre></td></tr></table></figure><p>比如我使用的Hexo框架是需要nodejs的，那么在我的Hexo博客文件夹中，我可以使用上述命令检查是否有可升级的包，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/Win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20210328124531.png" alt="image-20210328124531852"></p>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux非系统性命令记录</title>
      <link href="2021/02/06/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/06/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录在安装、配置及使用Linux的过程中所用到的一些命令，因为这些命令有些杂乱，所以并不是系统性的进行记录，而是把用到的都记录过来，方便以后查看</p></blockquote><h2 id="Linux通用"><a href="#Linux通用" class="headerlink" title="Linux通用"></a>Linux通用</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh -y   <span class="comment">#安装zsh</span></span><br><span class="line">chsh -s /bin/zsh username <span class="comment">#修改用户的默认终端为zsh</span></span><br><span class="line"><span class="comment">#下载并安装 oh-my-zsh</span></span><br><span class="line">wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><h4 id="VSCode-Remote-SSH"><a href="#VSCode-Remote-SSH" class="headerlink" title="VSCode Remote SSH"></a>VSCode Remote SSH</h4><p>需要在VSCode中安装插件“Remote SSH”或者直接安装“Remote Development”，这样就可以在VSCode中使用SSH了。</p><p>修改openEuler虚拟机内部的“/etc/ssh/sshd_config”，启用如下设置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AllowAgentForwarding yes</span><br><span class="line">AllowTcpForwarding yes</span><br><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure><p>刷新sshd服务状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><p>在启用的“Remote SSH”插件中按照cmd使用ssh的语法即可：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh username@ip -p port</span><br><span class="line">ssh leok77@<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">201</span> -p <span class="number">22</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216220339.png" alt="image-20210216220339336"></p><h4 id="authorized-keys-公钥登录"><a href="#authorized-keys-公钥登录" class="headerlink" title="authorized_keys - 公钥登录"></a>authorized_keys - 公钥登录</h4><h5 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\LeoK77\.ssh\</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216214734.png" alt="image-20210216213935122"></p><h5 id="上传到openEuler虚拟机"><a href="#上传到openEuler虚拟机" class="headerlink" title="上传到openEuler虚拟机"></a>上传到openEuler虚拟机</h5><p>在你的用户文件夹中新建“.ssh”文件夹，并将你的公钥“id_rsa.pub”上传到这个文件夹中，然后将“id_rsa.pub”写入到“authorized_keys”中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir ./.ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"><span class="comment">## 将前面生成的公钥上传到这个文件夹里，可以使用VSCode，也可以使用Xftp等软件</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>这样使用SSH登录的时候就不需要每次都输入密码了，仅限于你当前使用的机器。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/Linux%E9%9D%9E%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/20210216215533.png" alt="image-20210216215532960"></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>添加新用户到wheel组(管理员)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -g users -G wheel -s /bin/bash username</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户及其对应的文件目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel -f username</span><br></pre></td></tr></table></figure><h2 id="CentOS-openEuler"><a href="#CentOS-openEuler" class="headerlink" title="CentOS / openEuler"></a>CentOS / openEuler</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>设置静态IP，修改“/etc/sysconfig/network-scripts/ifcfg-enp0s3”文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## BOOTPROTO&#x3D;dhcp      #dhcp动态分配</span><br><span class="line">BOOTPROTO&#x3D;static      #static静态分配</span><br><span class="line">IPADDR&#x3D;192.168.0.121  #静态IP地址</span><br><span class="line">NETMASK&#x3D;255.255.255.0 #子网掩码</span><br><span class="line">GATEWAY&#x3D;192.168.0.1   #默认网关</span><br><span class="line">DNS1&#x3D;223.5.5.5        #阿里云公共DNS</span><br><span class="line">DNS2&#x3D;180.76.76.76     #腾讯公共DNS</span><br></pre></td></tr></table></figure><p>重新加载配置文件，并重启网卡，使设置生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli c reload     <span class="comment">#重新加载网络连接</span></span><br><span class="line">sudo nmcli c up enp0s3  <span class="comment">#重启网卡</span></span><br></pre></td></tr></table></figure><h4 id="防火墙-端口开放"><a href="#防火墙-端口开放" class="headerlink" title="防火墙 - 端口开放"></a>防火墙 - 端口开放</h4><h5 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld    <span class="comment">#查看firewalld服务状态</span></span><br><span class="line">systemctl start firewalld     <span class="comment">#开启firewalld服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld    <span class="comment">#firewalld服务开机自启</span></span><br><span class="line">systemctl is-enable firewalld <span class="comment">#查看firewalld服务开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld   <span class="comment">#禁止firewalld服务开机自启</span></span><br><span class="line">service firewalld start       <span class="comment">#开启firewalld服务</span></span><br><span class="line">service firewalld restart     <span class="comment">#重启firewalld服务</span></span><br><span class="line">service firewalld stop        <span class="comment">#关闭firewalld服务</span></span><br></pre></td></tr></table></figure><h5 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state        <span class="comment">#查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload       <span class="comment">#重载防火墙 - 更改规则后需要重载</span></span><br><span class="line">firewall-cmd --list-all     <span class="comment">#查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-ports   <span class="comment">#查看所有打开的端口</span></span><br><span class="line">firewall-cmd --add-port=25565/tcp --permanent     <span class="comment">#永久添加25565端口(全局)</span></span><br><span class="line">firewall-cmd --remove-port=25565/tcp --permanent  <span class="comment">#永久删除25565端口(全局)</span></span><br><span class="line">firewall-cmd --add-port=65001-65010/tcp --permanent      <span class="comment">#永久增加65001-65010端口(全局)</span></span><br><span class="line">firewall-cmd --zone=public --add-port=25565/tcp --permanent     <span class="comment">#永久添加25565端口(public)</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=25565/tcp --permanent  <span class="comment">#永久删除25565端口(public)</span></span><br></pre></td></tr></table></figure><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum makecache</span><br><span class="line">sudo yum grouplist</span><br><span class="line">sudo yum groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">./hello</span><br><span class="line">g++ -o hello-cpp hello.cpp</span><br><span class="line">./hello-cpp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinecraftJava版开服指北</title>
      <link href="2021/02/04/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/"/>
      <url>2021/02/04/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文以Win10平台为例，如果有在Linux系统下开服的要求(如各种云服务器)，可以把MC开服后的Server文件夹整个上传到Linux服务器上，然后执行相应命令即可<br>Minecraft Java Edition需要电脑中有Java环境，我使用的是Java8，Oracle Java8官方下载地址(需注册账号)：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p></blockquote><h2 id="原版服"><a href="#原版服" class="headerlink" title="原版服"></a>原版服</h2><h3 id="下载服务器核心-server-jar"><a href="#下载服务器核心-server-jar" class="headerlink" title="下载服务器核心 - server.jar"></a>下载服务器核心 - server.jar</h3><h4 id="Minecraft官方启动器下载server-jar"><a href="#Minecraft官方启动器下载server-jar" class="headerlink" title="Minecraft官方启动器下载server.jar"></a>Minecraft官方启动器下载server.jar</h4><p>这里不阐述官启本身的下载方式，仅展示如何通过官启下载对应版本的server.jar：</p><p>打开我的世界官方启动器，先点击“配置”，再点击“新建”，会出现新建页面，然后在如图所示位置先选择游戏版本，再点击“服务器”，就可以跳转到浏览器下载对应游戏版本的“server.jar”了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153605.png" alt="image-20210204193616825"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153609.png" alt="image-20210204193755584"></p><h4 id="我的世界中文Wiki下载server-jar"><a href="#我的世界中文Wiki下载server-jar" class="headerlink" title="我的世界中文Wiki下载server.jar"></a>我的世界中文Wiki下载server.jar</h4><blockquote><p>我的世界中文Wiki：<a href="https://minecraft-zh.gamepedia.com/Minecraft_Wiki">https://minecraft-zh.gamepedia.com/Minecraft_Wiki</a></p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153611.png" alt="image-20210204194521618"></p><h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>把server.jar放到一个文件夹中，比如我这里是 C:/Games/MinecraftServer 那么整个“MinecraftServer”文件夹就是这个服务器的文件夹。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153714.png" alt="image-20210204194845865"></p><p>打开cmd，cd到这个文件夹中，执行命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx2G -jar server.jar nogui</span><br><span class="line"># 内存大小可以自己设置，我本地单人服务端是这样设置的</span><br><span class="line">-Xms512M:   #分配最小内存<span class="number">512</span>M</span><br><span class="line">-Xmx2G:     #分配最大内存<span class="number">2</span>G</span><br><span class="line"><span class="function">nogui:      #服务器信息都在命令行输出，没有<span class="title">GUI</span></span></span><br></pre></td></tr></table></figure><p>你会发现服务器并没有完全启动起来，这是因为第一次启动服务端之后需要配置“eula.txt”以及“server.properties”文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153616.png" alt="image-20210204195452726"></p><p>修改“eula.txt”：打开此文件，将其中的“eula=false”修改为“eula=true”：</p><p>文件内容大致意思就是说不同意MOJANG的最终用户许可协议就不可以开服，设置为true后就是同意了，没得选，想开服只能同意</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153619.png" alt="image-20210204195833961"></p><p>此时就可以再次执行上面那条命令开服了，但是如果想对服务器做一些“定制”的话，需要修改一下“server.properties”文件再开服，此文件可以通过win10自带的“记事本”打开，文件每个属性各代表什么可以参考我的世界中文Wiki中的内容，这里仅指出几个我认为比较重要的：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">difficulty</span>=<span class="string">3    # 游戏难度改为“困难”，因为此模式下村民才可以百分之百转化成僵尸村民</span></span><br><span class="line"><span class="meta">level-seed</span>=     <span class="string"># 游戏种子，如果你希望使用特定的种子开服，那么填到这里</span></span><br><span class="line"><span class="meta">max-players</span>=<span class="string">5   # 服务器同时容纳的最大玩家数量，同时最多有多少个人可以在线</span></span><br><span class="line"><span class="attr">motd</span>=<span class="string">A Minecraft Server # 服务器的描述，在客户端的“多人游戏”那里可以看到这句话</span></span><br><span class="line"><span class="meta">online-mode</span>=<span class="string">true    # 可以理解为正版验证</span></span><br><span class="line"><span class="meta">server-ip</span>=          <span class="string"># 服务器IP，一般空着</span></span><br><span class="line"><span class="meta">server-port</span>=<span class="string">25565   # 服务器端口，如我本地访问的时候就是 127.0.0.1:25565</span></span><br><span class="line"><span class="meta">view-distance</span>=<span class="string">10    # 视距，服务器出现卡顿的情况下可缩小此值，一般建议默认</span></span><br><span class="line"><span class="meta">white-list</span>=<span class="string">true     # 开启白名单，以免奇奇怪怪的人进来</span></span><br><span class="line"><span class="meta">enforce-whitelist</span>=<span class="string">true  # 不在白名单列表中的用户会被踢出服务器</span></span><br></pre></td></tr></table></figure><p>注：<strong>如果你想给server.properties文件打注释的话，建议备份一下，然后把注释打到备份的文件里，不然你会发现运行之后你的注释都没了，文件中你自己调的属性顺序也都变回默认的了，当然属性值还是你自己设置的</strong></p><blockquote><p>我的世界中文Wiki - Server.properties：<a href="https://minecraft-zh.gamepedia.com/Server.properties">https://minecraft-zh.gamepedia.com/Server.properties</a></p></blockquote><p>设置好后就可以再次通过前面执行的命令开服了。</p><p>如果开启了白名单，则需要在终端运行时的服务端使用 /whitelist add username 的形式添加白名单，或者直接修改服务器文件夹下的 whitelist.json 文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153622.png" alt="image-20210204202458114"></p><p>关闭服务器时在运行着的服务器终端输入 /stop 即可。</p><p>可以把运行服务器的命令放到一个 .bat 文件中，这样可以直接在win10系统下运行这个 .bat 文件来开启服务端：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153625.png" alt="image-20210204203002984"></p><h3 id="部署到Linux服务器"><a href="#部署到Linux服务器" class="headerlink" title="部署到Linux服务器"></a>部署到Linux服务器</h3><blockquote><p>由于我没有买阿里云或者腾讯云、华为云的云服务器，所以这里我使用Linux虚拟机来代替</p></blockquote><p>需要设置或知道的云服务器信息：</p><ul><li>服务器IP地址 - 公网IP，云服务器会给分配</li><li>服务器开启SSH服务 - 一般此服务默认开启</li><li>服务器用户名和密码 - 服务器里一个用户的用户名和密码(最好不是root用户)</li></ul><p>我使用的工具：Xshell、Xftp。家庭、个人或学生不作为商业用途可以免费使用。</p><blockquote><p>软件官网：<br>Xshell：<a href="https://www.netsarang.com/zh/xshell/">https://www.netsarang.com/zh/xshell/</a><br>Xftp：<a href="https://www.netsarang.com/zh/xftp/">https://www.netsarang.com/zh/xftp/</a></p></blockquote><p>通过Xshell链接到Linux系统</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153627.png" alt="image-20210204204514595"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153630.png" alt="image-20210204204542724"></p><p>连接成功后的界面应如图所示(示例中的Linux系统是Ubuntu Server LTS 20.04)：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153632.png" alt="image-20210204205030197"></p><p>通过Xftp上传Server文件夹 - 建议先将文件夹压缩成ZIP包，再上传到服务器解压</p><p>直接拖动过去就可以执行上传操作，速度与带宽有关</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153635.png" alt="image-20210204205219967"></p><p>回到Xshell中，安装java8及unzip：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-8-jdk unzip</span><br></pre></td></tr></table></figure><p>安装结束之后查看java版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>解压服务端压缩包到指定文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip MinecraftServer.zip -d MinecraftServer</span><br></pre></td></tr></table></figure><p>cd到服务端文件夹，新建一个screen：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MinecraftServer/</span><br><span class="line">screen -S MC_server <span class="comment"># 这样当SSH关闭的时候，MC服务端依旧会在云服务器上运行</span></span><br></pre></td></tr></table></figure><p>查看服务器内存大小后，修改开服命令参数再执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>输出结果以M为单位，根据自己服务器的内存大小来定，比如我这里可以设置为最大内存1G。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153639.png" alt="image-20210204211651280"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx1G -jar server.jar nogui</span><br></pre></td></tr></table></figure><p>云服务器上执行的很慢属于正常现象，毕竟如果一年一百出头的云电脑能打得过几千块的笔记本的话，那还要啥实体机。</p><p>比如我此处的Linux系统IP地址是192.168.0.131，Minecraft服务器端口号是默认的25565，开放对应端口后(云服务器需要在控制台的安全组策略中开放对应端口，不然无法访问)，我就可以通过192.168.0.131:25565链接服务器了。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153642.png" alt="image-20210204213113871"></p><p>之后远程链接云服务器进行控制的时候，只需要执行“screen -R”就可以恢复之前创建的后台运行的程序了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -R</span><br></pre></td></tr></table></figure><h2 id="Fabric-mod服"><a href="#Fabric-mod服" class="headerlink" title="Fabric mod服"></a>Fabric mod服</h2><blockquote><p>我本地的单人服务端就是一个Fabric端，其中我添加了一些优化mod，获得了一些不是那么原版的功能以及对服务器的优化，所以Fabric端某种意义上也是原版端。<br>如果开Fabric服的话，除了原版服部分下载server.jar的两种方法以外，此处也可通过fabric下载server.jar</p></blockquote><h3 id="下载并安装Fabric"><a href="#下载并安装Fabric" class="headerlink" title="下载并安装Fabric"></a>下载并安装Fabric</h3><p>进入Fabric官网，点击如图所示下载fabric安装器</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153647.png" alt="image-20210205111007615"></p><blockquote><p>Fabric官网：<a href="https://fabricmc.net/use/">https://fabricmc.net/use/</a></p></blockquote><p>打开安装器，执行安装操作：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153650.png" alt="image-20210205112321558"></p><p>安装过程如果无科学上网的话会比较慢，但是可以下载完成，耐心等待即可。</p><p>如果没有下载服务端，则可以在此处下载“server.jar”核心文件，根据提示，需要将开服命令中的“server.jar”文字替换为“fabric-server-launch.jar”，注意，替换的是命令中的文字，而不是替换文件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153652.png" alt="image-20210205112459011"></p><p>开服命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Xms512M -Xmx2G -jar fabric-server-launch.jar nogui</span><br></pre></td></tr></table></figure><p>开服成功后的命令行信息与原版服基本一致：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/Minecraft%E6%8C%87%E5%8C%97/MinecraftJava%E7%89%88%E5%BC%80%E6%9C%8D%E6%8C%87%E5%8C%97/20210208153655.png" alt="image-20210205112937398"></p><h3 id="Fabric-服务端-mod推荐"><a href="#Fabric-服务端-mod推荐" class="headerlink" title="Fabric 服务端 mod推荐"></a>Fabric 服务端 mod推荐</h3><h4 id="Fabric-API-必装"><a href="#Fabric-API-必装" class="headerlink" title="Fabric API - 必装"></a>Fabric API - 必装</h4><p>基本上是一个必装mod，很多fabric的mod都需要他作为前置mod</p><blockquote><p>Curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/fabric-api/files/all">https://www.curseforge.com/minecraft/mc-mods/fabric-api/files/all</a></p></blockquote><h4 id="Carpet-优化-修Bug-假人"><a href="#Carpet-优化-修Bug-假人" class="headerlink" title="Carpet - 优化/修Bug/假人"></a>Carpet - 优化/修Bug/假人</h4><p>carpet模组是一个功能强大的模组，里面有很多的优化内容，可以修复或增加一些游戏特性，可以提供挂机的假人(我用的最多的就是假人)</p><blockquote><p>curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/carpet/files/all">https://www.curseforge.com/minecraft/mc-mods/carpet/files/all</a><br>github：<a href="https://github.com/gnembon/fabric-carpet">https://github.com/gnembon/fabric-carpet</a><br>wiki：<a href="https://github.com/gnembon/fabric-carpet/wiki/Current-Available-Settings">https://github.com/gnembon/fabric-carpet/wiki/Current-Available-Settings</a>  </p></blockquote><p>我的Carpet配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onePlayerSleeping true      # 单人睡觉跳过夜晚 - 我的服务器里只有假人</span><br><span class="line">commandPlayer true          # 生存玩家可以使用 &#x2F;player 指令 - 假人相关</span><br><span class="line">leadFix true                # 修复缰绳bug</span><br><span class="line">antiCheatDisabled true      # 关闭反飞行 - 因为我红石机器排错时会使用 Tweakroo 的 FreeCamera 功能</span><br><span class="line">defaultLoggers mobcaps,tps  # 默认加载 mobcaps 和 tps 信息 - Tab 键显示这些信息</span><br><span class="line">lagFreeSpawning true        # 减少CPU和内存占用</span><br></pre></td></tr></table></figure><h4 id="化学元素三件套-lithium、sodium、phosphor"><a href="#化学元素三件套-lithium、sodium、phosphor" class="headerlink" title="化学元素三件套 - lithium、sodium、phosphor"></a>化学元素三件套 - lithium、sodium、phosphor</h4><p>同一个作者的三个优化mod，装在服务端可以显著减少卡顿，客户端可不装，mod简介可以参考我的世界中文论坛中的帖子：</p><blockquote><p>我的世界中文论坛(MCBBS)：<br>Lithium：<a href="https://www.mcbbs.net/thread-1080959-1-1.html">https://www.mcbbs.net/thread-1080959-1-1.html</a><br>Sodium：<a href="https://www.mcbbs.net/thread-1079347-1-1.html">https://www.mcbbs.net/thread-1079347-1-1.html</a><br>Phosphor：<a href="https://www.mcbbs.net/thread-1081821-1-1.html">https://www.mcbbs.net/thread-1081821-1-1.html</a><br>Curseforge：<br><a href="https://www.curseforge.com/minecraft/mc-mods/lithium/files/all">https://www.curseforge.com/minecraft/mc-mods/lithium/files/all</a><br><a href="https://www.curseforge.com/minecraft/mc-mods/sodium/files/all">https://www.curseforge.com/minecraft/mc-mods/sodium/files/all</a><br><a href="https://www.curseforge.com/minecraft/mc-mods/phosphor/files/all">https://www.curseforge.com/minecraft/mc-mods/phosphor/files/all</a></p></blockquote><h4 id="BBOR-建筑生成查看"><a href="#BBOR-建筑生成查看" class="headerlink" title="BBOR - 建筑生成查看"></a>BBOR - 建筑生成查看</h4><p>可以查看出生点范围，各种建筑的轮廓</p><blockquote><p>Curseforge：<a href="https://www.curseforge.com/minecraft/mc-mods/bounding-box-outline-reloaded/files/all">https://www.curseforge.com/minecraft/mc-mods/bounding-box-outline-reloaded/files/all</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Minecraft指北 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox基础使用教程</title>
      <link href="2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>选择VirtualBox而不是VMware Workstation的原因：VirtualBox是开源软件，对于个人的Linux学习来说，既免费又够用，且相较于VMware Workstation来说更为小巧，也没有那么多的自启动服务，不会在你不使用虚拟机的时候也有那么多服务在后台运行。  </p></blockquote><h2 id="下载并安装VirtualBox"><a href="#下载并安装VirtualBox" class="headerlink" title="下载并安装VirtualBox"></a>下载并安装VirtualBox</h2><p>注：<strong>以下说明以Win10系统为例，使用其他系统操作会有一些不同</strong></p><h3 id="下载VirtualBox"><a href="#下载VirtualBox" class="headerlink" title="下载VirtualBox"></a>下载VirtualBox</h3><p>找到VirtualBox官网，在下载界面选择自己想要下载的版本即可，我这里是Win10系统，选择“Windows Hosts”即可：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152117.png" alt="image-20210128162739725"></p><blockquote><p>VirtualBox官网下载界面：<a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p></blockquote><h3 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h3><p>安装VirtualBox的注意事项并不多，基本上按他默认的内容来即可，其中安装位置按照自己习惯进行选择，我之前也觉着装在C盘会拖慢系统，会单独分区进行安装软件，但是现在固态硬盘读写速度极快，也不像机械硬盘有磁盘碎片，装不装在C盘对系统的影响微乎其微，所以我现在基本上按照软件的默认位置直接安装。(非专业人士，没做过详细比对，软件安装选择默认的C盘路径仅个人想法)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152121.png" alt="image-20210128171122821"></p><h2 id="配置VirtualBox"><a href="#配置VirtualBox" class="headerlink" title="配置VirtualBox"></a>配置VirtualBox</h2><h3 id="修改虚拟机的默认安装位置"><a href="#修改虚拟机的默认安装位置" class="headerlink" title="修改虚拟机的默认安装位置"></a>修改虚拟机的默认安装位置</h3><p>VirtualBox创建的虚拟机的默认位置在用户路径”C:\Users\username&quot;下，安装位置可改可不改，根据个人习惯即可。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152123.png" alt="image-20210128172029879"></p><h3 id="注册系统安装镜像"><a href="#注册系统安装镜像" class="headerlink" title="注册系统安装镜像"></a>注册系统安装镜像</h3><p>VirtualBox并不会对你的计算机进行全盘扫描来寻找镜像文件，所以需要指定这些镜像文件的位置，即便不指定位置，也可以在创建虚拟机的时候再注册镜像文件，但是我习惯于提前注册：</p><p>在VirtualBox的主界面点击左上角的“管理”，然后点击“虚拟介质管理”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152127.png" alt="image-20210128173829678"></p><p>依次选择“虚拟光盘”、“注册”以及要注册的镜像文件</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152129.png" alt="image-20210128174019686"></p><h2 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h2><h3 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h3><p>点击“工具”之后可以看到“新建”选项，点击后开始新建虚拟机的流程。</p><h4 id="名称、位置、类型及版本"><a href="#名称、位置、类型及版本" class="headerlink" title="名称、位置、类型及版本"></a>名称、位置、类型及版本</h4><p>名称：这个虚拟机在你的电脑中的名字，可以理解为文件名<br>文件夹：虚拟机存储位置的父目录，会在这个文件夹里新建一个存储虚拟机的文件夹<br>类型和版本：选择自己想要安装的虚拟机的种类即可，种类不一致会一些问题  </p><blockquote><p>注：对于Linux系统，如果要安装的不是主流发行版的话，版本一栏不会给出具体的发行版名称，这时需要选择“Other Linux”</p></blockquote><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152133.png" alt="image-20210129131629346"></p><h4 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h4><p>一般情况下默认分配的内存大小是让这个系统处于“能用”范畴的内存大小，如果要想“流畅地使用”虚拟机，物理机内存较大的情况下建议多分配一些。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152136.png" alt="image-20210129131700510"></p><h4 id="虚拟硬盘"><a href="#虚拟硬盘" class="headerlink" title="虚拟硬盘"></a>虚拟硬盘</h4><p>虚拟硬盘选项如图所示，不做赘述，一般按照默认的“现在创建虚拟硬盘”即可。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152139.png" alt="image-20210129131716155"></p><p>可以选择的虚拟硬盘种类：</p><ul><li>VDI：VirtualBox的专用的磁盘映像种类，仅可供VirtualBox自己使用  </li><li>VHD：Microsoft Virtual PC的原生格式(本人了解也不多)  </li><li>VMDK：VMware的虚拟机磁盘种类，除了可供VMware使用以外，可供市面上大部分常用的虚拟机软件使用</li></ul><p>如果没有将此虚拟机转移到别的虚拟机软件中使用的需求的话，使用默认的VDI类型即可。即便是此时选择了VDI类型，之后也可以使用VirtualBox自带的VBoxManager更改磁盘类型以适配别的虚拟机软件。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152142.png" alt="image-20210129131728694"></p><p>动态分配和固定分配的优缺点如图所示，需要注意的是“固定大小”不仅直接将创建好的空间完全分配给虚拟硬盘，后续也无法改变这块硬盘的大小，我一般选择动态分配</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152145.png" alt="image-20210129131737708"></p><p>磁盘大小依照自己要装的系统而定，不要盲目信任软件给出的推荐大小，比如CentOS的推荐大小是8GB，如果是安装Server版那么算是绰绰有余，但若是安装带GUI的完全版，则会因为空间太小而无法安装，所以明确自己要装的系统需要多大的空间也是一件非常重要的事。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152147.png" alt="image-20210129131746654"></p><h3 id="设置虚拟机"><a href="#设置虚拟机" class="headerlink" title="设置虚拟机"></a>设置虚拟机</h3><p>进入对虚拟机的设置项，对虚拟机做一些较为详细的设置。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152150.png" alt="image-20210129131858099"></p><h4 id="常规设置"><a href="#常规设置" class="headerlink" title="常规设置"></a>常规设置</h4><p>对于有图形界面的虚拟机一般可以开启“共享粘贴板”和“拖放”这两项设置，便于物理机和虚拟机之间的交互(需要安装增强工具)，比如我这里的“Win10”虚拟机，当我开启这两个选项并安装“增强工具”之后，就可以实现物理机与虚拟机之间这种较为便捷的交互。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152153.png" alt="image-20210129132025514"></p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><p>内存：如果不满意之前的内存分配，可以在这里重新分配内存大小<br>EFI：对于有EFI需求的系统可以开启，对于部分系统开启此处后可以提升一些使用体验，比如openEuler在不开启EFI的情况下，安装时会有部分内容显示不完全，开启之后显示的分辨率更好且显示内容完全</p><p>处理器数量：与内存的分配原则类似，适当增加这里的处理器数量可以提升虚拟机的流畅性，但是这里分配太多的话会引起物理机的卡顿从而虚拟机也卡</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152156.png" alt="image-20210129132341342"></p><h4 id="显示设置"><a href="#显示设置" class="headerlink" title="显示设置"></a>显示设置</h4><p>显存大小：与内存的分配原则类似<br>硬件3D加速：如果物理机配置好的话可以开启，能使虚拟机的画面更为流畅甚至绚丽(若要安装的是只是用CUI的Linux系统，则没必要开启)，但物理机配置不够好的情况下会导致双方都卡顿</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152159.png" alt="image-20210129132430852"></p><h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><ol><li><p>网络地址转换(NAT)：可以将物理机理解为一个路由器，虚拟机的网络都经过物理机转发之后与外界网络进行链接</p><ul><li>优点：无需进行复杂设置，就可以使虚拟机联网</li><li>缺点：使用SSH链接虚拟机或需要访问虚拟机的某个端口时，需要先将虚拟机端口映射到物理机的端口，当需要使用的端口数较多时，设置起来有些烦人</li></ul></li><li><p>桥接网卡：将物理机的网卡虚拟化，虚拟机也可经过此网卡联网，与物理机在同一个网段下(在同一个局域网下)</p><ul><li>优点：虚拟机有自己的IPv4地址，与物理机在一个网段下，可以互相ping通</li><li>缺点：一般仅适用于有自己的路由器的情况，尤其是校园网用户一般情况下无法使用(校园网转路由器则可使用)</li></ul></li><li><p>仅主机(Host-Only)网络：虚拟机没有访问外网的能力，仅可以与物理机交互</p></li></ol><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208152203.png" alt="image-20210129132816115"></p><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><p>点击启动，VirtualBox虚拟机在第一次启动时会要求你选择系统镜像，选择好要使用的镜像后，执行对应系统的安装过程即可。</p><p>如果安装系统时要断网安装(如Win10系统，我安装的时候习惯在断网情况下安装，以免在安装过程给我弄一大堆没用的东西)，需要在“网络设置”中不启用网络连接。</p><h2 id="实例-安装openEuler虚拟机"><a href="#实例-安装openEuler虚拟机" class="headerlink" title="实例 - 安装openEuler虚拟机"></a>实例 - 安装openEuler虚拟机</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="下载openEuler系统镜像"><a href="#下载openEuler系统镜像" class="headerlink" title="下载openEuler系统镜像"></a>下载openEuler系统镜像</h4><p>首先进入openEuler的官网，并点击“下载”按钮</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151741.png" alt="image-20210203214744209"></p><blockquote><p>openEuler官网：<a href="https://openeuler.org/zh/">https://openeuler.org/zh/</a></p></blockquote><p>选中“LTS”即 Long Term Support(长期支持) 版本，在筛选出来的版本中找一个合适的版本，合适与否因人而异，一般带有最新的补丁的LTS版即可，此处我选择的是“openEuler 20.03 LTS SP1”，然后点击其对应的“下载”按钮</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151745.png" alt="image-20210203215435882"></p><p>依次选择“ISO”、“x86_64”，可以到达镜像及SHA256类型的HASH校验和文件列表，此处我选择的分别是“openEuler-20.03-LTS-SP1-x86_64-dvd.iso”以及“openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum”</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151748.png" alt="image-20210203220443535"></p><blockquote><p>openEuler-20.03-LTS-SP1-x86_64-dvd.iso：<a href="https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso">https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso</a><br>openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum：<a href="https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum">https://repo.openeuler.org/openEuler-20.03-LTS-SP1/ISO/x86_64/openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum</a></p></blockquote><h4 id="校验openEuler系统镜像"><a href="#校验openEuler系统镜像" class="headerlink" title="校验openEuler系统镜像"></a>校验openEuler系统镜像</h4><p>为了验证文件的完整性，需要对系统镜像进行HASH校验，若计算得出的校验和与官方提供的不一致，则说明完整性被破坏，需要重新下载</p><p>这里由于校验和文件的后缀名是“sha256sum”，可以得出校验类型是“SHA256”，在Windows系统下可以在终端输入指令来计算校验和，比如我的校验命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Get-FileHash D:\Linux_ISO\openEuler-<span class="number">20</span>.<span class="number">03</span>-LTS-SP1-x86_64-dvd.iso -Algorithm SHA256| <span class="built_in">Format</span>-List</span><br></pre></td></tr></table></figure><p>其中“D:\Linux_ISO\openEuler-20.03-LTS-SP1-x86_64-dvd.iso”是我电脑中的镜像文件存储路径，请替换路径后使用校验命令进行校验</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151752.png" alt="image-20210203221742431"></p><p>然后与“openEuler-20.03-LTS-SP1-x86_64-dvd.iso.sha256sum”中的校验和进行比较，“sha256sum”文件可以使用Windows自带的“记事本”打开，在打开方式中选择对应应用即可</p><h3 id="在Virtual中安装openEuler"><a href="#在Virtual中安装openEuler" class="headerlink" title="在Virtual中安装openEuler"></a>在Virtual中安装openEuler</h3><blockquote><p>“新建”及“设置”属于VirtualBox的操作，其具体细节可以参考文章首部提供的博文链接： <a href="https://leok77.github.io/2021/01/28/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">VirtualBox的简单使用教程</a> ，这里仅给出一些需要注意的点</p></blockquote><h4 id="新建openEuler虚拟机"><a href="#新建openEuler虚拟机" class="headerlink" title="新建openEuler虚拟机"></a>新建openEuler虚拟机</h4><h5 id="系统类型"><a href="#系统类型" class="headerlink" title="系统类型"></a>系统类型</h5><p>openEuler是一款社区支持的开源的Linux系统，基于CentOS定制而成，但是不隶属于CentOS的母公司Rad Hat，所以这里应该选择的版本是Other Linux(64-bit)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151755.png" alt="image-20210204093206163"></p><h5 id="最小虚拟化空间要求"><a href="#最小虚拟化空间要求" class="headerlink" title="最小虚拟化空间要求"></a>最小虚拟化空间要求</h5><p>openEuler官方文档中给出的最小虚拟化空间要求如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151758.png" alt="image-20210204093727166"></p><p>实测在使用Server版的情况下，并不需要严格按照这里的要求，参照CentOS Server虚拟机的配置即可，内存2GB，硬盘8GB(我习惯性凑整改成了10GB)。</p><h4 id="设置openEuler虚拟机"><a href="#设置openEuler虚拟机" class="headerlink" title="设置openEuler虚拟机"></a>设置openEuler虚拟机</h4><ol><li><p>在“系统设置”启用EFI，这样可以让安装系统的界面更为友好，主要体现为不会有内容显示在显示器外部(即显示器可以完全显示图形界面)</p></li><li><p>如果要安装带GUI的虚拟机，为了GUI的流畅性，还可以在“显示设置”中启用3D加速，并增大显存大小</p></li><li><p>如果对于之前分配的硬盘存储空间不满意，可以在“管理”-“虚拟介质管理”找到对应的“虚拟硬盘”，并增加其大小，VirtualBox暂不支持缩小虚拟硬盘</p></li></ol><h4 id="安装openEuler虚拟机"><a href="#安装openEuler虚拟机" class="headerlink" title="安装openEuler虚拟机"></a>安装openEuler虚拟机</h4><h5 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h5><p>设置好后，点击“启动”虚拟机，VirtualBox虚拟机第一次启动时会要求选择安装镜像，选择好镜像后进入系统安装页面。</p><p>在安装页面选择默认的“Test this media &amp; install openEuler”即可，即先验证镜像再安装，可以检测出一些镜像可能存在的奇奇怪怪的问题(实际上经过校验之后的镜像一般是不会存在问题的)。</p><p>验证完之后会开始安装过程，因为我仅使用CLI(命令行终端)，不使用GUI，所以我选择的语言是美式英语</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151801.png" alt="image-20210204125331352"></p><h5 id="Software-Selection"><a href="#Software-Selection" class="headerlink" title="Software Selection"></a>Software Selection</h5><p>软件选择可以理解为版本安装，因为这个镜像中包含了很多的软件，而需要安装的并不是全部，给出的有“Minimal Install”、“Server”、“Virtualization Host”三个基础内容，安装时选择基础版本，再选择右侧的额外软件包即可。</p><p>我选择安装的是“Server”版，未安装右侧提供的额外软件。</p><h5 id="Installation-Destination"><a href="#Installation-Destination" class="headerlink" title="Installation Destination"></a>Installation Destination</h5><p>安装位置选择，一般情况下默认的自动分配即可，但是需要先把它点开一下，否则默认的自动分配是不生效的，且无法进入下面的安装阶段。</p><h5 id="Network-amp-Host-Name"><a href="#Network-amp-Host-Name" class="headerlink" title="Network &amp; Host Name"></a>Network &amp; Host Name</h5><p>Host Name即主机名，在局域网中若开启让其他网络设备发现的功能，那么其他设备看到的此主机名字就是此处设置的名字，修改后别忘了点击“Apply”，不然不生效</p><h5 id="Root-Password"><a href="#Root-Password" class="headerlink" title="Root Password"></a>Root Password</h5><p>设置超级管理员账户的密码，密码要求如下：</p><ul><li>口令长度至少8个字符。</li><li>口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。</li><li>口令不能和账号一样。</li><li>口令不能使用字典词汇。</li></ul><h5 id="User-Creation-可选项"><a href="#User-Creation-可选项" class="headerlink" title="User Creation(可选项)"></a>User Creation(可选项)</h5><p>添加一个普通用户/管理员，管理员需要选择“Make this user administrator”，这样这个用户就可以“sudo”了，密码要求与Root Password的要求一致。</p><p>建议在这里添加一个管理员用户，一般情况下没必要以root用户运行。</p><h5 id="Begin-Installation"><a href="#Begin-Installation" class="headerlink" title="Begin Installation"></a>Begin Installation</h5><p>以上信息都设置好之后就可以点击“Begin Installation”开始安装了。</p><p>安装结束之后，点击“Reboot System”，就可以重启进入系统了。</p><h3 id="SSH连接openEuler"><a href="#SSH连接openEuler" class="headerlink" title="SSH连接openEuler"></a>SSH连接openEuler</h3><p>连接openEuler的IP地址以及端口号需要根据网络模式来决定</p><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换(NAT)"></a>网络地址转换(NAT)</h4><p>使用“ip addr”获取虚拟机的IP地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151806.png" alt="image-20210206143759055"></p><p>打开虚拟机的网络设置：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151808.png" alt="image-20210206143915209"></p><p>设置端口转发规则：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151811.png" alt="image-20210206144146988"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主机IP：    127.0.0.1   ## localhost</span><br><span class="line">主机端口：  10122       ## 自己设置，避开特定的那些端口</span><br><span class="line">子系统IP：  10.0.2.15   ## 通过“ip addr”获取的IP地址</span><br><span class="line">子系统端口：22          ## SSH服务的默认端口</span><br></pre></td></tr></table></figure><p>那么通过SSH连接openEuler时的IP地址就是127.0.0.1，端口号是10122：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151814.png" alt="image-20210206144534640"></p><h4 id="桥接网卡"><a href="#桥接网卡" class="headerlink" title="桥接网卡"></a>桥接网卡</h4><h5 id="DHCP自动获取IP"><a href="#DHCP自动获取IP" class="headerlink" title="DHCP自动获取IP"></a>DHCP自动获取IP</h5><p>通过“ip addr”获取openEuler的IP地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151818.png" alt="image-20210206144751919"></p><p>那么通过SSH连接openEuler时的IP地址就是192.168.0.103，端口号是默认的22：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151820.png" alt="image-20210206144946060"></p><h5 id="设置静态IP-可选项"><a href="#设置静态IP-可选项" class="headerlink" title="设置静态IP(可选项)"></a>设置静态IP(可选项)</h5><blockquote><p>适用场景：非校园网用户，虚拟机的网络链接方式是桥接模式</p></blockquote><h6 id="获取物理机的IP信息"><a href="#获取物理机的IP信息" class="headerlink" title="获取物理机的IP信息"></a>获取物理机的IP信息</h6><p>以Win10系统为例，打开cmd，执行“ipconfig”：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br></pre></td></tr></table></figure><p>找到如图所示的信息，需要有方框中框出的这三项信息。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151824.png" alt="image-20210204130106958"></p><p>由此得出了物理机的IP信息为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Address:    IPv4地址:   192.168.0.111</span><br><span class="line">Netmask:    子网掩码:   255.255.255.0</span><br><span class="line">Gateway:    默认网关:   192.168.0.1</span><br></pre></td></tr></table></figure><p>在cmd执行“arp -a”</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure><p>找到接口为物理机IPv4地址的信息，列出的这些Internet地址是已经被分配了的，openEuler设置静态IP时要避开，192.168.0.116是当前分配给openEuler的IP地址，可以通过“ip addr”查看</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151826.png" alt="image-20210204130413555"></p><h6 id="设置openEuler的静态IP"><a href="#设置openEuler的静态IP" class="headerlink" title="设置openEuler的静态IP"></a>设置openEuler的静态IP</h6><p>输入命令“ip addr”查看网卡名字(一般是enp0s3)</p><p>编辑“/etc/sysconfig/network-scripts/ifcfg-enp0s3”文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure><p>找到“BOOTPROTO=dhcp”，将其注释掉并添加“BOOTPROTO=static”</p><p>在文末添加如下信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.0.121    ## 不能是前面已分配的地址</span><br><span class="line">NETMASK&#x3D;255.255.255.0   ## 与物理机一致</span><br><span class="line">GATEWAY&#x3D;192.168.0.1     ## 与物理机一致</span><br><span class="line">DNS1&#x3D;223.5.5.5          ## 阿里云公共DNS</span><br><span class="line">DNS2&#x3D;180.76.76.76       ## 百度公共DNS</span><br></pre></td></tr></table></figure><p>修改完后文件如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151830.png" alt="image-20210204151402588"></p><p>在终端执行“sudo nmcli c reload”刷新网络信息，并执行“sudo nmcli c up enp0s3”使变更立即生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli c reload</span><br><span class="line">sudo nmcli c up enp0s3</span><br></pre></td></tr></table></figure><p>那么通过SSH连接openEuler时的IP地址就是192.168.0.121，端口号是默认的22：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E4%BD%8E%E6%8A%80%E6%9C%AF%E5%8A%9BCS%E6%8A%80%E8%83%BD%E5%88%86%E4%BA%AB/VirtualBox%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/20210208151832.png" alt="image-20210206145541614"></p>]]></content>
      
      
      <categories>
          
          <category> 低技术力CS技能分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VirtualBox </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10软件推荐</title>
      <link href="2021/01/27/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>2021/01/27/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>这篇博文是为了分享和记录一下我正在用的win10平台的一些软件，软件这种东西仁者见仁智者见智，仅供参考。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>安装并首次完全更新完win10系统之后我做的第一件事：安装浏览器</p><p>这里推荐两款浏览器，分别是微软的新版Edge浏览器，和火狐浏览器。首先阐述一下我不使用旧版Edge的原因：我使用旧版Edge的时候，时常会出现用浏览器下载东西卡住的现象，虽然浏览器的本职工作不包括下载，但是一个系统刚安装好的时候，下载别的软件都是要通过浏览器的，而我多次重装系统的经验告诉我，旧版Edge的下载功能极其羸弱，这一点使得我对这款浏览器并不感冒。</p><h3 id="新版Edge浏览器"><a href="#新版Edge浏览器" class="headerlink" title="新版Edge浏览器"></a>新版Edge浏览器</h3><p>新版Edge浏览器基于谷歌的开源Chromium内核(其实市面上很多浏览器都是采用的这个内核)，且支持Windows/Mac/Android/IOS平台的同步功能(截至2021年1月27日，Linux平台的Microsoft Edge浏览器尚未提供账号登陆功能)，对于喜欢多个平台共用同一款浏览器，且使用同步的收藏夹、密码等内容的用户来说是一款很棒的浏览器，且使用的账号是微软账号，不需要像Chrome浏览器那样科学上网才可以同步。但是需要注意新版Edge和旧版Edge不可以并存，若要使用旧版Edge的话，请不要升级到新版的Edge浏览器。</p><blockquote><p>Edge官网地址：<a href="https://www.microsoft.com/zh-cn/edge">https://www.microsoft.com/zh-cn/edge</a></p></blockquote><h3 id="FireFox火狐浏览器"><a href="#FireFox火狐浏览器" class="headerlink" title="FireFox火狐浏览器"></a>FireFox火狐浏览器</h3><p>火狐浏览器支持全平台(包括Linux平台，广为流传的Ubuntu的默认浏览器就是火狐浏览器)，且提供同步服务(由于中国国情，提供的同步服务分为全球服务和国内服务，且两个同步服务不互通)，在新版Edge面世之前我一直使用的是火狐浏览器，且当我使用带图形界面的Linux系统时，火狐浏览器是我的首选。乍一看火狐浏览器几乎没有缺点，应该是我没有设置好的原因，当我使用火狐浏览器的时候，偶尔会出现页面加载很慢的现象(网络正常且要访问的页面不是需要科学上网的页面)，所以新版Edge出现之后我选择了新版Edge。</p><blockquote><p>Firefox官网地址：<a href="https://www.firefox.com.cn/">https://www.firefox.com.cn/</a><br>注：在Linux平台使用发行版自带的软件库时，安装的火狐浏览器可能不提供国内同步服务，请使用来自火狐中文社区的拓展：<a href="http://mozilla.com.cn/thread-343905-1-1.html">http://mozilla.com.cn/thread-343905-1-1.html</a> (参考自ArchWiki)。</p></blockquote><p>PS:搜索引擎建议使用微软的必应，因为百度的搜索结果往往不是那么靠谱，毕竟跟钱沾边；谷歌搜索需要科学上网，挺麻烦的。</p><blockquote><p>必应国内版：<a href="https://cn.bing.com/">https://cn.bing.com/</a></p></blockquote><h2 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h2><h3 id="Internet-Download-Manager下载器"><a href="#Internet-Download-Manager下载器" class="headerlink" title="Internet Download Manager下载器"></a>Internet Download Manager下载器</h3><p>IDM下载器(注意这是一个付费软件)，Windows平台的一个多线程下载利器，支持浏览器资源嗅探，在下载的时候基本可以跑满带宽且不会像迅雷一样占用极大资源，直观表现就是风扇不会起飞。但是不支持BT和ed2k下载。</p><blockquote><p>IDM官网：<a href="https://www.internetdownloadmanager.com/">https://www.internetdownloadmanager.com/</a></p></blockquote><h3 id="qBittorrent-Enhanced-Edition-BT下载利器"><a href="#qBittorrent-Enhanced-Edition-BT下载利器" class="headerlink" title="qBittorrent-Enhanced-Edition - BT下载利器"></a>qBittorrent-Enhanced-Edition - BT下载利器</h3><p>顾名思义，qBittorrent-Enhanced-Edition是qBittorrent的增强版，我认为相比于qBittorrent来说最值得提一嘴的是增加了自动更新Tracker的功能，按照我的理解，Tracker就是记录这个资源在哪儿有，也把你的信息分享到Tracker服务器供别人下载。</p><p>BT社区需要大家一起维护，不要觉着迅雷好用就只用迅雷，现在国内BT社区环境不好很大一部分原因就是迅雷的问题，也许会有人觉着普通用户用啥软件都一样，请参考百度网盘，迅雷比百度网盘还算良心，但是恶心就是恶心，没得洗。</p><blockquote><p>qBittorrent-Enhanced-Edition：<a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a><br>Tracker(自带默认)：<a href="https://cdn.jsdelivr.net/gh/ngosang/trackerslist/trackers_best.txt">https://cdn.jsdelivr.net/gh/ngosang/trackerslist/trackers_best.txt</a><br>Tracker：<a href="https://trackerslist.com/#/zh">https://trackerslist.com/#/zh</a></p></blockquote><h3 id="迅雷-推荐仅限于Ed2K连接使用"><a href="#迅雷-推荐仅限于Ed2K连接使用" class="headerlink" title="迅雷 - 推荐仅限于Ed2K连接使用"></a>迅雷 - 推荐仅限于Ed2K连接使用</h3><p>迅雷，让人又爱又恨，但国内的ed2k工具我没有找到比他更棒的替代品，所以他也是我电脑里的下载器之一，当然仅限于下载ed2k链接的时候我才会把它打开，平时他必然是被我关掉的，弹窗和时不时占资源着实让人恶心。嫌弃归嫌弃，但是用起来也确实简单易懂。</p><blockquote><p>迅雷官网：<a href="https://www.xunlei.com/">https://www.xunlei.com/</a></p></blockquote><h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><h3 id="Visual-Studio-Code：一款近乎全能的文本编辑器"><a href="#Visual-Studio-Code：一款近乎全能的文本编辑器" class="headerlink" title="Visual Studio Code：一款近乎全能的文本编辑器"></a>Visual Studio Code：一款近乎全能的文本编辑器</h3><p>VScode，微软家的一大力作，装上插件之后可以被称为神器，但是我并没有装多少插件，仅仅是把他当作文本编辑器来用(像我这样的菜鸡写代码的时候当然是选择用IDE了，JetBrains永远的神)，主要是因为使用起来不占多少资源，且可以将文件保存为几乎任意类型(默认自带的记事本就不行，我想要将一个文件保存为没有后缀名的文件的时候，记事本都会把它保存为文本文件即TXT)，编辑文本的时候十分好用。</p><blockquote><p>VScode官网：<a href="https://code.visualstudio.com/#alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p></blockquote><p>我选择的是System Installer，即将VScode安装为此计算机的所有用户都可以使用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153835.png" alt="image-20210127114145372"></p><p>安装时建议勾选“其他”这一栏的这几项，这样在想编辑一些文件时就可以方便地直接打开VScode对其进行编辑，而不需要改变这些文件的默认应用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153837.png" alt="image-20210127114724973"></p><h3 id="Typora：Markdown编辑器"><a href="#Typora：Markdown编辑器" class="headerlink" title="Typora：Markdown编辑器"></a>Typora：Markdown编辑器</h3><p>Typora，markdown神器，编辑markdown文件时的首选软件，支持“所见即所得”，也就是输入之后直接转换为对应markdown格式，而不是左右分屏一边是源代码一边是markdown转义之后的文章。</p><p>但也并不是完美无缺，有时会出现渲染错误(可能是我的个例，说白了就是自己的Markdown语法掌握的不好，写出有歧义的格式)，所以我现在主要使用markdown来读文章或者插入图片，写文章的时候其实是使用Typora搭配VScode(搭配Markdown All in One以及markdownlint这两个插件)一起用的。</p><blockquote><p>Typora官网：<a href="https://typora.io/">https://typora.io/</a></p></blockquote><h2 id="工具：适合开机自启"><a href="#工具：适合开机自启" class="headerlink" title="工具：适合开机自启"></a>工具：适合开机自启</h2><blockquote><p>以下的工具都是我选择开机自启的工具，当然个别可能还是用的时候再开比较好，但我的使用习惯是这些开机自启，而且这些工具占用资源也不多，我内存还蛮大的(16G)，不会因为这些小工具爆内存，顶多偶尔CPU飚上去(点名火绒)。</p></blockquote><h3 id="火绒安全软件：杀毒-弹窗拦截"><a href="#火绒安全软件：杀毒-弹窗拦截" class="headerlink" title="火绒安全软件：杀毒+弹窗拦截"></a>火绒安全软件：杀毒+弹窗拦截</h3><p>火绒安全软件，很多人说win10自带的Windows Defender就很棒，不需要其他的杀毒软件，但是多一重保护比没有好，而且不怎么占用资源。</p><p>其实我使用火绒的主要目的是使用他的弹窗拦截功能，所以如果自己电脑没有带弹窗的软件的话可以跳过这儿了，可以自己比对火绒的弹窗库来找出电脑中有哪些软件带弹窗，也可以自己选择想阻拦哪些窗口，十分的轻量又好用。(如我电脑里用的时候才开的迅雷，就被他无情的进行了拦截)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153840.png" alt="火绒弹窗拦截截屏"></p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153843.png" alt="image-20210127155501216"></p><p>美中不足的就是有时候开机会占用一大片资源以及自动查杀时CPU占用很高导致风扇狂转，但是大多数情况下我都感受不到这个软件的存在。</p><blockquote><p>火绒安全官网：<a href="https://huorong.cn/">https://huorong.cn/</a></p></blockquote><h3 id="网易邮箱大师：多平台邮箱一同管理"><a href="#网易邮箱大师：多平台邮箱一同管理" class="headerlink" title="网易邮箱大师：多平台邮箱一同管理"></a>网易邮箱大师：多平台邮箱一同管理</h3><p>网易邮箱大师，支持Windows/MacOS/Android/IOS平台且提供同步服务，相比于Win10自带的Mail来说更为人性化(个人观点)，且在新平台登录网易邮箱大师的时候，你所添加过的邮箱是要求你重新验证一遍密码的，基本上不用担心网易账号泄露之后所有的邮箱都被泄露。</p><blockquote><p>网易邮箱大师官网：<a href="http://mail.163.com/dashi/">http://mail.163.com/dashi/</a></p></blockquote><h3 id="Snipaste：截屏神器"><a href="#Snipaste：截屏神器" class="headerlink" title="Snipaste：截屏神器"></a>Snipaste：截屏神器</h3><p>Snipaste，功能强大的截屏软件，绑定快捷键之后可以快捷键截屏，且截屏具有窗口捕获功能，即他会判定一下鼠标所在的窗口，然后优先截屏范围是这个窗口的范围，也支持鼠标指针按住之后选择范围，且可以增加矩形框、马赛克、箭头、文字等内容，截屏之后也可以选择保存到剪切板或直接保存为图片，十分的人性化。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153851.png" alt="image-20210127143720953"></p><p>如图所示，截屏的瞬间CPU占用为0.5%，内存占用为12.5M，磁盘占用0.1M/s；而日常待机时仅占用12.3M的内存，不会给电脑带来很大的负担。</p><blockquote><p>Snipaste官网：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></p></blockquote><h3 id="腾讯桌面整理"><a href="#腾讯桌面整理" class="headerlink" title="腾讯桌面整理"></a>腾讯桌面整理</h3><p>腾讯桌面整理，这款软件放在“工具”而不是“腾讯系软件”的原因是这真的是一款好软件，不要因为患有“腾讯PTSD”就抗拒他，在竞品中免费且不抢占大量资源。</p><p>可以下载的独立于腾讯电脑管家之外的小软件，可以双击隐藏/显示桌面图标，在桌面上以网格的形式存放一些软件，提供的文件搜索工具响应速度和搜索结果整理强于Windows的文件管理器。其提供的壁纸功能请自己选择是否使用，本人是不使用的。</p><p>主要功能的效果图：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153854.png" alt="image-20210127150643067"></p><p>下载时请注意下载“桌面整理独立版”，如果点的是立即下载的话，那么安装的是腾讯电脑管家。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153857.png" alt="image-20210127163152412"></p><blockquote><p>腾讯桌面整理官网：<a href="https://guanjia.qq.com/product/zmzl/">https://guanjia.qq.com/product/zmzl/</a></p></blockquote><h3 id="Everything-搜索神器"><a href="#Everything-搜索神器" class="headerlink" title="Everything - 搜索神器"></a>Everything - 搜索神器</h3><p>一开始我是抗拒Everything的，因为在知乎看到了太多吹他的软文，以为有什么猫腻，后来厌倦了腾讯桌面整理的搜索引擎之后(因为个人权限配置问题，激活的时候需要管理员)，决定试一试Everything，然后爱上了这个软件，占资源小，反应快，搜索功能真的强大，且是免费软件，点一个大大的赞。</p><p>我绑定的快捷键是”Ctrl+Alt+Space”，注意绑定快捷键时是选择”显示窗口快捷键”而不是新建窗口，保持开机自启后台常驻即可，占用不了多少资源。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316203323.png" alt="image-20210316203323695"></p><p>而且搜索的时候支持正则表达式，比如下面就是在”C:\Users\LeoK77\Documents\WorkSpace&quot;路径下搜索所有*.cpp(即CPP类型的文件)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316203113.png" alt="image-20210316203113620"></p><blockquote><p>Everything官网：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p></blockquote><h3 id="PowerToys：微软小型工具包"><a href="#PowerToys：微软小型工具包" class="headerlink" title="PowerToys：微软小型工具包"></a>PowerToys：微软小型工具包</h3><p>微软官方的一些小工具的集合，我开启的是如图所示的这几个工具。(众所周知微软就喜欢自己背地里搞些好用的小软件，而不是直接登录Win10应用商店)</p><p>虽然名字是”Toys”可能会对一些人劝退，但我综合使用下来还是蛮不错的；缺点的话就是PowerToys Run功能后台占用内存有一百多M，不是太需要这个功能或者电脑内存不是那么大的话还是不要开启了(我电脑内存16G)。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316194201.png" alt="image-20210316194201867"></p><blockquote><p>PowerToys GitHub：<a href="https://github.com/microsoft/PowerToys">https://github.com/microsoft/PowerToys</a></p></blockquote><h3 id="Windows-TopMost-Control：窗口置顶工具"><a href="#Windows-TopMost-Control：窗口置顶工具" class="headerlink" title="Windows TopMost Control：窗口置顶工具"></a>Windows TopMost Control：窗口置顶工具</h3><p>在任务栏常驻，设置快捷键后，现在处于活跃状态的窗口(不妨起名”窗口一”)会被置顶，其他的窗口(不妨起名”窗口二”)处于活跃状态后，”窗口一”还在最前面。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316195900.png" alt="image-20210316195859877"></p><p>如图所示当我把Typora置顶后，我在VSCode中编辑的时候，Typora并不会因为失去焦点而被VSCode遮住(仅做一个示例，并不是最常用的使用情况)。</p><blockquote><p>Windows TopMost Control：<a href="https://www.sordum.org/9182/window-topmost-control-v1-2/">https://www.sordum.org/9182/window-topmost-control-v1-2/</a></p></blockquote><h3 id="TrafficMonitor：系统资源占用显示"><a href="#TrafficMonitor：系统资源占用显示" class="headerlink" title="TrafficMonitor：系统资源占用显示"></a>TrafficMonitor：系统资源占用显示</h3><p>实时显示系统资源的占用情况，包括CPU、内存占用率以及当前的网络，对于部分人来说可能比较鸡肋，但是对于我来说很好用，因为通过让他常驻状态栏，我可以了解我的电脑处于一种什么样的资源占用状态，来判断我正在进行的工作有没有出现问题。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316202624.png" alt="image-20210316202617174"></p><blockquote><p>Traffic Monitor GitHub：<a href="https://github.com/zhongyang219/TrafficMonitor">https://github.com/zhongyang219/TrafficMonitor</a></p></blockquote><h2 id="工具：适合使用时启用"><a href="#工具：适合使用时启用" class="headerlink" title="工具：适合使用时启用"></a>工具：适合使用时启用</h2><h3 id="PotPlayer：视频播放器"><a href="#PotPlayer：视频播放器" class="headerlink" title="PotPlayer：视频播放器"></a>PotPlayer：视频播放器</h3><p>Potplayer，这应该是很多win10用户的选择，轻量级但是支持多种格式，且使用起来极其方便，对于本地视频的播放极其友好。</p><p>喜欢折腾的话甚至可以用PotPlayer看直播(但是我之前没找到好的直播源，电视直播源基本都是转播的网络源，有些卡)</p><blockquote><p>Potplayer官网：<a href="https://potplayer.daum.net/">https://potplayer.daum.net/</a></p></blockquote><h3 id="BandiZip：解压缩软件"><a href="#BandiZip：解压缩软件" class="headerlink" title="BandiZip：解压缩软件"></a>BandiZip：解压缩软件</h3><p>Bandizip，免费但是强大的压缩软件，且没有烦人的广告(指弹窗广告，打开本体的时候还是有广告的，但是使用右键集成功能时无广告)骚扰你，并支持在系统右键菜单栏中添加常用功能选项，如“添加到XXX.zip等格式”、“解压到…”，简单易用，不流氓。</p><p>压缩包的右键菜单如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153846.png" alt="image-20210127144129861"></p><p>普通文件的右键菜单如下：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153848.png" alt="image-20210127144224036"></p><blockquote><p>Bandizip官网：<a href="https://www.bandisoft.com/">https://www.bandisoft.com/</a></p></blockquote><h3 id="Tablacus-Explorer-多标签文件资源管理器"><a href="#Tablacus-Explorer-多标签文件资源管理器" class="headerlink" title="Tablacus Explorer - 多标签文件资源管理器"></a>Tablacus Explorer - 多标签文件资源管理器</h3><p>每当我需要在不同的文件夹下复制文件或者文件夹时，通常需要打开两个文件资源管理器，然后中途如果需要临时弄别的东西，切回来时要把两个文件资源管理器调用一遍才能到主桌面最前，但是Tablacus Explorer解决了这个问题，支持多标签多窗口，可以在一个窗口内展示两个文件资源管理器。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301085547.png" alt="image-20210301085547720"></p><blockquote><p>Tablacus Explorer：<a href="https://github.com/tablacus/TablacusExplorer">https://github.com/tablacus/TablacusExplorer</a></p></blockquote><h3 id="Microsoft便笺-jian"><a href="#Microsoft便笺-jian" class="headerlink" title="Microsoft便笺(jian)"></a>Microsoft便笺(jian)</h3><p>轻量级产品，以窗口的形式作为一个备忘录存在，固定在任务栏随时唤醒，提醒自己计划要做的任务有哪些。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301092646.png" alt="image-20210301092646614"></p><p>下载安装在Win10应用商店即可，搜索“便笺”，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301092944.png" alt="image-20210301092943900"></p><h3 id="Windows-Terminal：Win10终端"><a href="#Windows-Terminal：Win10终端" class="headerlink" title="Windows Terminal：Win10终端"></a>Windows Terminal：Win10终端</h3><p>是否觉着cmd不好用，powershell有些丑？试一试Windows Terminal吧，颜值高，兼容一些Linux下shell的用法，感觉不要太爽。</p><p>要在Windows Terminal下执行脚本，需要依次进行如下操作：设置-&gt;更新和安全-&gt;开发者选项(拉到最下方)-&gt;应用以下设置以执行脚本。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301093447.png" alt="image-20210301093446877"></p><p>下载安装在Win10应用商店即可，搜索“Windows Terminal”，如图所示：</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210301093601.png" alt="image-20210301093601384"></p><h3 id="DiskGenius：强大的磁盘管理工具"><a href="#DiskGenius：强大的磁盘管理工具" class="headerlink" title="DiskGenius：强大的磁盘管理工具"></a>DiskGenius：强大的磁盘管理工具</h3><p>对于我来说，DiskGenius几乎是我离不开的工具之一，我会用它做磁盘分区种类转换(MBR-&gt;GPT)、用它清空/格式化磁盘、用它检测磁盘坏道、用它进行磁盘分区……因为我之前总是装系统装着玩儿，所以磁盘管理这块用DiskGenius比较多(作为一个弟弟实在是不太会用Linux终端分盘，仅有的一次还是使用arch的时候，但我现在是Windows的忠实用户了，Linux还是在虚拟机里比较好)</p><p>中文软件使用方式就不多说了，但凡认字应该就能看懂怎么用。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316201037.png" alt="image-20210316201037103"></p><blockquote><p>DiskGenius：<a href="https://www.diskgenius.cn/">https://www.diskgenius.cn/</a></p></blockquote><h2 id="腾讯系软件"><a href="#腾讯系软件" class="headerlink" title="腾讯系软件"></a>腾讯系软件</h2><h3 id="TIM：比PC版QQ简洁"><a href="#TIM：比PC版QQ简洁" class="headerlink" title="TIM：比PC版QQ简洁"></a>TIM：比PC版QQ简洁</h3><p>TIM，之所以选择TIM而不选择QQ是因为TIM在电脑上的操作逻辑要比QQ好一些，且花里胡哨的东西也少一些，日常聊天一个窗口即可，不需要像QQ挂着一个主标签，聊天框分离开。(TIM也可以把某一个聊天框从主界面分离出来，凭自己喜好而定)</p><p>(弱弱的说一句，有时候觉着TIM就像是在Win10平台的MacOS的QQ)</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153912.png" alt="image-20210127145139111"></p><blockquote><p>TIM官网：<a href="https://office.qq.com/">https://office.qq.com/</a></p></blockquote><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>微信，懂得都懂，都在用，没办法。当然，不喜欢下载微信客户端的话也可以使用微信网页版。</p><blockquote><p>微信Win10客户端下载：<a href="https://pc.weixin.qq.com/?lang=zh_CN">https://pc.weixin.qq.com/?lang=zh_CN</a><br>微信网页版：<a href="https://wx.qq.com/">https://wx.qq.com/</a></p></blockquote><h3 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h3><p>QQ音乐，国内的音乐软件也就QQ音乐和网易云音乐两个平台最火热，但是网易云很多歌曲因为版权问题歌单变灰，不能听了，虽然QQ音乐也不见得多好，但我还是选择了使用它。</p><p>PS:我知道有些软件可以“解锁”网易云灰色歌单，或者可以直接听收费的音乐，但是用起来要么是麻烦要么不是那么舒服，我也曾经使用过一些类似的软件，但是本人不是发烧友，也不喜欢看歌曲评论，为了少折腾，QQ音乐是我现阶段最好的选择。如果喜欢听的歌以国外的歌曲为主，可以选择Apple Music。</p><blockquote><p>QQ音乐官网：<a href="https://y.qq.com/download/index.html">https://y.qq.com/download/index.html</a></p></blockquote><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><h3 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h3><p>Steam，蒸汽平台要面世了管我Steam什么事呢(滑稽)。需要注意的是steam的任何资源请认准steam官网，不要以为浏览器搜出来的steam管家之类的就是官方平台，纯粹骗钱的。</p><blockquote><p>steam官网：<a href="https://store.steampowered.com/">https://store.steampowered.com/</a></p></blockquote><h3 id="UU网游加速器：免费加速Steam社区"><a href="#UU网游加速器：免费加速Steam社区" class="headerlink" title="UU网游加速器：免费加速Steam社区"></a>UU网游加速器：免费加速Steam社区</h3><p>UU网游加速器，喜欢逛社区的可以使用一下，包括steam个人主页也都是需要加速社区才可以访问的。</p><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153902.png" alt="image-20210127154151291"></p><blockquote><p>UU加速器官网：<a href="https://uu.163.com/">https://uu.163.com/</a></p></blockquote><h3 id="Minecraft-Java-Edition：我的世界Java版"><a href="#Minecraft-Java-Edition：我的世界Java版" class="headerlink" title="Minecraft Java Edition：我的世界Java版"></a>Minecraft Java Edition：我的世界Java版</h3><ul><li>Plain Craft Launcher 2：我目前正在用的启动器(虽然我是用的预览版，没买正式版，但目前来看还是很好用的一款启动器)，颜值高、可以自动装forge、fabric、optifine，可以直接通过启动器装mod(似乎不全)，功能很强大，个人觉着挺好用的。(有能力支持正式版，没能力的像我这种穷孩子用公开预览版也没事，在作者的爱发电平台下载，正式版找”Alpha”，预览版找”Beta”)</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210316192538.png" alt="image-20210316192538576"></p><blockquote><p>作者龙腾猫跃的爱发电：<a href="https://afdian.net/@LTCat">https://afdian.net/@LTCat</a></p></blockquote><ul><li>MultiMC，一款只支持正版用户使用的MC启动器，可以多个版本共存，各个实例之间互不影响，mod支持也十分友好，mod加载器使用其提供的forge/fabric可以直接安装。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153906.png" alt="image-20210127153234044"></p><blockquote><p>MultiMC官网：<a href="https://multimc.org/">https://multimc.org/</a></p></blockquote><ul><li>HMCL，我使用的第一个启动器，支持离线登录/正版登录/第三方平台登录，此启动器一般建议一个启动器只安装一个游戏版本，因为他的各个版本之间的.minecraft文件夹是不会自行区分的，而是都堆在启动器本身所在的目录下，有多版本需求的只需要将启动器本体复制到另一个目录下即可。</li></ul><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/LeoK77%E6%9D%82%E8%B0%88/Win10%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/20210208153909.png" alt="image-20210127153540080"></p><blockquote><p>HMCL官网：<a href="https://hmcl.huangyuhui.net/">https://hmcl.huangyuhui.net/</a><br>HMCL Github：<a href="https://github.com/huanghongxun/HMCL">https://github.com/huanghongxun/HMCL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeoK77杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
