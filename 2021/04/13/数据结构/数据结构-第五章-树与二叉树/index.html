<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构-第五章-树与二叉树 | LeoK77</title><meta name="keywords" content="数据结构"><meta name="author" content="LeoK77,17560376405@163.com"><meta name="copyright" content="LeoK77"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构&#x2F;第五章-树与二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-第五章-树与二叉树">
<meta property="og:url" content="https://www.leok77.cn/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="LeoK77">
<meta property="og:description" content="数据结构&#x2F;第五章-树与二叉树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.leok77.cn/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="article:published_time" content="2021-04-13T04:39:51.000Z">
<meta property="article:modified_time" content="2021-04-13T11:14:48.000Z">
<meta property="article:author" content="LeoK77">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.leok77.cn/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.leok77.cn/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构-第五章-树与二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-13 19:14:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LeoK77</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">数据结构-第五章-树与二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-13T04:39:51.000Z" title="发表于 2021-04-13 12:39:51">2021-04-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-13T11:14:48.000Z" title="更新于 2021-04-13 19:14:48">2021-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p>
</blockquote>
<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>树是n(n&gt;=0)个结点的有限集合，n=0时称为空树。<br>任意非空树应该满足：①有且仅有一个特定的称为根的结点；②当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根节点的子树</p>
<p>n个结点的树只有n-1条边：除了根结点以外，每个结点都有前驱结点，与前驱结点通过边相连</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413132651.png" alt="image-20210413132651113"></p>
<p>度：树中一个结点的子结点的个数；如上图所示树中，A的度是3(有B、C、D三个子结点)，E的度是2(有K、L两个子结点)，F的度是0(没有子结点)<br>树中最大度数称为树的度，如上图所示树中，最大度数是3，则这棵树的度便是3</p>
<p>分支结点：度&gt;0的结点(有孩子结点)<br>叶子结点：度=0的结点(没有孩子结点)</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413133140.png" alt="image-20210413133140758"></p>
<p>树的高度(深度)是树中结点的最大层数，如上图所示树的高度(深度)是4</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413133519.png" alt="image-20210413133519530"></p>
<p>路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的；因为树中的分支是有向的(从双亲结点指向孩子结点)，所以路径一定是自上而下的。如A到K结点的路径是：ABEK<br>路径长度：路径上所经历的边的个数，如A到K结点的路径长度是3(经历了三条边)</p>
<p>森林：m(m&gt;=0)棵互不相交的树的集合</p>
<ul>
<li>树的性质：<ol>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1)</li>
<li>高度为h的m叉树至多有(m^h-1)/(m-1)个结点</li>
<li>具有n个结点的m叉树的最小高度为[logm^(n(m-1)+1)]以m为底n(m-1)+1的对数向上取整</li>
</ol>
</li>
</ul>
<h2 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h2><h3 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h3><p>二叉树是n(n&gt;=0)个结点的有限集合。①n=0时，二叉树为空；②n&gt;=0时，由根节点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树也分别是一棵二叉树</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413134433.png" alt="image-20210413134433610"></p>
<table>
<thead>
<tr>
<th></th>
<th>二叉树</th>
<th>度为2的有序树</th>
</tr>
</thead>
<tbody><tr>
<td>结点个数</td>
<td>可以为空</td>
<td>至少有3个结点</td>
</tr>
<tr>
<td>孩子结点</td>
<td>始终有左右孩子之分</td>
<td>孩子结点的次序是相对的，只有一个孩子结点的时候不区分次序</td>
</tr>
</tbody></table>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树：一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413134749.png" alt="image-20210413134749494"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树：设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p>
<ul>
<li>完全二叉树的性质：<ol>
<li>若i&lt;=(n/2)，则结点i为分支结点，否则为叶子结点</li>
<li>叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点，都依次排在最左边的位置上</li>
<li>度为1的结点若存在，则只有一个，且是编号最大的分支结点，其孩子结点一定是左结点</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135301.png" alt="image-20210413135301492"></p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>二叉排序树：一棵二叉树，若树非空则具有如下性质——对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点；二叉排序树的子树也是一棵二叉排序树</p>
<ul>
<li>二叉排序树(BST)，也称二叉查找树，或者为空树，或者为满足如下条件的非空树：<ol>
<li>若左子树非空，则左子树上所有结点关键字值均<strong>小于</strong>根结点的关键字</li>
<li>若右子树非空，则右子树上所有结点关键字值均<strong>大于</strong>根结点的关键字</li>
<li>左、右子树本身也分别是一棵二叉排序树</li>
</ol>
</li>
<li>由上述定义可知，二叉排序树中没有关键字值相等的两个结点，每个关键字值若出现则只可以出现一次</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135452.png" alt="image-20210413135452509"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树(AVL)：树上<strong>任意结点</strong>的左子树和右子树的深度之差不超过1</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413135658.png" alt="image-20210413135658286"></p>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>1、非空二叉树上的叶子结点数等于**度为2的结点数(n2)**加1，即n0=n2+1</p>
<p>非空二叉树上的结点总数=n0+n1+n2=n1+2n2+1</p>
<p>2、非空二叉树上第k层上至多有2^(k-1)个结点(k&gt;=1)</p>
<p>3、高度为h的二叉树至多有2^h-1个结点(h&gt;=1)</p>
<p>4、对完全二叉树按从上到下、从左到右的顺序依次编号为1、2、3、……、n，则有如下关系：</p>
<ul>
<li>当i&gt;1时，结点i的双亲结点标号为[i/2](取下界)，即i为偶数时，双亲结点的编号为i/2，它是双亲结点的左孩子；i是奇数时，其双亲结点的编号是(i-1)/2，他是双亲结点的右孩子</li>
<li>当2i&lt;=n时，结点i的左孩子编号为2i，否则无左孩子</li>
<li>当2i+1&lt;=n时，结点i的右孩子编号为2i+1，否则无右孩子</li>
</ul>
<p>5、具有n个(n&gt;=0)结点的完全二叉树的高度为[log2^n]+1或[log2^(n+1)]</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>二叉树的顺序存储：用一组连续的存储单元依次自上而下，自左向右存储<strong>完全二叉树</strong>上的结点元素</p>
<p>在完全二叉树中依次编号，对于结点i：若存在左孩子，则编号为2i；若存在右孩子，则编号为2i+1</p>
<p>二叉树的顺序存储中，在二叉树不是完全二叉树的情况下，需要补充空结点使得二叉树成为一棵完全二叉树，这也就导致了在最坏的情况下(每个结点有孩子结点的时候只会有右孩子结点)会极其浪费存储空间，因此顺序存储的方式比较适合完全二叉树</p>
<h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><p>二叉树的链式存储：用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储；那么二叉树的结点结构就包含数据域data，和两个指针lchild和rchild分别指向左孩子和右孩子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413141537.png" alt="image-20210413141537240"></p>
<p>含有n个结点的二叉链表中，有n+1个空链域</p>
<h2 id="二叉树的遍历及线索二叉树"><a href="#二叉树的遍历及线索二叉树" class="headerlink" title="二叉树的遍历及线索二叉树"></a>二叉树的遍历及线索二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul>
<li>若二叉树非空：<ol>
<li>访问根结点</li>
<li>先序访问左子树</li>
<li>先序访问右子树</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142115.png" alt="image-20210413142115148"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li>若二叉树非空：<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142243.png" alt="image-20210413142243031"></p>
<ul>
<li>中序遍历的非递归算法，借助栈：<ol>
<li>初始时依次扫描根结点的所有左侧结点并将它们一一进栈</li>
<li>出栈一个结点，访问它</li>
<li>扫描该结点的右孩子结点并将其进栈</li>
<li>依次扫描右孩子结点的所有左侧结点并一一进栈</li>
<li>反复该过程直到栈空为止</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul>
<li>若二叉树非空：<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413142426.png" alt="image-20210413142426760"></p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413145333.png" alt="image-20210413145333840"></p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul>
<li>层次遍历，即按照编号的顺序遍历，借助队列：<ol>
<li>初始时将根入队并访问根结点</li>
<li>若有左子树，则将左子树的根入队</li>
<li>若有右子树，则将右子树的根入队</li>
<li>然后出队，访问该结点，并执行2.3.4步骤</li>
<li>反复该过程直到队列为空</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4><p>先(后)序遍历序列和中序遍历序列可以确定一棵二叉树，但是先序遍历序列和后序遍历序列不能确定一棵二叉树</p>
<ul>
<li>由中序遍历和先序遍历序列构造二叉树：<ol>
<li>在先序序列中，第一个结点是根结点</li>
<li>根结点将中序遍历序列划分为两部分</li>
<li>然后在先序序列中确定两部分的结点，并且两部分的第一个结点分别为左子树的根和右子树的根</li>
<li>在子树中递归重复该过程，便能唯一确定一棵二叉树</li>
</ol>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>线索化：若无左子树，则将左指针指向其前驱结点；若无右子树，则将右指针指向其后继结点</p>
<p>PS：前驱结点和后继结点由遍历方式的不同而不同，比如下图便是同一棵树的不同遍历方式的线索二叉树；前驱结点就是遍历顺序中的前一个结点，后继结点就是遍历顺序中的下一个结点；最后一个结点没有后继结点，如先序遍历序列中的6，因为没有后继结点，所以它的是右指针依旧是空指针</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413145912.png" alt="image-20210413145912124"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相较于二叉树的结点结构，线索二叉树的结点结构增加了两个标志位</span></span><br><span class="line"><span class="comment">// 若标志域取值为0，则表示指针域指向孩子；若标志域取值为1，则表示指针域指向前驱或后继</span></span><br><span class="line"><span class="comment">// 比如，ltag==0时，lchild指向左孩子；ltag==1时，lchild指向前驱结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>

<p>上述线索二叉树结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表</p>
<p>在中序线索二叉树中，中序遍历序列的第一个结点是中序线索二叉树中的最左侧的结点，最后一个结点是中序线索二叉树中的最右侧的结点</p>
<ul>
<li>中序线索二叉树的前驱结点：<ul>
<li>若左指针为线索，则其指向结点为前驱结点</li>
<li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</li>
</ul>
</li>
<li>中序线索二叉树的后继结点：<ul>
<li>若右指针为线索，则其指向结点为后继结点</li>
<li>若右指针为右孩子，则其右子树的最左侧结点为后继结点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序线索二叉树线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p, ThreadTree *pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InTread(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入头结点的中序线索二叉树：头结点的左指针指向根结点，遍历序列第一个结点的左指针指向头结点，头结点的右指针指向遍历序列的最后一个结点，遍历序列最后一个结点的右指针指向头结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序线索二叉树的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=FirstNode(T);p!=<span class="literal">nullptr</span>;p=NextNode(p))&#123;</span><br><span class="line">        visti(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1、双亲表示法：采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置；根结点的下标为0，其伪指针域为-1.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413153644.png" alt="image-20210413153644176"></p>
<p>2、孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;           <span class="comment">// 孩子结点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子结点的指针</span></span><br><span class="line">&#125;CNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;       <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">child</span>;</span> <span class="comment">// 第一个孩子结点的指针</span></span><br><span class="line">&#125;PNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413155106.png" alt="image-20210413154315418"></p>
<p>3、孩子兄弟表示法：以二叉链表作为树的存储结构，又称二叉树表示法(左孩子右兄弟)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, CSTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413155831.png" alt="image-20210413155831659"></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>双亲表示法</td>
<td>寻找结点的双亲结点效率高</td>
<td>寻找结点的孩子结点效率低</td>
</tr>
<tr>
<td>孩子表示法</td>
<td>寻找结点的孩子结点效率高</td>
<td>寻找结点的双亲结点效率低</td>
</tr>
<tr>
<td>孩子兄弟表示法</td>
<td>寻找结点的孩子结点效率高，方便实现树转换为二叉树</td>
<td>寻找结点的双亲结点效率低</td>
</tr>
</tbody></table>
<h3 id="树、森林与二叉树"><a href="#树、森林与二叉树" class="headerlink" title="树、森林与二叉树"></a>树、森林与二叉树</h3><h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><p>树转换为二叉树：每个结点左指针指向它的第一个孩子结点，有指针指向它在树中相邻的兄弟结点</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413160400.png" alt="树-&gt;二叉树"></p>
<p>二叉树转换为树：即上述转换过程的逆过程</p>
<p>森林与二叉树的转换：将每一棵树都转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树；即每棵树转化为二叉树，后一棵树的根节点视为前一棵树的根节点的兄弟结点，然后根据“右兄弟”的原则进行连接，转化为常见形式</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413161214.png" alt="image-20210413161214653"></p>
<p>二叉树转换为森林即上述的逆过程，从根结点一路拆右孩子结点的连接使其转化为n棵二叉树，再分别将这些二叉树转化为树</p>
<h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><p>树的遍历：按照某种方式访问树中的每个结点，且仅访问一次，遍历方式有三种——先根遍历、后根遍历、层次遍历</p>
<ol>
<li>先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树</li>
<li>后根遍历：若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点</li>
<li>层次遍历：按照编号的顺序从左到右、从上到下的顺序遍历</li>
</ol>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413162342.png" alt="树的先根遍历及二叉树的先序遍历"></p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413162417.png" alt="树的后根遍历及二叉树的中序遍历"></p>
<p>森林的遍历，有两种遍历方法——先序遍历、中序遍历</p>
<ul>
<li>先序遍历：若森林非空，则<ol>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的子树森林</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413163100.png" alt="image-20210413163100817"></p>
<ul>
<li>中序遍历：若森林非空，则<ol>
<li>中序遍历第一棵树的根节点的子树森林</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413163305.png" alt="image-20210413163305810"></p>
<table>
<thead>
<tr>
<th align="center">树</th>
<th align="center">森林</th>
<th align="center">二叉树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先根遍历</td>
<td align="center">先序遍历</td>
<td align="center">先序遍历</td>
</tr>
<tr>
<td align="center">后根遍历</td>
<td align="center">中序遍历</td>
<td align="center">中序遍历</td>
</tr>
</tbody></table>
<h3 id="树的应用——并查集"><a href="#树的应用——并查集" class="headerlink" title="树的应用——并查集"></a>树的应用——并查集</h3><p>并查集：一种简单的集合表示；通常用树的<strong>双亲表示法</strong>作为并查集的存储结构，用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Initial(S);<span class="comment">//将集合S中的每个元素都初始化为只有一个单元素的子集合</span></span><br><span class="line">Union(S, Root1, Root2);<span class="comment">//把集合S中的子集合(互不相交)Root2并入子集合Root1</span></span><br><span class="line">Find(S, x);<span class="comment">//查找集合S中单元素x所在子集合，并返回该子集合的名字</span></span><br></pre></td></tr></table></figure>

<p>并查集实例(分为三个子集，我也不知道这是怎么分的)，如0是根结点，这个子集有四个结点，所以它的parent域是-4；6是0的子节点，所以5的parent域是0。</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413165336.png" alt="并查集实例(分为三个子集)"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];<span class="comment">//默认下标就是其数据域的值，假如数据域有单独的值，需要再开一个数组或者使用结构体的形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        x=S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h3><p>二叉排序树的特点：BST的中序遍历序列是一个递增有序序列</p>
<p>在BST中执行<strong>查找</strong>操作：二叉树非空时，查找根结点，若相等则查找成功；若不等，则当小于根节点时，查找左子树；当大于根结点时，查找右子树；当查找到叶子结点仍没有查找到相应的值时，则查找失败。查找效率取决于树的高度，当BST接近平衡二叉树时，时间复杂度是O(log2^n)(n是结点个数)；最坏的情况下是O(n)，所有结点有子结点的时候有且仅有右节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key, BSTNode *&amp;p)</span></span>&#123;</span><br><span class="line">    P=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">nullptr</span> &amp;&amp; key != T-&gt;data)&#123;</span><br><span class="line">        p=T;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在BST执行<strong>插入</strong>操作：二叉树为空时，直接插入结点；二叉树非空时，当值小于根节点时，插入左子树；当值大于根节点时，插入右子树；当值等于根节点时不可以进行插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        T = (BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">        T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造二叉排序树</strong>：读入一个元素并建立结点，若二叉树为空将其作为根结点；若二叉树非空，当值小于根节点时，插入左子树；当值大于根节点时，插入右子树；当值等于根节点时不进行插入。实际上就是不断调用<strong>插入</strong>操作来构造这棵二叉排序树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, ElemType keys[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    T=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">        BST_Insert(T, keys[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉排序树的<strong>删除结点</strong>操作：①若被删除结点z是叶子结点，则直接删除；②若被删除结点z只有一棵子树，则让结点z的子树成为结点z的父结点的子树，代替z结点；③若被删除结点z有两棵子树，则让结点z的中序序列直接后继代替结点z，并删去直接后继结点</p>
<h3 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>高度为h的最小平衡二叉树的结点数Nh=Nh-1+Nh-2+1，N0=0，N1=1</p>
<p>平衡二叉树的判断：利用递归的后序遍历过程——①判断左子树是一棵平衡二叉树；②判断右子树是一棵平衡二叉树；③判断以该结点为根的二叉树为平衡二叉树，若左子树和右子树均为平衡二叉树且左子树与右子树高度差的绝对值小于等于1则以该结点为根的二叉树是平衡二叉树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> br=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild==<span class="literal">nullptr</span> &amp;&amp; bt-&gt;rchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        h=<span class="number">1</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Judge_AVL(bt-&gt;lchild, bl, hl);</span><br><span class="line">        Judge_AVL(bt-&gt;rchild, br, hr);</span><br><span class="line">        <span class="keyword">if</span>(hl&gt;hr)&#123;</span><br><span class="line">            h=hl+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h=hr+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(hl-hr)&lt;=<span class="number">1</span> &amp;&amp; bl==<span class="number">1</span> &amp;&amp; br==<span class="number">1</span>)&#123;</span><br><span class="line">            balance = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平衡二叉树的<strong>插入</strong>操作：先插入，后调整，每次调整最小不平衡子树，调整分为四种类型——①LL平衡旋转(右单旋转)；②</p>
<p>1、LL平衡旋转(右单旋转)：原因——在结点A的左孩子的左子树上插入了新结点<br>调整方法：右旋操作，将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413182610.png" alt="image-20210413182610737"></p>
<p>2、RR平衡旋转(左单旋转)：原因——在结点A的右孩子的右子树上插入了新结点<br>调整方法：左旋操作，将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413182926.png" alt="image-20210413182926484"></p>
<p>3、LR平衡旋转(先左后右双旋转)：原因——在结点A的左孩子的右子树上插入了新结点<br>调整方法：先左旋后右旋操作，将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413183312.png" alt="image-20210413183312540"></p>
<p>4、RL平衡旋转(先右后左双旋转)：原因——在结点A的右孩子的左子树上插入了新结点<br>调整方法：先右旋后左旋操作，将A的右孩子B的左孩子结点C代替B，然后再将C结点向上代替A的位置</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413183606.png" alt="image-20210413183539191"></p>
<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><p>带权路径长度：①路径长度——路径上所经历边的个数；②结点的权——结点被赋予的数值</p>
<p>树的带权路径长度：WPL，树中所有叶子结点的带权路径长度(结点的权*路径长度)之和</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413184654.png" alt="image-20210413184626562"></p>
<p>哈夫曼树，也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树</p>
<ul>
<li>哈夫曼树的构造算法：<ol>
<li>将n个结点作为n棵仅含有一个根结点的二叉树，构成森林F；</li>
<li>生成一个新结点，并从F中找出根结点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根结点的权值之和；</li>
<li>从F中删除这两棵树，并将新生成的树加入到F中；</li>
<li>重复2.3.步骤，直到F中只有一棵树为止</li>
</ol>
</li>
<li>哈夫曼树的性质：<ol>
<li>每个初始结点都会成为叶子结点，拥有左右子树的结点都为新生成的结点</li>
<li>权值越大离根结点越近，反之权值越小离根结点越远</li>
<li>哈夫曼树中没有结点的度为1</li>
<li>n个叶子结点的哈夫曼树的叶子结点总数为2n-1，其中度为2的结点数为n-1</li>
</ol>
</li>
</ul>
<p>编码：对于一个字符串序列，用二进制来表示字符</p>
<p>固定长度编码：每个字符的二进制串长度都相同<br>可变长度编码：每个字符的二进制串长度不完全相同<br>前缀编码：没有一个编码是另一个编码的前缀</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413185739.png" alt="image-20210413185739855"></p>
<p>哈夫曼编码：将字符的出现次数视为权重，构造哈夫曼树，然后依次读出编码，便可以得到最优的前缀编码(占存储空间最小，出现次数越多，二进制串长度越短)之一(因为哈夫曼树不唯一)</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/20210413190020.png" alt="image-20210413190020821"></p>
<p>哈夫曼树并不唯一(因为左右子树并不做严格规范)，所以每个字符对应的哈夫曼编码也不唯一，但是带权路径长度相同且最优</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:17560376405@163.com">LeoK77</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.leok77.cn/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">https://www.leok77.cn/2021/04/13/数据结构/数据结构-第五章-树与二叉树/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.leok77.cn" target="_blank">LeoK77</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-MSSQLSERVER/"><img class="prev-cover" src="/img/LeetCode_Logo.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库系统-LeetCode刷题记录-MSSQLSERVER</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/"><img class="next-cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构-第四章-串</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/22/数据结构/数据结构-第一章-绪论/" title="数据结构-第一章-绪论"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-22</div><div class="title">数据结构-第一章-绪论</div></div></a></div><div><a href="/2021/03/27/数据结构/数据结构-第七章-查找/" title="数据结构-第七章-查找"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">数据结构-第七章-查找</div></div></a></div><div><a href="/2021/04/11/数据结构/数据结构-第四章-串/" title="数据结构-第四章-串"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">数据结构-第四章-串</div></div></a></div><div><a href="/2021/03/24/数据结构/数据结构-第二章-线性表/" title="数据结构-第二章-线性表"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-24</div><div class="title">数据结构-第二章-线性表</div></div></a></div><div><a href="/2021/04/10/数据结构/数据结构-第三章-栈和队列/" title="数据结构-第三章-栈和队列"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">数据结构-第三章-栈和队列</div></div></a></div><div><a href="/2021/03/27/数据结构/数据结构-第八章-排序/" title="数据结构-第八章-排序"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">数据结构-第八章-排序</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LeoK77</div><div class="author-info__description">考えたくはないよ  馬鹿になっていたいもん</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leok77"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leok77" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:17560376405@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">二叉树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.4.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">二叉树的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">二叉树的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">二叉树的链式存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉树的遍历及线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.4.</span> <span class="toc-text">层次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.5.</span> <span class="toc-text">由遍历序列构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">4.</span> <span class="toc-text">树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">树、森林与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">树、森林与二叉树的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">树和森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.3.</span> <span class="toc-text">树的应用——并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-BST"><span class="toc-number">5.1.</span> <span class="toc-text">二叉排序树(BST)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">5.2.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">5.3.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By LeoK77</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '2f220532af9d5da3f585',
      clientSecret: '4dd9b398df123d0c1ddd42c6ed6a6122236053fb',
      repo: 'leok77.github.io',
      owner: 'leok77',
      admin: ['leok77'],
      id: 'c19987b1d4e68f45741f88a5ff7a68ef',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>