<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构-第八章-排序 | LeoK77</title><meta name="keywords" content="数据结构"><meta name="author" content="LeoK77,17560376405@163.com"><meta name="copyright" content="LeoK77"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构&#x2F;第八章-排序">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-第八章-排序">
<meta property="og:url" content="https://www.leok77.cn/2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="LeoK77">
<meta property="og:description" content="数据结构&#x2F;第八章-排序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.leok77.cn/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="article:published_time" content="2021-03-27T02:43:11.000Z">
<meta property="article:modified_time" content="2021-03-30T09:34:13.000Z">
<meta property="article:author" content="LeoK77">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.leok77.cn/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.leok77.cn/2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构-第八章-排序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-30 17:34:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LeoK77</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">数据结构-第八章-排序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-27T02:43:11.000Z" title="发表于 2021-03-27 10:43:11">2021-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-30T09:34:13.000Z" title="更新于 2021-03-30 17:34:13">2021-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>内容来自王道考研的《数据结构考研复习指导》实体书，以及王道的B站官号所上传的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798">数据结构网课</a>。</p>
</blockquote>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327104827.png" alt="image-20210327104827739"></p>
<h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><p>排序：重新排列表中的元素，使表中的元素满足按关键字递增或递减</p>
<p>排序算法的稳定性：若待排序表中有两个元素Ri和Rj，其对应的关键字ki=kj，且在排序前Ri在Rj前面，若使用某排序算法后，Ri仍然在Rj前面，则称这个排序算法是稳定的，否则称排序算法不稳定。</p>
<blockquote>
<p>排序算法的稳定性是算法的一个性质，并不能衡量一个算法的优劣。</p>
<p>比如STL的算法(algorithm)中的sort()排序函数基本是采用”快速排序”的方法实现的，”快速排序”是一种不稳定的算法，却不能说”快速排序”算法不好</p>
</blockquote>
<ul>
<li>内部排序：在排序期间元素全部存放在内存中的排序；性能由<strong>时空复杂度</strong>决定<ol>
<li>插入排序：<ol>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>希尔排序</li>
</ol>
</li>
<li>交换排序<ol>
<li>冒泡排序</li>
<li>快速排序</li>
</ol>
</li>
<li>选择排序<ol>
<li>简单选择排序</li>
<li>堆排序</li>
</ol>
</li>
<li>归并排序</li>
<li>基数排序——除基数排序外，其余8种排序方法都基于”移动和比较”来进行排序</li>
</ol>
</li>
<li>外部排序：在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间进行移动——内存大小有限，当要排序的元素表的大小比内存大时，需要不断将一部分元素放入内存中进行排序，直到排序完成</li>
</ul>
<blockquote>
<p>引入A[0]哨兵概念，即对于一个含有n个数据元素的线性表(一般情况下是一个数组)A，它的实际大小应该是n+1，其中每个数据元素的下标从1开始，即与位序相等的，实际存储是从A[1]到A[n-1]，A[0]仅作为一个辅助元素。</p>
<p>当然，对于大部分实际应用场景来说，线性表本身是不存在A[0]哨兵概念的，即一般情况下数据元素的存储由下标0开始，这里引入A[0]作为哨兵是为了下述排序算法更容易实现，当然也可以定义一个局部变量作为暂存元素。</p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：每次将一个待排序的序列插入到一个前面已经排好序的子序列当中</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul>
<li>初始L[1]是一个已经排好序的子序列</li>
<li>对于元素L(i)(L(2)~L(n))插入到前面已经排好序的子序列当中：<ol>
<li>查找出L(i)在L[1……i-1]中的插入位置k</li>
<li>将L[k……i-1]中的所有元素全部后移一个位置</li>
<li>将L(i)复制到L(k)</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212342.png" alt="image-20210329212342098"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的直接插入排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">// 从A[2]开始——A[0]是哨兵，不存放元素；A[1]看做已经排好序的序列</span></span><br><span class="line">    <span class="comment">// n指的是待排序元素个数而不是数组大小，由于有A[0]作为哨兵，所以A大小为n+1，有效元素A[1]到A[n]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// A[0]作为哨兵，不存放元素</span></span><br><span class="line">        <span class="comment">// 此处是暂存待插入的元素</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        <span class="comment">// j=i-1——从后向前找一个合适的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; j--) &#123;</span><br><span class="line">            <span class="comment">// 找到合适的位置前，所有元素后移</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            <span class="comment">// 循环终止条件——A[0]&lt;A[j]</span></span><br><span class="line">            <span class="comment">// 1、找到了一个A[0]&gt;=A[j]的位置，那么A[0]应该插入到A[j+1]处</span></span><br><span class="line">            <span class="comment">// 2、所有元素都比A[0]大，那么此时j=0，A[0]需插入到A[1]即A[j+1]</span></span><br><span class="line">            <span class="comment">// 总之就是A[j+1]的值应该替换为A[0]的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有A[0]哨兵的直接插入排序</span></span><br><span class="line"><span class="comment">// A[]中所有元素都是待排序元素的直接插入排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ElemType elemTmp;   <span class="comment">// 起哨兵作用，暂存待插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        elemTmp = A[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; elemTmp &lt; A[j] &amp;&amp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 从后向前找插入位置，且下标不等小于0</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同A[0]作为哨兵的情况，无论如何都是替换A[j+1]的值</span></span><br><span class="line">        A[j + <span class="number">1</span>] = elemTmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<ul>
<li>最好时间复杂度：O(n)</li>
<li>最坏时间复杂度：O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
</li>
</ul>
<p>直接插入排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>折半插入排序——相较于直接插入排序，查找插入位置时采用<strong>折半查找</strong>的方式，查找效率优于直接插入排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];    <span class="comment">// 哨兵——A[0]，暂存待插入元素</span></span><br><span class="line">        <span class="comment">// 查找区间——[1, i-1]</span></span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 折半查找</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] &lt; A[mid]) &#123;</span><br><span class="line">                <span class="comment">// A[0]应插入到A[mid]之前</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// A[0]应插入到A[mid]之后</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当low&gt;high时，说明已经找到了位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 待插入位置既可以用A[high+1]表示，也可以用A[low]表示</span></span><br><span class="line">        <span class="comment">// 待插入位置A[high+1]之后的元素后移</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt; high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终插入位置是A[high+1]</span></span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折半插入排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；仅适用于顺序存储(数组)。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(缩小增量排序)：先将排序表分割成d个形如[i, i+d, i+2d, ……, i+kd]的“特殊”子表，分别进行直接插入排序，进行多趟(每趟步长d缩减)，当整个表中的元素已成“基本有序时”(步长d缩减到1)，再对全体记录进行一次直接插入排序。</p>
<p>步长d选取方法——Shell’s idea</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327142055.png" alt="image-20210327142055361"></p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212428.png" alt="image-20210329212428133"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的根据定义制定的希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dk; i++) &#123;</span><br><span class="line">            <span class="comment">// dk组——每组的起点[1, 2, ……, dk]</span></span><br><span class="line">            <span class="comment">// 对每组分别进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + dk; j &lt;= n; j += dk) &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[j];    <span class="comment">// A[0]是哨兵</span></span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="comment">// 判定条件有k&gt;0是因为k-=dk可能出现k为负数的情况</span></span><br><span class="line">                <span class="keyword">for</span> (k = j - dk; k &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[k]; k -= dk) &#123;</span><br><span class="line">                    A[k + dk] = A[k];</span><br><span class="line">                &#125;</span><br><span class="line">                A[k + dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具备A[0]哨兵的“同时对所有组进行直接插入排序”的希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 同时对所有组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">// 判定条件有j&gt;0是因为j-=dk可能出现j为负数的情况</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j -= dk) &#123;</span><br><span class="line">                    A[j + dk] = A[j];</span><br><span class="line">                &#125;</span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序是一个时间复杂度为O(n^2)(大部分情况下是O(n^1.3)，效率较高)、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；仅适用于顺序存储(数组)。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序：假设待排序表长为n，从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换他们直到序列比较结束</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329215202.png" alt="image-20210329215202478"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有A[0]哨兵的冒泡排序，共n个元素，有A[0]到A[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前n-1个元素都到其最终位置之后，最后第n个元素也就在其最终位置了，所以i&lt;n-1</span></span><br><span class="line">        <span class="comment">// 一趟下来之后，有一个元素到达最终位置</span></span><br><span class="line">        <span class="comment">// 如此处以增序为例(从小到大排序)，每次剩下序列里最小的就会到最前面</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 如果一趟下来一个都不交换，说明已经排序好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="comment">// 从后往前比较，最后j=i+1，比较A[i]和A[i+1]</span></span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">                <span class="comment">// 相邻两个为逆序，交换位置，并将flag置true，说明没排好序</span></span><br><span class="line">                swap(A[j - <span class="number">1</span>], A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;    <span class="comment">// 一趟下来没发生交换(无逆序)，说明已经排好序了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<ul>
<li>最好时间复杂度：O(n)</li>
<li>最坏时间复杂度：O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
</li>
</ul>
<p>冒泡排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序——在待排序表L[1……n]中任取一个元素pivot(一般为第一个元素)作为<strong>基准</strong>，通过一趟排序将待排序表划分为具有如下特点的两部分：使pivot逐渐到中间位置，在pivot之前的元素都小于等于pivot，在pivot之后的元素都大于等于pivot——即一次划分会将一个元素pivot放置到它最终的位置上</p>
<ul>
<li>基本思路：初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断地移动两个标记并交换元素：<ol>
<li>high向前移动找到第一个比pivot小的元素</li>
<li>low向后移动找到第一个比pivot大的元素</li>
<li>交换当前两个元素的位置</li>
<li>继续移动标记，执行1.2.3.过程，直到low大于等于high为止</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于区间 [low, high] 的一次划分</span></span><br><span class="line"><span class="comment">// 返回值是这次划分之后基准元素落在的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    ElemType pivot = A[low];    <span class="comment">// 基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) &#123;</span><br><span class="line">            <span class="comment">// 从后向前找，找到一个比pivot小的元素</span></span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A[low]作为辅助变量，暂存找到的比pivot小的元素</span></span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &gt;= A[low]) &#123;</span><br><span class="line">            <span class="comment">// 从前向后找，找到一个比pivot大的元素</span></span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基准元素pivot最后落在的位置，此时low==high，A[low]与A[high]等价</span></span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">//返回基准元素最后落在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于上述一次划分算法的举例：5, 7, 5, 8, 6, 9, 1, 4, 3</span><br><span class="line">初始low&#x3D;0, high&#x3D;8, pivot&#x3D;A[low]&#x3D;A[0]&#x3D;5</span><br><span class="line"></span><br><span class="line">1. high&#x3D;8, A[low]&#x3D;A[0]&#x3D;A[high]&#x3D;A[8]&#x3D;3</span><br><span class="line">low&#x3D;1, A[high]&#x3D;A[8]&#x3D;A[low]&#x3D;A[1]&#x3D;7</span><br><span class="line">此时：3, 7, 5, 8, 6, 9, 1, 4, 7——low&#x3D;1, high&#x3D;8, pivot&#x3D;5</span><br><span class="line">2. high&#x3D;7, A[low]&#x3D;A[1]&#x3D;A[high]&#x3D;A[7]&#x3D;4</span><br><span class="line">low&#x3D;3, A[high]&#x3D;A[7]&#x3D;A[low]&#x3D;A[3]&#x3D;8</span><br><span class="line">此时：3, 4, 5, 8, 6, 9, 1, 8, 7——low&#x3D;3, high&#x3D;7, pivot&#x3D;5</span><br><span class="line">3. high&#x3D;6, A[low]&#x3D;A[3]&#x3D;A[high]&#x3D;A[6]&#x3D;1</span><br><span class="line">low&#x3D;4, A[high]&#x3D;A[6]&#x3D;A[low]&#x3D;A[4]&#x3D;6</span><br><span class="line">此时：3, 4, 5, 1, 6, 9, 6, 8, 7——low&#x3D;4, high&#x3D;6, pivot&#x3D;5</span><br><span class="line">4. high&#x3D;4, A[low]&#x3D;A[4]&#x3D;A[high]&#x3D;A[4]&#x3D;6</span><br><span class="line">low&#x3D;4, A[high]&#x3D;A[4]&#x3D;A[low]&#x3D;A[4]&#x3D;6</span><br><span class="line">此时：3, 4, 5, 1, 6, 9, 6, 8, 7——low&#x3D;4, high&#x3D;4, pivot&#x3D;5</span><br><span class="line"></span><br><span class="line">low&#x3D;high&#x3D;4，跳出了while循环，更换A[low]的值</span><br><span class="line">low&#x3D;4, A[low]&#x3D;A[4]&#x3D;pivot&#x3D;5</span><br><span class="line">此时：3, 4, 5, 1, 5, 9, 6, 8, 7</span><br><span class="line">返回的基准元素位置是low&#x3D;4：</span><br><span class="line">    即在A[4]&#x3D;5的左部，所有元素都&lt;&#x3D;pivot&#x3D;5</span><br><span class="line">    在A[4]&#x3D;5的右部，所有元素都&gt;&#x3D;pivot&#x3D;5</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用上述的一趟排序函数，再递归调用自身逐层排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获得基准元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotPos = Partition(A, low, high);</span><br><span class="line">        <span class="comment">// 对左半部分进行排序—— [low, pivotPos) 即 [low, pivotPos-1]</span></span><br><span class="line">        QuickSort(A, low, pivotPos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对右半部分进行排序—— (pivotPos, high] 即 (pivotPos+1, high]</span></span><br><span class="line">        QuickSort(A, pivotPos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlog2(n))(n×以2为底n的对数)<ul>
<li>最坏时间复杂度：O(n^2)——初始基本有序或逆序</li>
</ul>
</li>
<li>空间复杂度：O(log2(n))(以2为底n的对数)<ul>
<li>最坏空间复杂度：O(n)</li>
</ul>
</li>
</ul>
<p>快速排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(log2(n))的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)，有时要求链式存储也实现快速排序算法(更改指针初始位置，及一些特殊条件的情况下)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：每次将一个待排序序列中关键字最小的元素放到前面已经排好序的子序列尾部</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>简单选择排序：每一趟在后面n-i+1(i=1,2,……,n-1)个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到n-1趟做完，待排序元素只剩下1个；一趟排序结束会将一个元素放置在其最终位置上</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212534.png" alt="image-20210329212534712"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) &#123;</span><br><span class="line">                <span class="comment">// 找到了比A[min]更小的数，更新min(下标)</span></span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="comment">// 找到了比A[i]更小的数，需要交换位置</span></span><br><span class="line">            swap(A[i], A[min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单选择排序是一个时间复杂度为O(n^2)、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>堆：n个关键字序列L[1……n]称为堆，当且仅当该序列满足：<ul>
<li>若L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)，则称该堆为<strong>小根堆</strong></li>
<li>若L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)，则称该堆为<strong>大根堆</strong></li>
<li>1&lt;=i&lt;=(n/2)</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327162848.png" alt="image-20210327162848352"></p>
<p>在排序过程中可以将L[1……n]视为一棵完全二叉树的顺序存储结构，小根堆实例如下(大根堆同理)</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327163012.png" alt="image-20210327163012487"></p>
<ul>
<li>堆的初始化(以大根堆举例)：对所有具有双亲节点含义编号从大到小((n/2)……1)做出如下调整：<ol>
<li>若孩子节点皆小于双亲结点，则该结点的调整结束</li>
<li>若存在孩子结点大于双亲结点，则将最大的孩子结点与双亲结点交换，并对该孩子结点进行1.2.过程，直到出现1.或直到叶子结点为止</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327170201.png" alt="堆的初始化实例(大根堆)"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下找子节点调整的过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];    <span class="comment">// 编号由1开始，A[0]作为一个辅助变量，暂存结点值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 2*k是其左孩子结点，每次*2都是到达左孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 找出孩子结点里最大的那一个</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) &#123;</span><br><span class="line">            <span class="comment">// 如果双亲结点&gt;=孩子结点那么就不需要替换了，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 孩子结点&gt;双亲结点，需要替换</span></span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没有发生替换，则A[k]恢复原值</span></span><br><span class="line">    <span class="comment">// 若发生了替换，则被替换过后的结点赋值为原A[k]的值</span></span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定需要判断调整的结点，然后调用调整过程——初始化大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// [n/2, 1] 编号的结点调整</span></span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化堆的时间复杂度——O(n)</li>
</ul>
<p>堆排序：不断输出堆顶元素，并向下调整</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212727.png" alt="image-20210329212727352"></p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210329212837.png" alt="image-20210329212836942"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不断输出堆顶元素，并向下调整——将堆顶元素放置到末尾，然后将前面的序列调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);   <span class="comment">// 初始化大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 从i=len开始，每次将堆顶元素放到现在这个大根堆的末尾，然后对剩下的无序序列(仅1号元素不符合大根堆)进行调整，使其成为一个大根堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前大根堆的最后的元素与堆顶元素进行交换，这样堆顶元素(最大的元素)就到了最后</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 交换后堆顶元素变为了原最后的值，对现在这个堆进行一次调整，使其称为一个大根堆</span></span><br><span class="line">        <span class="comment">// 因为原堆顶元素被放置到了末尾，所以调整时不可以取末尾，使得i-1即可</span></span><br><span class="line">        AdjustDown(A, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(1)的<strong>不稳定</strong>的排序算法；适用于顺序存储(数组)。</p>
<p>堆的插入：将新结点放置在末端然后进行向上调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大根堆的向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];    <span class="comment">// 暂存A[k]结点值</span></span><br><span class="line">    <span class="keyword">int</span> i = k / <span class="number">2</span>;  <span class="comment">// 找到其双亲结点的下标</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] &lt; A[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 循环结束条件：1、已经是1号结点，不能再向上了；2、双亲结点&gt;=子节点</span></span><br><span class="line">        <span class="comment">// 循环进行时也就代表需要调整</span></span><br><span class="line">        A[k] = A[i];    <span class="comment">// A[k]结点替换为其双亲结点A[i]的值</span></span><br><span class="line">        k = i;          <span class="comment">// 下一次调整：从双亲结点A[i]向上调整</span></span><br><span class="line">        i = k / <span class="number">2</span>;      <span class="comment">// 找到新的双亲结点的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];    <span class="comment">// 赋值为待调整的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的基本思想：首先将a[0……n-1]看成是长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到(n/(k^2))个长度为k^2的有序子表，如此反复进行下去，直到最后得到一个长度为n的有序表。</p>
<p>可以理解为：将相邻的n个有序子表合并成一个大的有序子表，然后再合并相邻的n个大的有序子表直到将整个序列合并成一个完整的有序序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二路归并排序实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个相邻的有序线性表</span></span><br><span class="line">ElemType *B = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * (length + <span class="number">1</span>)); <span class="comment">// length是待归并的数组大小</span></span><br><span class="line"><span class="comment">// 对于归并排序合并的两个线性表其实是在数组A[]中的两片相邻空间</span></span><br><span class="line"><span class="comment">// 线性表 A1——[low, mid] A2——(mid, high]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; k++) &#123;</span><br><span class="line">        <span class="comment">// 先将待处理的两个线性表的所有元素都存储到辅助数组B[]中</span></span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="comment">// i 作为线性表 A1——[low, mid] 的索引</span></span><br><span class="line">    <span class="comment">// j 作为线性表 A2——(mid, high] 的索引</span></span><br><span class="line">    <span class="comment">// k 作为线性表 A 的索引，将符合条件的元素依次根据k放入A中</span></span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="comment">// 先将小的放到A中</span></span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束时，两个线性表中最多只有一个线性表的元素还没放完</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        <span class="comment">// 线性表A1剩余的元素放入A中</span></span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 线性表A2剩余的元素放入A中</span></span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序——递归调用</span></span><br><span class="line"><span class="comment">// 递归出口：当low&gt;=high时，也就是划分到每一个有序序列或为空或仅有一个元素</span></span><br><span class="line"><span class="comment">// 递归体：将当前区间分成两个区间——[low, mid]和(mid, high]，分别进行归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;         <span class="comment">// 将这个区间对半分，分别归并</span></span><br><span class="line">        MergeSort(A, low, mid);             <span class="comment">// 左半部分——[low, mid]</span></span><br><span class="line">        MergeSort(A, mid + <span class="number">1</span>, high);    <span class="comment">// 右半部分——(mid, high]</span></span><br><span class="line">        Merge(A, low, mid, high);           <span class="comment">// 将归并结束之后的两个有序序列合并到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327195913.png" alt="二路归并实例"></p>
<p>归并排序是一个时间复杂度为O(nlog2(n))、空间复杂度为O(n)的<strong>稳定</strong>的排序算法；适用于顺序存储(数组)和链式存储(链表)。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序：借助”分配”和”收集”两种操作对单逻辑关键字进行排序，分为最高位有序(MSD)和最低位优先(LSD)。特点：不基于比较</p>
<p>以r为基数的最低位优先基数排序：假设线性表由结点序列a0, a1, ……, an-1构成，每个结点aj的关键字有d元组(kj^(d-1), kj^(d-2), ……, kj^(1), kj^(0))组成，0&lt;=kj^(i)\&lt;=r-1(0&lt;=j&lt;n, 0&lt;=i&lt;=d-1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个线性表的每个结点的关键字可以记为如下：</span><br><span class="line">324, 768, 270, 121, 962, 666, 857, 503, 768</span><br><span class="line">那么对于这个线性表，有：</span><br><span class="line">n&#x3D;9：线性表共有9个数据元素——a0到an-1</span><br><span class="line">d&#x3D;3：每个结点的关键字是3元组(上面的关键字都是3位数)</span><br><span class="line">r&#x3D;10：d元组的每个k取值在[0, 10)中，即0~9</span><br></pre></td></tr></table></figure>

<ul>
<li>分配和收集：在排序时使用r个队列Q0, Q1, ……, Qr-1<ul>
<li>分配：开始时，把各个队列置空，然后依次考察每个结点的关键字，若aj的关键字中kj^(i)=k，就把aj放入队列Qk当中</li>
<li>收集：把各个队列中的结点依次首尾相接，得到一个新的结点序列，组成线性表</li>
<li>经过d次(按照i由小到大的顺序)分配收集之后，序列会成为一个有序的序列</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327202945.png" alt="基数排序实例"></p>
<p>时间复杂度：O(d(n+r))；d——d元组；n——线性表元素个数；r——d元组中每个k值的取值范围</p>
<p>基数排序是一个时间复杂度为O(d(n+r))、空间复杂度为O(r)的<strong>稳定</strong>的排序算法；不基于比较。</p>
<h2 id="内部排序方法对比"><a href="#内部排序方法对比" class="headerlink" title="内部排序方法对比"></a>内部排序方法对比</h2><p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210327204641.png" alt="内部排序方法的对比——不带“折半插入排序”是因为其仅是在“直接插入排序”的查找方面进行了优化"></p>
<ul>
<li><p>选择内部排序算法时的考虑因素：</p>
<ul>
<li>元素数目：<ul>
<li>n较小时(n&lt;=50)，一般采用直接插入排序或简单选择排序</li>
<li>n较大时，一般采用快速排序、堆排序或归并排序</li>
<li>n特别大，记录关键字位数较少且可分解时，采用基数排序</li>
</ul>
</li>
<li>元素大小：数据元素类型的存储空间大小，当占用空间大时，采用“交换元素位置”的排序算法(如“冒泡排序”)时，会因为交换元素而耗用大量时间<ul>
<li>即尽量避免大量移动的排序算法，尽量采用链式存储</li>
</ul>
</li>
<li>关键字结构及分布：<ul>
<li>关键字结构：关键字可以分割成某些位时，可以采用基数排序</li>
<li>分布：初始序列是否有序<ul>
<li>初始序列有序时：一般不考虑快速排序，而是采用直接插入或冒泡排序</li>
</ul>
</li>
</ul>
</li>
<li>稳定性：是否要求稳定排序算法</li>
<li>存储结构：是否支持链式存储结构，以及实现链式存储结构的排序时是否麻烦</li>
<li>辅助空间：对于辅助空间大小有无限制要求</li>
<li>……</li>
</ul>
</li>
<li><p>元素数目n较大时：</p>
<ul>
<li>快速排序：初始序列有序时不建议采用；辅助空间有限制</li>
<li>堆排序：不稳定</li>
<li>归并排序：稳定</li>
</ul>
</li>
</ul>
<p>当文件的n个关键字随机分布时，任何借助“比较”的排序，至少需要O(nlog2(n))的时间</p>
<table>
<thead>
<tr>
<th>内部排序方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性质</th>
<th>适用存储结构</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>顺序、链式</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>顺序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>顺序</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>顺序、链式</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2(n))</td>
<td>O(log2(n))</td>
<td>不稳定</td>
<td>顺序(链式)</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>顺序、链式</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2(n))</td>
<td>O(1)</td>
<td>不稳定</td>
<td>顺序(链式)</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2(n))</td>
<td>O(n)</td>
<td>稳定</td>
<td>顺序、链式</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(r)</td>
<td>稳定</td>
<td>不基于比较</td>
</tr>
</tbody></table>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><blockquote>
<p>外部排序方面似乎不常考，但是要知道概念和常用排序方法(大概)，往年考研题我只做到了一道关于外部排序的选择题，涉及的是<strong>最佳归并树</strong>的知识</p>
</blockquote>
<h3 id="归并排序算法——基础算法"><a href="#归并排序算法——基础算法" class="headerlink" title="归并排序算法——基础算法"></a>归并排序算法——基础算法</h3><p>外部排序通常采用<strong>归并排序</strong>方法：首先，根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，<strong>依次读入内存</strong>并利用有限的<strong>内部排序算法</strong>对它们进行排序，并将排序后得到的<strong>有序子文件重新写回外存</strong>，通常称这些有序子文件为<strong>归并段</strong>或<strong>顺串</strong>；然后对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件</p>
<p>一般将内存分为三个缓冲区：输入缓冲区1(从第一段中输入)、输入缓冲区2(从第二段中输入)、输出缓冲区(预计写入到文件中的数据)。</p>
<p>以两个相邻有序段——归并段1[1, 3, 5, 8]与归并段2[2, 4, 6, 7]为例(归并段1在外存上排在归并段2之前)，不妨以$表示已经读入到内存中的数据(这里只是为了更直观的表示排序过程，并不是真的外存内容被设置为$)，内存可容纳6个数据元素，均分为三段——输入缓冲区1、输入缓冲区2、输出缓冲区：</p>
<table>
<thead>
<tr>
<th align="center">归并段1</th>
<th align="center">归并段2</th>
<th>输入缓冲区1</th>
<th>输入缓冲区2</th>
<th>输出缓冲区</th>
<th align="left">输出文件</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1, 3, 5, 8</td>
<td align="center">2, 4, 6, 7</td>
<td></td>
<td></td>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td>1, 3</td>
<td>2, 4</td>
<td></td>
<td align="left"></td>
<td>读入1,3到输入缓冲区1，读入2,4到输入缓冲区2</td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td>1, 3</td>
<td>2, 4</td>
<td>1</td>
<td align="left"></td>
<td>1与2进行比较，1进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td>1, 3</td>
<td>2, 4</td>
<td>1, 2</td>
<td align="left"></td>
<td>3与2进行比较，2进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td>1, 3</td>
<td>2, 4</td>
<td></td>
<td align="left">1, 2</td>
<td>输出缓冲区已满，输出到外存</td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td>1, 3</td>
<td>2, 4</td>
<td>3</td>
<td align="left">1, 2</td>
<td>3与4进行比较，3进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, 5, 8</td>
<td align="center">$, $, 6, 7</td>
<td></td>
<td>2, 4</td>
<td>3</td>
<td align="left">1, 2</td>
<td>输入缓冲区1已比较完毕，清空输入缓冲区1</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, 6, 7</td>
<td>5, 8</td>
<td>2, 4</td>
<td>3</td>
<td align="left">1, 2</td>
<td>读入5,8到输入缓冲区1</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, 6, 7</td>
<td>5, 8</td>
<td>2, 4</td>
<td>3, 4</td>
<td align="left">1, 2, 3, 4</td>
<td>5与4进行比较，4进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, 6, 7</td>
<td>5, 8</td>
<td>2, 4</td>
<td></td>
<td align="left">1, 2, 3, 4</td>
<td>输出缓冲区已满，输出到外存</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, 6, 7</td>
<td>5, 8</td>
<td></td>
<td></td>
<td align="left">1, 2, 3, 4</td>
<td>输入缓冲区2已比较完毕，清空输入缓冲区2</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td>6, 7</td>
<td></td>
<td align="left">1, 2, 3, 4</td>
<td>读入6,7到输入缓冲区2</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td>6, 7</td>
<td>5</td>
<td align="left">1, 2, 3, 4</td>
<td>5与6进行比较，5进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td>6, 7</td>
<td>5, 6</td>
<td align="left">1, 2, 3, 4</td>
<td>6与8进行比较，6进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td>6, 7</td>
<td></td>
<td align="left">1, 2, 3, 4, 5, 6</td>
<td>输出缓冲区已满，输出到外存</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td>6, 7</td>
<td>7</td>
<td align="left">1, 2, 3, 4, 5, 6</td>
<td>7与8进行比较，7进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td></td>
<td>7</td>
<td align="left">1, 2, 3, 4, 5, 6</td>
<td>输出缓冲区2已比较完毕，清空输入缓冲区2</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td></td>
<td>7, 8</td>
<td align="left">1, 2, 3, 4, 5, 6</td>
<td>8进入输出缓冲区</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td>5, 8</td>
<td></td>
<td></td>
<td align="left">1, 2, 3, 4, 5, 6, 7, 8</td>
<td>输出缓冲区已满，输出到外存</td>
</tr>
<tr>
<td align="center">$, $, $, $</td>
<td align="center">$, $, $, $</td>
<td></td>
<td></td>
<td></td>
<td align="left">1, 2, 3, 4, 5, 6, 7, 8</td>
<td>输入缓冲区1已比较完毕，清空输入缓冲区1</td>
</tr>
</tbody></table>
<p>即对上述两个外存中的两个有序段归并之后输出文件中的数据序列即为有序序列</p>
<p>使用<strong>归并排序</strong>的方法进行外部排序时，只需不断执行上述过程，便可以得到排好序的外存中的大量数据的文件。</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330095112.png" alt="2路归并"></p>
<p>外部排序的总时间=内部排序所需时间(单个小归并段使用内部排序方法排序为有序序列)+外存信息读写时间(I/O时间)+内部归并所需时间(两个相邻的归并段进行上述归并操作)</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330095424.png" alt="image-20210330095424602"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tES——外部排序的总时间</span><br><span class="line">r——初始把外存中的文件一共划分为r段</span><br><span class="line">tIS——每段进行内部排序所需时间</span><br><span class="line">d——总共进行的I&#x2F;O次数，一次读取记一次，一次写入记一次——(S+1)*(2*r)</span><br><span class="line">tIO——每段读取或者写入所花费的时间</span><br><span class="line">S——归并趟数，如上图所示的归并共进行了2趟(中间的线是趟)</span><br><span class="line">(n-1)——每一趟所需的比较次数</span><br><span class="line">tmg——一次内部归并比较所需时间</span><br><span class="line"></span><br><span class="line">不妨举这么一个例子：初始记录有20000个记录，初始归并段5000个记录</span><br><span class="line">r&#x3D;20000&#x2F;5000&#x3D;4——初始把外存中的文件一共划分为4段，每段5000个记录(如上图所示)</span><br><span class="line">S&#x3D;2——4-&gt;2-&gt;1，中间的-&gt;代表一趟</span><br><span class="line">d&#x3D;(S+1)*(2*r)&#x3D;3*(2*4)——一段读或写需要tIO，划分为r段，则读取r次写入r次，即整个文件一次读写花费2*r次，4-&gt;2-&gt;1可知需要读写3轮，即3*(2*r)</span><br><span class="line">n&#x3D;20000——20000个数据</span><br><span class="line">S(n-1)&#x3D;2*(20000-1)&#x3D;2*20000——20000&gt;&gt;1，1可忽略</span><br><span class="line">即tES&#x3D;4*tIS+3*(2*4)tIO+2*20000tmg</span><br></pre></td></tr></table></figure>

<p>从2路归并变为4路归并之后，读写时间会发生改变，如下图所示，归并趟数由2变为了1，外存信息读写时间由3*(2*4)tIO变为了2*(2*4)tIO，即增大归并路数减少归并段数可以有效减少外存信息读写时间，减少外部排序的总时间。</p>
<p>归并趟数=logm(r)向上取整(以m为底r的对数向上取整，其中m是归并路数，r是划分的段数)，比如上述例子的2路归并中，m=2，r=4，log2(4)向上取整为2，即2趟归并。</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330153143.png" alt="4路归并"></p>
<h3 id="败者树——优化m"><a href="#败者树——优化m" class="headerlink" title="败者树——优化m"></a>败者树——优化m</h3><ul>
<li>S趟归并总共需要比较的次数——S(n-1)(m-1)<ul>
<li>S：归并趟数</li>
<li>n：关键字个数</li>
<li>m-1：求得最小的关键字比较所需的时间，m路归并，一次比较需要比较m-1次才可以求出最小的关键字</li>
</ul>
</li>
</ul>
<p>败者树：树形选择排序的一种变体，可视为一棵完全二叉树。每个叶子结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，胜利者向上记录进行比较，直到根结点</p>
<p>如图所示是一棵败者树的实例的前两轮，依次按照败者树的比较方法向下进行即可。</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330161030.png" alt="败者树的前两轮比较示例"></p>
<p>败者树可以减少比较次数，按照归并路数计算来说，5路归并，每次确定一个最小值需要比较5-1=4次，但是从第二轮开始，仅需与双亲结点记录的位置进行比较，比如如图所示的第二轮仅比较了3次就确定了当前最小值——9，倘若继续进行下去，可知第三轮需要比较b1(18)与b2(20)得到b1(18)上移，然后b1(18)与b0(10)得到b0(10)上移，1号结点记录由bo(10)-&gt;b1(18)，即第三轮仅比较了两次就确定了当前的最小值——10。</p>
<p>每次确定最小值所需的比较次数变为了树的高度，而树的高度就是log2(m)向上取整(以2为底m的对数向上取整)</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330161906.png" alt="image-20210330161906846"></p>
<h3 id="置换-选择排序——优化r"><a href="#置换-选择排序——优化r" class="headerlink" title="置换-选择排序——优化r"></a>置换-选择排序——优化r</h3><ul>
<li>置换-选择排序：设初始待排序文件为FI，初始归并段文件为FO，内存工作区为WA，内存工作区可容纳w个记录<ol>
<li>从待排序文件FI输入w个记录到工作区WA中</li>
<li>从内存工作区WA中选出其中关键字取最小值的记录，记为MINIMAX</li>
<li>将MINIMAX记录输出到FO中</li>
<li>若FI未读完，则从FI输入下一个记录到WA中</li>
<li>从WA中所有关键字比MINMAX记录的关键字大的记录中选出最小的关键字记录，作为新的MINIMAX</li>
<li>重复3.~5.直到WA中选不出新的MINIMAX记录位置，由此得到一个初始归并段，输出一个归并段的结束标志到FO中</li>
<li>重复2.~6.直到WA为空，由此得到全部初始归并段</li>
</ol>
</li>
<li>排序结束之后，得到了若干个大小不等的初始归并段</li>
</ul>
<table>
<thead>
<tr>
<th align="right">输入文件FI</th>
<th>内存工作区WA</th>
<th>MINIMAX</th>
<th align="left">输出文件FO</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td align="right">17, 21, 05, 44, 10, 12, 56, 32, 29</td>
<td></td>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="right">44, 10, 12, 56, 32, 29</td>
<td>17, 21, 05</td>
<td></td>
<td align="left"></td>
<td>读入17, 21, 05到工作区WA中</td>
</tr>
<tr>
<td align="right">10, 12, 56, 32, 29</td>
<td>17, 21, 44</td>
<td>05</td>
<td align="left">05</td>
<td>输出05到FO中，读入44到WA中</td>
</tr>
<tr>
<td align="right">12, 56, 32, 29</td>
<td>10, 21, 44</td>
<td>05-&gt;17</td>
<td align="left">05, 17</td>
<td>输出17到FO中，读入10到WA中</td>
</tr>
<tr>
<td align="right">56, 32, 29</td>
<td>10, 12, 44</td>
<td>17-&gt;21</td>
<td align="left">05, 17, 21</td>
<td>输出21到FO中，读入12到WA中</td>
</tr>
<tr>
<td align="right">32, 29</td>
<td>10, 12, 56</td>
<td>21-&gt;44</td>
<td align="left">05, 17, 21, 44</td>
<td>输出44到FO中，读入56到WA中</td>
</tr>
<tr>
<td align="right">29</td>
<td>10, 12, 32</td>
<td>44-&gt;56</td>
<td align="left">05, 17, 21, 44, 56</td>
<td>输出56到FO中，读入32到WA中</td>
</tr>
<tr>
<td align="right">29</td>
<td>10, 12, 32</td>
<td></td>
<td align="left">05, 17, 21, 44, 56, #</td>
<td>没有比56大的关键字，输出归并段结束标志#到FO中，MNIMAX置空</td>
</tr>
<tr>
<td align="right"></td>
<td>29, 12, 32</td>
<td>10</td>
<td align="left">10</td>
<td>输出10到FO中，读入29到WA中</td>
</tr>
<tr>
<td align="right"></td>
<td>29, $, 32</td>
<td>10-&gt;12</td>
<td align="left">10, 12</td>
<td>输出12到FO中</td>
</tr>
<tr>
<td align="right"></td>
<td>$, $, 32</td>
<td>12-&gt;29</td>
<td align="left">10, 12, 29</td>
<td>输出29到FO中</td>
</tr>
<tr>
<td align="right"></td>
<td></td>
<td>29-&gt;32</td>
<td align="left">10, 12, 29, 32</td>
<td>输出32到FO中</td>
</tr>
<tr>
<td align="right"></td>
<td></td>
<td></td>
<td align="left">10, 12, 29, 32, #</td>
<td>FI为空、WA为空，置换-选择排序结束，输出归并段结束标志#到FO中</td>
</tr>
</tbody></table>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>归并树：用来描述m归并，并只有度为0和度为m的结点的严格m叉树(m路归并可以用一棵m叉树描述)。</p>
<p>设由置换-选择排序得到了9个初始归并段，他们的记录长度依次为：9, 30, 12, 18, 3, 17, 2, 6, 24</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330170636.png" alt="普通归并树"></p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330171100.png" alt="最佳归并树——哈夫曼树"></p>
<p>当叶子结点数不够时，需要增加权值为0的结点用来构造哈夫曼树</p>
<p>设由置换-选择排序得到了8个初始归并段，其记录的长度依次为9, 12, 18, 3, 17, 2, 6, 24</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330171619.png" alt="image-20210330171619424"></p>
<ul>
<li>需要补充的虚段个数：设度为0的结点有n0个，度为m的结点由Nm个，则对严格的m叉树有n0=(m-1)Nm+1，即得Nm=(n0-1)/(m-1)——可以被整除<ul>
<li>若(n0-1)%(m-1)==0，则说明对于这个n0个叶子结点(初始归并段)可以构造m叉树归并树</li>
<li>若(n0-1)%(m-1)=u≠0，则说明对于这个n0个叶子结点(初始归并段)，其中有u个多余结点——多出u个结点时，需要补充m-u-1个结点</li>
</ul>
</li>
</ul>
<p>例如有10个叶子结点时，做3路归并排序：</p>
<p><img src="https://gitee.com/leok77/blog-img-leok77/raw/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/20210330172918.png" alt="image-20210330172918028"></p>
<p>m-u-1：将某个叶子结点新补充为一个m叉树，“-1”减去原叶子结点，“-u”减去多余的叶子结点，m-u-1则为这棵新补充的m叉树还需要的虚段结点个数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:17560376405@163.com">LeoK77</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.leok77.cn/2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/">https://www.leok77.cn/2021/03/27/数据结构/数据结构-第八章-排序/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.leok77.cn" target="_blank">LeoK77</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/"><img class="prev-cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构-第七章-查找</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/"><img class="next-cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构实例</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/22/数据结构/数据结构-第一章-绪论/" title="数据结构-第一章-绪论"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-22</div><div class="title">数据结构-第一章-绪论</div></div></a></div><div><a href="/2021/03/27/数据结构/数据结构-第七章-查找/" title="数据结构-第七章-查找"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">数据结构-第七章-查找</div></div></a></div><div><a href="/2021/04/11/数据结构/数据结构-第四章-串/" title="数据结构-第四章-串"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">数据结构-第四章-串</div></div></a></div><div><a href="/2021/04/10/数据结构/数据结构-第三章-栈和队列/" title="数据结构-第三章-栈和队列"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">数据结构-第三章-栈和队列</div></div></a></div><div><a href="/2021/03/24/数据结构/数据结构-第二章-线性表/" title="数据结构-第二章-线性表"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-24</div><div class="title">数据结构-第二章-线性表</div></div></a></div><div><a href="/2021/04/13/数据结构/数据结构-第五章-树与二叉树/" title="数据结构-第五章-树与二叉树"><img class="cover" src="/img/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-13</div><div class="title">数据结构-第五章-树与二叉树</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LeoK77</div><div class="author-info__description">考えたくはないよ  馬鹿になっていたいもん</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leok77"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leok77" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:17560376405@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">内部排序方法对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">归并排序算法——基础算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96m"><span class="toc-number">8.2.</span> <span class="toc-text">败者树——优化m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96r"><span class="toc-number">8.3.</span> <span class="toc-text">置换-选择排序——优化r</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">8.4.</span> <span class="toc-text">最佳归并树</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By LeoK77</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '2f220532af9d5da3f585',
      clientSecret: '4dd9b398df123d0c1ddd42c6ed6a6122236053fb',
      repo: 'leok77.github.io',
      owner: 'leok77',
      admin: ['leok77'],
      id: '84ecb6b7c2395230db46c6a8349a96dd',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>